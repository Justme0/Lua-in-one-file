/*
 * one.c -- Lua core, libraries, and interpreter in a single file
 */

/* default is to build the full interpreter */
/* choose suitable platform-specific features */
/* some of these may need extra libraries such as -ldl -lreadline -lncurses */

/* no need to change anything below this line ----------------------------- */

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
** Allows POSIX/XSI stuff
*/
/*
** Allows manipulation of large files in gcc and some other compilers
*/
/*
** Windows stuff
*/

/*
        assert.h
*/

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */

/* newlib.h.  Generated from newlib.hin by configure.  */
/* newlib.hin.  Manually edited from the output of autoheader to
   remove all PACKAGE_ macros which will collide with any user
   package using newlib header files and having its own package name,
   version, etc...  */

/* EL/IX level */
/* #undef _ELIX_LEVEL */

/* Newlib version */
/* _newlib_version.h.  Generated from _newlib_version.hin by configure.  */
/* Version macros for internal and downstream use. */

/* C99 formats support (such as %a, %zu, ...) in IO functions like
 * printf/scanf enabled */

/* long long type support in IO functions like printf/scanf enabled */

/* Register application finalization function using atexit. */
/* #undef _WANT_REGISTER_FINI */

/* long double type support in IO functions like printf/scanf enabled */

/* Positional argument support in printf functions enabled.  */

/* Optional reentrant struct support.  Used mostly on platforms with
   very restricted storage.  */
/* #undef _WANT_REENT_SMALL */

/* Multibyte supported */

/* MB_LEN_MAX */

/* ICONV enabled */
/* #undef _ICONV_ENABLED */

/* Enable ICONV external CCS files loading capabilities */
/* #undef _ICONV_ENABLE_EXTERNAL_CCS */

/* Define if the linker supports .preinit_array/.init_array/.fini_array
 * sections.  */
/* #undef HAVE_INITFINI_ARRAY */

/* True if atexit() may dynamically allocate space for cleanup
   functions.  */

/* True if long double supported.  */

/* Define if compiler supports -fno-tree-loop-distribute-patterns. */

/* True if long double supported and it is equal to double.  */
/* #undef _LDBL_EQ_DBL */

/* Define if ivo supported in streamio.  */

/* Define if fseek functions support seek optimization.  */

/* Define if wide char orientation is supported.  */

/* Define if unbuffered stream file optimization is supported.  */

/* Define if lite version of exit supported.  */
/* #undef _LITE_EXIT */

/* Define if declare atexit data as global.  */
/* #undef _REENT_GLOBAL_ATEXIT */

/* Define to move the stdio stream FILE objects out of struct _reent and make
   them global.  The stdio stream pointers of struct _reent are initialized to
   point to the global stdio FILE stream objects. */
/* #undef _WANT_REENT_GLOBAL_STDIO_STREAMS */

/* Define if small footprint nano-formatted-IO implementation used.  */
/* #undef _NANO_FORMATTED_IO */

/* Define if using retargetable functions for default lock routines.  */
/* #undef _RETARGETABLE_LOCKING */

/* Define to use type long for time_t.  */
/* #undef _WANT_USE_LONG_TIME_T */

/*
 * Iconv encodings enabled ("to" direction)
 */
/* #undef _ICONV_TO_ENCODING_BIG5 */
/* #undef _ICONV_TO_ENCODING_CP775 */
/* #undef _ICONV_TO_ENCODING_CP850 */
/* #undef _ICONV_TO_ENCODING_CP852 */
/* #undef _ICONV_TO_ENCODING_CP855 */
/* #undef _ICONV_TO_ENCODING_CP866 */
/* #undef _ICONV_TO_ENCODING_EUC_JP */
/* #undef _ICONV_TO_ENCODING_EUC_TW */
/* #undef _ICONV_TO_ENCODING_EUC_KR */
/* #undef _ICONV_TO_ENCODING_ISO_8859_1 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_10 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_11 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_13 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_14 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_15 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_2 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_3 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_4 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_5 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_6 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_7 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_8 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_9 */
/* #undef _ICONV_TO_ENCODING_ISO_IR_111 */
/* #undef _ICONV_TO_ENCODING_KOI8_R */
/* #undef _ICONV_TO_ENCODING_KOI8_RU */
/* #undef _ICONV_TO_ENCODING_KOI8_U */
/* #undef _ICONV_TO_ENCODING_KOI8_UNI */
/* #undef _ICONV_TO_ENCODING_UCS_2 */
/* #undef _ICONV_TO_ENCODING_UCS_2_INTERNAL */
/* #undef _ICONV_TO_ENCODING_UCS_2BE */
/* #undef _ICONV_TO_ENCODING_UCS_2LE */
/* #undef _ICONV_TO_ENCODING_UCS_4 */
/* #undef _ICONV_TO_ENCODING_UCS_4_INTERNAL */
/* #undef _ICONV_TO_ENCODING_UCS_4BE */
/* #undef _ICONV_TO_ENCODING_UCS_4LE */
/* #undef _ICONV_TO_ENCODING_US_ASCII */
/* #undef _ICONV_TO_ENCODING_UTF_16 */
/* #undef _ICONV_TO_ENCODING_UTF_16BE */
/* #undef _ICONV_TO_ENCODING_UTF_16LE */
/* #undef _ICONV_TO_ENCODING_UTF_8 */
/* #undef _ICONV_TO_ENCODING_WIN_1250 */
/* #undef _ICONV_TO_ENCODING_WIN_1251 */
/* #undef _ICONV_TO_ENCODING_WIN_1252 */
/* #undef _ICONV_TO_ENCODING_WIN_1253 */
/* #undef _ICONV_TO_ENCODING_WIN_1254 */
/* #undef _ICONV_TO_ENCODING_WIN_1255 */
/* #undef _ICONV_TO_ENCODING_WIN_1256 */
/* #undef _ICONV_TO_ENCODING_WIN_1257 */
/* #undef _ICONV_TO_ENCODING_WIN_1258 */

/*
 * Iconv encodings enabled ("from" direction)
 */
/* #undef _ICONV_FROM_ENCODING_BIG5 */
/* #undef _ICONV_FROM_ENCODING_CP775 */
/* #undef _ICONV_FROM_ENCODING_CP850 */
/* #undef _ICONV_FROM_ENCODING_CP852 */
/* #undef _ICONV_FROM_ENCODING_CP855 */
/* #undef _ICONV_FROM_ENCODING_CP866 */
/* #undef _ICONV_FROM_ENCODING_EUC_JP */
/* #undef _ICONV_FROM_ENCODING_EUC_TW */
/* #undef _ICONV_FROM_ENCODING_EUC_KR */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_1 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_10 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_11 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_13 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_14 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_15 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_2 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_3 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_4 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_5 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_6 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_7 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_8 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_9 */
/* #undef _ICONV_FROM_ENCODING_ISO_IR_111 */
/* #undef _ICONV_FROM_ENCODING_KOI8_R */
/* #undef _ICONV_FROM_ENCODING_KOI8_RU */
/* #undef _ICONV_FROM_ENCODING_KOI8_U */
/* #undef _ICONV_FROM_ENCODING_KOI8_UNI */
/* #undef _ICONV_FROM_ENCODING_UCS_2 */
/* #undef _ICONV_FROM_ENCODING_UCS_2_INTERNAL */
/* #undef _ICONV_FROM_ENCODING_UCS_2BE */
/* #undef _ICONV_FROM_ENCODING_UCS_2LE */
/* #undef _ICONV_FROM_ENCODING_UCS_4 */
/* #undef _ICONV_FROM_ENCODING_UCS_4_INTERNAL */
/* #undef _ICONV_FROM_ENCODING_UCS_4BE */
/* #undef _ICONV_FROM_ENCODING_UCS_4LE */
/* #undef _ICONV_FROM_ENCODING_US_ASCII */
/* #undef _ICONV_FROM_ENCODING_UTF_16 */
/* #undef _ICONV_FROM_ENCODING_UTF_16BE */
/* #undef _ICONV_FROM_ENCODING_UTF_16LE */
/* #undef _ICONV_FROM_ENCODING_UTF_8 */
/* #undef _ICONV_FROM_ENCODING_WIN_1250 */
/* #undef _ICONV_FROM_ENCODING_WIN_1251 */
/* #undef _ICONV_FROM_ENCODING_WIN_1252 */
/* #undef _ICONV_FROM_ENCODING_WIN_1253 */
/* #undef _ICONV_FROM_ENCODING_WIN_1254 */
/* #undef _ICONV_FROM_ENCODING_WIN_1255 */
/* #undef _ICONV_FROM_ENCODING_WIN_1256 */
/* #undef _ICONV_FROM_ENCODING_WIN_1257 */
/* #undef _ICONV_FROM_ENCODING_WIN_1258 */

/* This file can define macros to choose variations of the IEEE float
   format:

   _FLT_LARGEST_EXPONENT_IS_NORMAL

        Defined if the float format uses the largest exponent for finite
        numbers rather than NaN and infinity representations.  Such a
        format cannot represent NaNs or infinities at all, but it's FLT_MAX
        is twice the IEEE value.

   _FLT_NO_DENORMALS

        Defined if the float format does not support IEEE denormals.  Every
        float with a zero exponent is taken to be a zero representation.

   ??? At the moment, there are no equivalent macros above for doubles and
   the macros are not fully supported by --enable-newlib-hw-fp.

   __IEEE_BIG_ENDIAN

        Defined if the float format is big endian.  This is mutually exclusive
        with __IEEE_LITTLE_ENDIAN.

   __IEEE_LITTLE_ENDIAN

        Defined if the float format is little endian.  This is mutually
   exclusive with __IEEE_BIG_ENDIAN.

   Note that one of __IEEE_BIG_ENDIAN or __IEEE_LITTLE_ENDIAN must be specified
   for a platform or error will occur.

   __IEEE_BYTES_LITTLE_ENDIAN

        This flag is used in conjunction with __IEEE_BIG_ENDIAN to describe a
   situation whereby multiple words of an IEEE floating point are in big endian
   order, but the words themselves are little endian with respect to the bytes.

   _DOUBLE_IS_32BITS

        This is used on platforms that support double by using the 32-bit IEEE
        float type.

   _FLOAT_ARG

        This represents what type a float arg is passed as.  It is used when the
   type is not promoted to double.


   __OBSOLETE_MATH_DEFAULT

        Default value for __OBSOLETE_MATH if that's not set by the user.
        It should be set here based on predefined feature macros.

   __OBSOLETE_MATH

        If set to 1 then some new math code will be disabled and older libm
        code will be used instead.  This is necessary because the new math
        code does not support all targets, it assumes that the toolchain has
        ISO C99 support (hexfloat literals, standard fenv semantics), the
        target has IEEE-754 conforming binary32 float and binary64 double
        (not mixed endian) representation, standard SNaN representation,
        double and single precision arithmetics has similar latency and it
        has no legacy SVID matherr support, only POSIX errno and fenv
        exception based error handling.
*/
/* necv70 was __IEEE_LITTLE_ENDIAN. */
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */
/* _newlib_version.h.  Generated from _newlib_version.hin by configure.  */
/* Version macros for internal and downstream use. */

/* Macro to test version of GCC.  Returns 0 for non-GCC or too old GCC. */
/* Version with trailing underscores for BSD compatibility. */

/*
 * Feature test macros control which symbols are exposed by the system
 * headers.  Any of these must be defined before including any headers.
 *
 * __STRICT_ANSI__ (defined by gcc -ansi, -std=c90, -std=c99, or -std=c11)
 *	ISO C
 *
 * _POSIX_SOURCE (deprecated by _POSIX_C_SOURCE=1)
 * _POSIX_C_SOURCE >= 1
 * 	POSIX.1-1990
 *
 * _POSIX_C_SOURCE >= 2
 * 	POSIX.2-1992
 *
 * _POSIX_C_SOURCE >= 199309L
 * 	POSIX.1b-1993 Real-time extensions
 *
 * _POSIX_C_SOURCE >= 199506L
 * 	POSIX.1c-1995 Threads extensions
 *
 * _POSIX_C_SOURCE >= 200112L
 * 	POSIX.1-2001 and C99
 *
 * _POSIX_C_SOURCE >= 200809L
 * 	POSIX.1-2008
 *
 * _XOPEN_SOURCE
 *	POSIX.1-1990 and XPG4
 *
 * _XOPEN_SOURCE_EXTENDED
 *	SUSv1 (POSIX.2-1992 plus XPG4v2)
 *
 * _XOPEN_SOURCE >= 500
 *	SUSv2 (POSIX.1c-1995 plus XSI)
 *
 * _XOPEN_SOURCE >= 600
 *	SUSv3 (POSIX.1-2001 plus XSI) and C99
 *
 * _XOPEN_SOURCE >= 700
 *	SUSv4 (POSIX.1-2008 plus XSI)
 *
 * _ISOC99_SOURCE or gcc -std=c99 or g++
 * 	ISO C99
 *
 * _ISOC11_SOURCE or gcc -std=c11 or g++ -std=c++11
 * 	ISO C11
 *
 * _ATFILE_SOURCE (implied by _POSIX_C_SOURCE >= 200809L)
 *	"at" functions
 *
 * _LARGEFILE_SOURCE (deprecated by _XOPEN_SOURCE >= 500)
 *	fseeko, ftello
 *
 * _GNU_SOURCE
 * 	All of the above plus GNU extensions
 *
 * _BSD_SOURCE (deprecated by _DEFAULT_SOURCE)
 * _SVID_SOURCE (deprecated by _DEFAULT_SOURCE)
 * _DEFAULT_SOURCE (or none of the above)
 * 	POSIX-1.2008 with BSD and SVr4 extensions
 *
 * _FORTIFY_SOURCE = 1 or 2
 * 	Object Size Checking function wrappers
 */
/*
 * The following private macros are used throughout the headers to control
 * which symbols should be exposed.  They are for internal use only, as
 * indicated by the leading double underscore, and must never be used outside
 * of these headers.
 *
 * __POSIX_VISIBLE
 * 	any version of POSIX.1; enabled by default, or with _POSIX_SOURCE,
 * 	any value of _POSIX_C_SOURCE, or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 2
 * 	POSIX.2-1992; enabled by default, with _POSIX_C_SOURCE >= 2,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 199309
 * 	POSIX.1b-1993; enabled by default, with _POSIX_C_SOURCE >= 199309L,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 199506
 * 	POSIX.1c-1995; enabled by default, with _POSIX_C_SOURCE >= 199506L,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 200112
 * 	POSIX.1-2001; enabled by default, with _POSIX_C_SOURCE >= 200112L,
 * 	or _XOPEN_SOURCE >= 600.
 *
 * __POSIX_VISIBLE >= 200809
 * 	POSIX.1-2008; enabled by default, with _POSIX_C_SOURCE >= 200809L,
 * 	or _XOPEN_SOURCE >= 700.
 *
 * __XSI_VISIBLE
 *	XPG4 XSI extensions; enabled with any version of _XOPEN_SOURCE.
 *
 * __XSI_VISIBLE >= 4
 *	SUSv1 XSI extensions; enabled with both _XOPEN_SOURCE and
 * 	_XOPEN_SOURCE_EXTENDED together.
 *
 * __XSI_VISIBLE >= 500
 *	SUSv2 XSI extensions; enabled with _XOPEN_SOURCE >= 500.
 *
 * __XSI_VISIBLE >= 600
 *	SUSv3 XSI extensions; enabled with _XOPEN_SOURCE >= 600.
 *
 * __XSI_VISIBLE >= 700
 *	SUSv4 XSI extensions; enabled with _XOPEN_SOURCE >= 700.
 *
 * __ISO_C_VISIBLE >= 1999
 * 	ISO C99; enabled with gcc -std=c99 or newer (on by default since GCC 5),
 * 	any version of C++, or with _ISOC99_SOURCE, _POSIX_C_SOURCE >= 200112L,
 * 	or _XOPEN_SOURCE >= 600.
 *
 * __ISO_C_VISIBLE >= 2011
 * 	ISO C11; enabled with gcc -std=c11 or newer (on by default since GCC 5),
 * 	g++ -std=c++11 or newer (on by default since GCC 6), or with
 * 	_ISOC11_SOURCE.
 *
 * __ATFILE_VISIBLE
 *	"at" functions; enabled by default, with _ATFILE_SOURCE,
 * 	_POSIX_C_SOURCE >= 200809L, or _XOPEN_SOURCE >= 700.
 *
 * __LARGEFILE_VISIBLE
 *	fseeko, ftello; enabled with _LARGEFILE_SOURCE or _XOPEN_SOURCE >= 500.
 *
 * __BSD_VISIBLE
 * 	BSD extensions; enabled by default, or with _BSD_SOURCE.
 *
 * __SVID_VISIBLE
 * 	SVr4 extensions; enabled by default, or with _SVID_SOURCE.
 *
 * __MISC_VISIBLE
 * 	Extensions found in both BSD and SVr4 (shorthand for
 * 	(__BSD_VISIBLE || __SVID_VISIBLE)), or newlib-specific
 * 	extensions; enabled by default.
 *
 * __GNU_VISIBLE
 * 	GNU extensions; enabled with _GNU_SOURCE.
 *
 * __SSP_FORTIFY_LEVEL
 * 	Object Size Checking; defined to 0 (off), 1, or 2.
 *
 * In all cases above, "enabled by default" means either by defining
 * _DEFAULT_SOURCE, or by not defining any of the public feature test macros.
 */
/* RTEMS adheres to POSIX -- 1003.1b with some features from annexes.  */
/* XMK loosely adheres to POSIX -- 1003.1 */
/* #define _POSIX_MEMLOCK			    -1 */

/* #define _POSIX_PRIORITIZED_IO		    -1 */
/* #define _POSIX_SPORADIC_SERVER		    -1 */

/* #define _POSIX_THREAD_PRIO_INHERIT		    -1 */
/* #define _POSIX_THREAD_PRIO_PROTECT		    -1 */

/* #define _POSIX_THREAD_SPORADIC_SERVER	    -1 */

/* #define _POSIX_TRACE				    -1 */
/* #define _POSIX_TRACE_EVENT_FILTER		    -1 */
/* #define _POSIX_TRACE_INHERIT			    -1 */
/* #define _POSIX_TRACE_LOG			    -1 */
/* #define _POSIX_TYPED_MEMORY_OBJECTS		    -1 */

/* #define _POSIX2_FORT_DEV			    -1 */
/* #define _POSIX2_FORT_RUN			    -1 */
/* #define _POSIX2_LOCALEDEF			    -1 */
/* #define _POSIX2_PBS				    -1 */
/* #define _POSIX2_PBS_ACCOUNTING		    -1 */
/* #define _POSIX2_PBS_CHECKPOINT		    -1 */
/* #define _POSIX2_PBS_LOCATE			    -1 */
/* #define _POSIX2_PBS_MESSAGE			    -1 */
/* #define _POSIX2_PBS_TRACK			    -1 */
/* #define _XOPEN_LEGACY			    -1 */
/* #define _XOPEN_REALTIME			    -1 */
/* #define _XOPEN_REALTIME_THREADS		    -1 */

/* #define _XOPEN_STREAMS			    -1 */
/* #define _XOPEN_UNIX				    -1 */

/* The value corresponds to UNICODE version 5.2, which is the current
   state of newlib's wide char conversion functions. */

/* exceptions first */

/* 16 bit integer machines */
/* For the PowerPC eabi, force the _impure_ptr to be in .sdata */
/* Configure small REENT structure for Xilinx MicroBlaze platforms */
/* This block should be kept in sync with GCC's limits.h.  The point
   of having these definitions here is to not include limits.h, which
   would pollute the user namespace, while still using types of the
   the correct widths when deciding how to define __int32_t and
   __int64_t.  */
/* End of block that should be kept in sync with GCC's limits.h.  */
/* cygwin/config.h header file for Cygwin.

   This wraps Cygwin configuration setting which were in newlib's
   sys/config.h before.  This way we can manaage our configuration
   setting without bothering newlib.
   Written by C. Vinschen.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */
/* The following provides an inline version of __getreent() for newlib,
   which will be used throughout the library whereever there is a _r
   version of a function that takes _REENT.  This saves the overhead
   of a function call for what amounts to a simple computation.

   The definition below is essentially equivalent to the one in cygtls.h
   (&_my_tls.local_clib) however it uses a fixed precomputed
   offset rather than dereferencing a field of a structure.

   Including tlsoffets.h here in order to get this constant offset
   tls_local_clib is a bit of a hack, but the alternative would require
   dragging the entire definition of struct _cygtls (a large and complex
   Cygwin internal data structure) into newlib.  The machinery to
   compute these offsets already exists for the sake of gendef so
   we might as well just use it here.  */
/* The following block of macros is required to build newlib correctly for
   Cygwin.  Changing them in applications has no or not the desired effect.
   Just leave them alone. */
/* Define return type of read/write routines.  In POSIX, the return type
   for read()/write() is "ssize_t" but legacy newlib code has been using
   "int" for some time.  If not specified, "int" is defaulted.  */

/* Define `count' parameter of read/write routines.  In POSIX, the `count'
   parameter is "size_t" but legacy newlib code has been using "int" for some
   time.  If not specified, "int" is defaulted.  */
/* See if small reent asked for at configuration time and
   is not chosen by the platform by default.  */
/* If _MB_EXTENDED_CHARSETS_ALL is set, we want all of the extended
   charsets.  The extended charsets add a few functions and a couple
   of tables of a few K each. */

/*  ISO C++.  */
/* Support gcc's __attribute__ facility.  */

/*  The traditional meaning of 'extern inline' for GCC is not
  to emit the function body unless the address is explicitly
  taken.  However this behaviour is changing to match the C99
  standard, which uses 'extern inline' to indicate that the
  function body *must* be emitted.  Likewise, a function declared
  without either 'extern' or 'static' defaults to extern linkage
  (C99 6.2.2p5), and the compiler may choose whether to use the
  inline version or call the extern linkage version (6.7.4p6).
  If we are using GCC, but do not have the new behaviour, we need
  to use extern inline; if we are using a new GCC with the
  C99-compatible behaviour, or a non-GCC compiler (which we will
  have to hope is C99, since there is no other way to achieve the
  effect of omitting the function if it isn't referenced) we use
  'static inline', which c99 defines to mean more-or-less the same
  as the Gnu C 'extern inline'.  */

/* We're using GCC in C99 mode, or an unknown compiler which
  we just have to hope obeys the C99 semantics of inline.  */
/* Use g++'s demangled names in C++.  */

/* Older versions of gcc don't have __func__ but can use __FUNCTION__.  */
void __assert(const char *, int, const char *) __attribute__((__noreturn__));
void __assert_func(const char *, int, const char *, const char *)
    __attribute__((__noreturn__));

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */

/*
 *  $Id$
 */

/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */

/*
 * Guess on types by examining *_MIN / *_MAX defines.
 */

/* GCC >= 3.3.0 has __<val>__ implicitly defined. */

/* Check if "long long" is 64bit wide */
/* Modern GCCs provide __LONG_LONG_MAX__, SUSv3 wants LLONG_MAX */

/* Check if "long" is 64bit or 32bit wide */
typedef signed char __int8_t;

typedef unsigned char __uint8_t;
typedef short int __int16_t;

typedef short unsigned int __uint16_t;
typedef int __int32_t;

typedef unsigned int __uint32_t;
typedef long long int __int64_t;

typedef long long unsigned int __uint64_t;
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;
typedef int __int_least32_t;

typedef unsigned int __uint_least32_t;
typedef long long int __int_least64_t;

typedef long long unsigned int __uint_least64_t;
typedef long long int __intmax_t;

typedef long long unsigned int __uintmax_t;

typedef int __intptr_t;

typedef unsigned int __uintptr_t;
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */

/* snaroff@next.com says the NeXT needs this.  */

/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */

/* On FreeBSD 5, machine/ansi.h does not exist anymore... */

/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */

/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
typedef int ptrdiff_t;
/* If this symbol has done its job, get rid of it.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
typedef unsigned int size_t;
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." */
/* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... */
typedef short unsigned int wchar_t;
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* A null pointer constant.  */
/* Offset of member MEMBER in a struct of type TYPE. */

/* Type whose alignment is supported in every context and is at least
   as great as that of any standard type not using alignment
   specifiers.  */
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld
      __attribute__((__aligned__(__alignof__(long double))));
  /* _Float128 is defined as a basic type, so max_align_t must be
     sufficiently aligned for it.  This code must work in C++, so we
     use __float128 here; that is only available on some
     architectures, but only on i386 is extra alignment needed for
     __float128.  */

  __float128 __max_align_f128
      __attribute__((__aligned__(__alignof(__float128))));

} max_align_t;
/*
 * Testing against Clang-specific extensions.
 */
/*
 * This code has been put in place to help reduce the addition of
 * compiler specific defines in FreeBSD code.  It helps to aid in
 * having a compiler-agnostic source tree.
 */
/*
 * Compiler memory barriers, specific to gcc and clang.
 */
/* XXX: if __GNUC__ >= 2: not tested everywhere originally, where replaced */
/*
 * The __CONCAT macro is used to concatenate parts of symbol names, e.g.
 * with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
 * The __CONCAT macro is a bit tricky to use if it must work in non-ANSI
 * mode -- there must be no spaces between its arguments, and for nested
 * __CONCAT's, all the __CONCAT's must be at the left.  __CONCAT can also
 * concatenate double-quoted strings produced by the __STRING macro, but
 * this only works with ANSI C.
 *
 * __XSTRING is like __STRING, but it expands any macros in its argument
 * first.  It is only available with ANSI C.
 */
/*
 * Compiler-dependent macros to help declare dead (non-returning) and
 * pure (no side effects) functions, and unused variables.  They are
 * null except for versions of gcc that are known to support the features
 * properly (old versions of gcc-2 supported the dead and pure features
 * in a different (wrong) way).  If we do not provide an implementation
 * for a given compiler, let the compile fail if it is told to use
 * a feature that we cannot live without.
 */
/*
 * Keywords added in C11.
 */
/*
 * Emulation of C11 _Generic().  Unlike the previously defined C11
 * keywords, it is not possible to implement this using exactly the same
 * syntax.  Therefore implement something similar under the name
 * __generic().  Unlike _Generic(), this macro can only distinguish
 * between a single type, so it requires nested invocations to
 * distinguish multiple cases.
 */
/*
 * C99 Static array indices in function parameter declarations.  Syntax such as:
 * void bar(int myArray[static 10]);
 * is allowed in C99 but not in C++.  Define __min_size appropriately so
 * headers using it can be compiled in either language.  Use like this:
 * void bar(int myArray[__min_size(10)]);
 */
/* XXX: should use `#if __STDC_VERSION__ < 199901'. */

/*
 * GCC 2.95 provides `__restrict' as an extension to C90 to support the
 * C99-specific `restrict' type qualifier.  We happen to use `__restrict' as
 * a way to define the `restrict' type qualifier without disturbing older
 * software that is unaware of C99 keywords.
 */
/*
 * GNU C version 2.96 adds explicit branch prediction so that
 * the CPU back-end can hint the processor and also so that
 * code blocks can be reordered such that the predicted path
 * sees a more linear flow, thus improving cache behavior, etc.
 *
 * The following two macros provide us with a way to utilize this
 * compiler feature.  Use __predict_true() if you expect the expression
 * to evaluate to true, and __predict_false() if you expect the
 * expression to evaluate to false.
 *
 * A few notes about usage:
 *
 *	* Generally, __predict_false() error condition checks (unless
 *	  you have some _strong_ reason to do otherwise, in which case
 *	  document it), and/or __predict_true() `no-error' condition
 *	  checks, assuming you want to optimize for the no-error case.
 *
 *	* Other than that, if you don't know the likelihood of a test
 *	  succeeding from empirical or other `hard' evidence, don't
 *	  make predictions.
 *
 *	* These are meant to be used in places that are run `a lot'.
 *	  It is wasteful to make predictions in code that is run
 *	  seldomly (e.g. at subsystem initialization time) as the
 *	  basic block reordering that this affects can often generate
 *	  larger code.
 */
/* Only default visibility is supported on PE/COFF targets. */
/*
 * Given the pointer x to the member m of the struct s, return
 * a pointer to the containing structure.  When using GCC, we first
 * assign pointer x to a local variable, to check that its type is
 * compatible with member m.
 */
/*
 * Compiler-dependent macros to declare that functions take printf-like
 * or scanf-like arguments.  They are null except for versions of gcc
 * that are known to support the features properly (old versions of gcc-2
 * didn't permit keeping the keywords out of the application namespace).
 */
/* Compiler-dependent macros that rely on FreeBSD-specific extensions. */
/*
 * Nullability qualifiers: currently only supported by Clang.
 */
/*
 * Type Safety Checking
 *
 * Clang provides additional attributes to enable checking type safety
 * properties that cannot be enforced by the C type system.
 */
/*
 * Lock annotations.
 *
 * Clang provides support for doing basic thread-safety tests at
 * compile-time, by marking which locks will/should be held when
 * entering/leaving a functions.
 *
 * Furthermore, it is also possible to annotate variables and structure
 * members to enforce that they are only accessed when certain locks are
 * held.
 */

/* Structure implements a lock. */
/* FIXME: Use __lockable__, etc. to avoid colliding with user namespace macros,
 * once clang is fixed: https://bugs.llvm.org/show_bug.cgi?id=34319 */

/* Function acquires an exclusive or shared lock. */

/* Function attempts to acquire an exclusive or shared lock. */

/* Function releases a lock. */

/* Function asserts that an exclusive or shared lock is held. */

/* Function requires that an exclusive or shared lock is or is not held. */

/* Function should not be analyzed. */

/* Guard variables and structure members by lock. */

int isalnum(int __c);
int isalpha(int __c);
int iscntrl(int __c);
int isdigit(int __c);
int isgraph(int __c);
int islower(int __c);
int isprint(int __c);
int ispunct(int __c);
int isspace(int __c);
int isupper(int __c);
int isxdigit(int __c);
int tolower(int __c);
int toupper(int __c);

int isblank(int __c);

int isascii(int __c);
int toascii(int __c);
const char *__locale_ctype_ptr(void);

/* These macros are intentionally written in a manner that will trigger
   a gcc -Wall warning if the user mistakenly passes a 'char' instead
   of an int containing an 'unsigned char'.  Note that the sizeof will
   always be 1, which is what we want for mapping EOF to __CTYPE_PTR[0];
   the use of a raw index inside the sizeof triggers the gcc warning if
   __c was of type char, and sizeof masks side effects of the extra __c.
   Meanwhile, the real index to __CTYPE_PTR+1 must be cast to int,
   since isalpha(0x100000001LL) must equal isalpha(1), rather than being
   an out-of-bounds reference on a 64-bit machine.  */
/* Non-gcc versions will get the library versions, and will be
   slightly slower.  These macros are not NLS-aware so they are
   disabled if the system supports the extended character sets. */
/* Allow a gcc warning if the user passed 'char', but defer to the
   function.  */
/* For C++ backward-compatibility only.  */
extern __attribute__((dllimport)) const char _ctype_[];

typedef int error_t;

/* errno is not a global variable, because that would make using it
   non-reentrant.  Instead, its address is returned by the function
   __errno.  */

/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  Targets shall use <machine/_types.h> to define their own
   internal types if desired.

   There are three define patterns used for type definitions.  Lets assume
   xyz_t is a user type.

   The internal type definition uses __machine_xyz_t_defined.  It is defined by
   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
   must not be used in other files.

   User type definitions are guarded by __xyz_t_defined in glibc and
   _XYZ_T_DECLARED in BSD compatible systems.
*/

/* newlib.h.  Generated from newlib.hin by configure.  */
/* newlib.hin.  Manually edited from the output of autoheader to
   remove all PACKAGE_ macros which will collide with any user
   package using newlib header files and having its own package name,
   version, etc...  */

/* Cygwin's machine/_types.h */

/*
 *  $Id$
 */
typedef __int64_t __blkcnt_t;

typedef __int32_t __blksize_t;

typedef __uint32_t __dev_t;

/* Keep as is.  32 bit on i386, 64 bit on x86_64. */
typedef unsigned long __fsblkcnt_t;

/* Keep as is.  32 bit on i386, 64 bit on x86_64. */
typedef unsigned long __fsfilcnt_t;

typedef __uint32_t __uid_t;

typedef __uint32_t __gid_t;

typedef __uint64_t __ino_t;

typedef long long __key_t;

typedef __uint16_t __sa_family_t;

/* Not unsigned for backward compatibility.  */

typedef int __socklen_t;
/* sys/lock.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

typedef void *_LOCK_T;

/*
 * This must match cygwins PTHREAD_XXX_MUTEX_INITIALIZER_NP which are
 * defined in <pthread.h>
 */
void __cygwin_lock_init(_LOCK_T *);
void __cygwin_lock_init_recursive(_LOCK_T *);
void __cygwin_lock_fini(_LOCK_T *);
void __cygwin_lock_lock(_LOCK_T *);
int __cygwin_lock_trylock(_LOCK_T *);
void __cygwin_lock_unlock(_LOCK_T *);
typedef long _off_t;

typedef int __pid_t;
typedef __uint32_t __id_t;
typedef __uint32_t __mode_t;

__extension__ typedef long long _off64_t;

typedef _off64_t __off_t;

typedef _off64_t __loff_t;

/*
 * We need fpos_t for the following, but it doesn't have a leading "_",
 * so we use _fpos_t instead.
 */

typedef long _fpos_t; /* XXX must match off_t in <sys/types.h> */
                      /* (and must be `long' for now) */

typedef _off64_t _fpos64_t;

/* Defined by GCC provided <stddef.h> */

typedef unsigned int __size_t;
/* If __SIZE_TYPE__ is defined (gcc) we define ssize_t based on size_t.
   We simply change "unsigned" to "signed" for this single definition
   to make sure ssize_t and size_t only differ by their signedness. */

typedef signed int _ssize_t;
typedef _ssize_t __ssize_t;

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */

/* On FreeBSD 5, machine/ansi.h does not exist anymore... */

/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */

/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* If this symbol has done its job, get rid of it.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
typedef unsigned int wint_t;

/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* A null pointer constant.  */
/* Offset of member MEMBER in a struct of type TYPE. */

/* Conversion state information.  */
typedef struct {
  int __count;
  union {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value; /* Value so far.  */
} _mbstate_t;

typedef _LOCK_T _flock_t;

/* Iconv descriptor type */
typedef void *_iconv_t;

typedef unsigned long /* clock() */ __clock_t;

typedef long __time_t;

typedef unsigned long __clockid_t;

typedef unsigned long __timer_t;
typedef int __nl_item;
typedef unsigned short __nlink_t;
typedef long __suseconds_t;         /* microseconds (signed) */
typedef unsigned long __useconds_t; /* microseconds (unsigned) */

typedef __builtin_va_list __va_list;

typedef unsigned long __ULong;
struct _reent;

struct __locale_t;

/*
 * If _REENT_SMALL is defined, we make struct _reent as small as possible,
 * by having nearly everything possible allocated at first use.
 */

struct _Bigint {
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};

/* needed by reentrant structure */
struct __tm {
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};

/*
 * atexit() support.
 */

struct _on_exit_args {
  void *_fnargs
      [32 /* must be at least 32 to guarantee ANSI conformance */]; /* user fn
                                                                       args */
  void *_dso_handle[32 /* must be at least 32 to guarantee ANSI conformance */];
  /* Bitmask is set if user function takes arguments.  */
  __ULong _fntypes; /* type of exit routine -
                                    Must have at least _ATEXIT_SIZE bits */
  /* Bitmask is set if function was registered via __cxa_atexit.  */
  __ULong _is_cxa;
};
struct _atexit {
  struct _atexit *_next; /* next in list */
  int _ind;              /* next index in this table */
  /* Some entries may already have been called, and will be NULL.  */
  void (*_fns[32 /* must be at least 32 to guarantee ANSI conformance */])(
      void); /* the table itself */
  struct _on_exit_args _on_exit_args;
};
/*
 * Stdio buffers.
 *
 * This and __FILE are defined here because we need them for struct _reent,
 * but we don't want stdio.h included when stdlib.h is.
 */

struct __sbuf {
  unsigned char *_base;
  int _size;
};

/*
 * Stdio state variables.
 *
 * The following always hold:
 *
 *	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
 *		_lbfsize is -_bf._size, else _lbfsize is 0
 *	if _flags&__SRD, _w is 0
 *	if _flags&__SWR, _r is 0
 *
 * This ensures that the getc and putc macros (or inline functions) never
 * try to write or read from a file that is in `read' or `write' mode.
 * (Moreover, they can, and do, automatically switch from read mode to
 * write mode, and back, on "r+" and "w+" files.)
 *
 * _lbfsize is used only to make the inline line-buffered output stream
 * code as compact as possible.
 *
 * _ub, _up, and _ur are used when ungetc() pushes back more characters
 * than fit in the current _bf, or when ungetc() pushes back a character
 * that does not match the previous one in _bf.  When this happens,
 * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
 * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
 */
struct __sFILE {
  unsigned char *_p; /* current position in (some) buffer */
  int _r;            /* read space left for getc() */
  int _w;            /* write space left for putc() */
  short _flags;      /* flags, below; this FILE is free if 0 */
  short _file;       /* fileno, if Unix descriptor, else -1 */
  struct __sbuf _bf; /* the buffer (at least 1 byte, if !NULL) */
  int _lbfsize;      /* 0 or -_bf._size, for inline putc */

  /* operations */
  void *_cookie; /* cookie passed to io functions */

  _ssize_t (*_read)(struct _reent *, void *, char *, size_t);
  _ssize_t (*_write)(struct _reent *, void *, const char *, size_t);
  _fpos_t (*_seek)(struct _reent *, void *, _fpos_t, int);
  int (*_close)(struct _reent *, void *);

  /* separate buffer for long sequences of ungetc() */
  struct __sbuf _ub;  /* ungetc buffer */
  unsigned char *_up; /* saved _p when _p is doing ungetc data */
  int _ur;            /* saved _r when _r is counting ungetc data */

  /* tricks to meet minimum requirements even when malloc() fails */
  unsigned char _ubuf[3]; /* guarantee an ungetc() buffer */
  unsigned char _nbuf[1]; /* guarantee a getc() buffer */

  /* separate buffer for fgetline() when line crosses buffer boundary */
  struct __sbuf _lb; /* buffer for fgetline() */

  /* Unix stdio files get aligned to block boundaries on fseek() */
  int _blksize;   /* stat.st_blksize (may be != _bf._size) */
  _off_t _offset; /* current lseek offset */

  struct _reent *_data; /* Here for binary compatibility? Remove? */

  _flock_t _lock; /* for thread-safety locking */

  _mbstate_t _mbstate; /* for wide char stdio functions. */
  int _flags2;         /* for future use */
};
struct __sFILE64 {
  unsigned char *_p; /* current position in (some) buffer */
  int _r;            /* read space left for getc() */
  int _w;            /* write space left for putc() */
  short _flags;      /* flags, below; this FILE is free if 0 */
  short _file;       /* fileno, if Unix descriptor, else -1 */
  struct __sbuf _bf; /* the buffer (at least 1 byte, if !NULL) */
  int _lbfsize;      /* 0 or -_bf._size, for inline putc */

  struct _reent *_data;

  /* operations */
  void *_cookie; /* cookie passed to io functions */

  _ssize_t (*_read)(struct _reent *, void *, char *, size_t);
  _ssize_t (*_write)(struct _reent *, void *, const char *, size_t);
  _fpos_t (*_seek)(struct _reent *, void *, _fpos_t, int);
  int (*_close)(struct _reent *, void *);

  /* separate buffer for long sequences of ungetc() */
  struct __sbuf _ub;  /* ungetc buffer */
  unsigned char *_up; /* saved _p when _p is doing ungetc data */
  int _ur;            /* saved _r when _r is counting ungetc data */

  /* tricks to meet minimum requirements even when malloc() fails */
  unsigned char _ubuf[3]; /* guarantee an ungetc() buffer */
  unsigned char _nbuf[1]; /* guarantee a getc() buffer */

  /* separate buffer for fgetline() when line crosses buffer boundary */
  struct __sbuf _lb; /* buffer for fgetline() */

  /* Unix stdio files get aligned to block boundaries on fseek() */
  int _blksize; /* stat.st_blksize (may be != _bf._size) */
  int _flags2;  /* for future use */

  _off64_t _offset; /* current lseek offset */
  _fpos64_t (*_seek64)(struct _reent *, void *, _fpos64_t, int);

  _flock_t _lock; /* for thread-safety locking */

  _mbstate_t _mbstate; /* for wide char stdio functions. */
};
typedef struct __sFILE64 __FILE;

struct _glue {
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};

/*
 * rand48 family support
 *
 * Copyright (c) 1993 Martin Birgmeier
 * All rights reserved.
 *
 * You may redistribute unmodified or modified versions of this source
 * code provided that the above copyright notice and this and the
 * following conditions are retained.
 *
 * This software is provided ``as is'', and comes with no warranties
 * of any kind. I shall in no event be liable for anything that happens
 * to anyone/anything when using this software.
 */

struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;
};

/* How big the some arrays are.  */

/*
 * struct _reent
 *
 * This structure contains *all* globals needed by the library.
 * It's raison d'etre is to facilitate threads by making all library routines
 * reentrant.  IE: All state information is contained here.
 */
struct _reent {
  int _errno; /* local copy of errno */

  /* FILE is a big struct and may change over time.  To try to achieve binary
     compatibility with future versions, put stdin,stdout,stderr here.
     These are pointers into member __sf defined below.  */
  __FILE *_stdin, *_stdout, *_stderr;

  int _inc; /* used by tmpnam */
  char _emergency[25];

  /* TODO */
  int _unspecified_locale_info; /* unused, reserved for locale stuff */
  struct __locale_t *_locale;   /* per-thread locale */

  int __sdidinit; /* 1 means stdio has been init'd */

  void (*__cleanup)(struct _reent *);

  /* used by mprec routines */
  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;

  /* used by some fp conversion routines */
  int _cvtlen; /* should be size_t */
  char *_cvtbuf;

  union {
    struct {
      unsigned int _unused_rand;
      char *_strtok_last;
      char _asctime_buf[26];
      struct __tm _localtime_buf;
      int _gamma_signgam;
      __extension__ unsigned long long _rand_next;
      struct _rand48 _r48;
      _mbstate_t _mblen_state;
      _mbstate_t _mbtowc_state;
      _mbstate_t _wctomb_state;
      char _l64a_buf[8];
      char _signal_buf[24];
      int _getdate_err;
      _mbstate_t _mbrlen_state;
      _mbstate_t _mbrtowc_state;
      _mbstate_t _mbsrtowcs_state;
      _mbstate_t _wcrtomb_state;
      _mbstate_t _wcsrtombs_state;
      int _h_errno;
    } _reent;
    /* Two next two fields were once used by malloc.  They are no longer
       used. They are used to preserve the space used before so as to
       allow addition of new reent fields and keep binary compatibility.   */
    struct {

      unsigned char *_nextf[30];
      unsigned int _nmalloc[30];
    } _unused;
  } _new;

  /* atexit stuff */
  struct _atexit *_atexit; /* points to head of LIFO stack */
  struct _atexit _atexit0; /* one guaranteed table, required by ANSI */

  /* signal info */
  void (**(_sig_func))(int);

  /* These are here last so that __FILE can grow without changing the offsets
     of the above members (on the off chance that future binary compatibility
     would be broken otherwise).  */
  struct _glue __sglue; /* root of glue chain */

  __FILE __sf[3]; /* first three file descriptors */
};
/* This value is used in stdlib/misc.c.  reent/reent.c has to know it
   as well to make sure the freelist is correctly free'd.  Therefore
   we define it here, rather than in stdlib/misc.c, as before. */

/*
 * All references to struct _reent are via this pointer.
 * Internally, newlib routines that need to reference it should use _REENT.
 */

extern struct _reent *_impure_ptr;
extern struct _reent *const _global_impure_ptr;

void _reclaim_reent(struct _reent *);

/* #define _REENT_ONLY define this to get only reentrant routines */

struct _reent *__getreent(void);

extern int *__errno(void);

/* Please don't use these variables directly.
   Use strerror instead. */
extern __attribute__((dllimport)) const char *const _sys_errlist[];
extern __attribute__((dllimport)) int _sys_nerr;

extern __attribute__((dllimport)) const char *const sys_errlist[];
extern __attribute__((dllimport)) int sys_nerr;
extern __attribute__((dllimport)) char *program_invocation_name;
extern __attribute__((dllimport)) char *program_invocation_short_name;
/* Copyright (C) 2002-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>
 */

/* Radix of exponent representation, b. */

/* Number of base-FLT_RADIX digits in the significand, p.  */

/* Number of decimal digits, q, such that any floating-point number with q
   decimal digits can be rounded into a floating-point number with p radix b
   digits and back again without change to the q decimal digits,

        p * log10(b)			if b is a power of 10
        floor((p - 1) * log10(b))	otherwise
*/

/* Minimum int x such that FLT_RADIX**(x-1) is a normalized float, emin */

/* Minimum negative integer such that 10 raised to that power is in the
   range of normalized floating-point numbers,

        ceil(log10(b) * (emin - 1))
*/

/* Maximum int x such that FLT_RADIX**(x-1) is a representable float, emax.  */

/* Maximum integer such that 10 raised to that power is in the range of
   representable finite floating-point numbers,

        floor(log10((1 - b**-p) * b**emax))
*/

/* Maximum representable finite floating-point number,

        (1 - b**-p) * b**emax
*/

/* The difference between 1 and the least value greater than 1 that is
   representable in the given floating point type, b**1-p.  */

/* Minimum normalized positive floating-point number, b**(emin - 1).  */

/* Addition rounds to 0: zero, 1: nearest, 2: +inf, 3: -inf, -1: unknown.  */
/* ??? This is supposed to change with calls to fesetround in <fenv.h>.  */

/* The floating-point expression evaluation method.  The precise
   definitions of these values are generalised to include support for
   the interchange and extended types defined in ISO/IEC TS 18661-3.
   Prior to this (for C99/C11) the definitions were:

        -1  indeterminate
         0  evaluate all operations and constants just to the range and
            precision of the type
         1  evaluate operations and constants of type float and double
            to the range and precision of the double type, evaluate
            long double operations and constants to the range and
            precision of the long double type
         2  evaluate all operations and constants to the range and
            precision of the long double type

   The TS 18661-3 definitions are:

        -1  indeterminate
         0  evaluate all operations and constants, whose semantic type has
            at most the range and precision of float, to the range and
            precision of float; evaluate all other operations and constants
            to the range and precision of the semantic type.
         1  evaluate all operations and constants, whose semantic type has
            at most the range and precision of double, to the range and
            precision of double; evaluate all other operations and constants
            to the range and precision of the semantic type.
         2  evaluate all operations and constants, whose semantic type has
            at most the range and precision of long double, to the range and
            precision of long double; evaluate all other operations and
            constants to the range and precision of the semantic type.
         N  where _FloatN  is a supported interchange floating type
            evaluate all operations and constants, whose semantic type has
            at most the range and precision of the _FloatN type, to the
            range and precision of the _FloatN type; evaluate all other
            operations and constants to the range and precision of the
            semantic type.
         N + 1, where _FloatNx is a supported extended floating type
            evaluate operations and constants, whose semantic type has at
            most the range and precision of the _FloatNx type, to the range
            and precision of the _FloatNx type; evaluate all other
            operations and constants to the range and precision of the
            semantic type.

   The compiler predefines two macros:

      __FLT_EVAL_METHOD__
      Which, depending on the value given for
      -fpermitted-flt-eval-methods, may be limited to only those values
      for FLT_EVAL_METHOD defined in C99/C11.

     __FLT_EVAL_METHOD_TS_18661_3__
      Which always permits the values for FLT_EVAL_METHOD defined in
      ISO/IEC TS 18661-3.

     Here we want to use __FLT_EVAL_METHOD__, unless
     __STDC_WANT_IEC_60559_TYPES_EXT__ is defined, in which case the user
     is specifically asking for the ISO/IEC TS 18661-3 types, so we use
     __FLT_EVAL_METHOD_TS_18661_3__.

   ??? This ought to change with the setting of the fp control word;
   the value provided by the compiler assumes the widest setting.  */

/* Number of decimal digits, n, such that any floating-point number in the
   widest supported floating type with pmax radix b digits can be rounded
   to a floating-point number with n decimal digits and back again without
   change to the value,

        pmax * log10(b)			if b is a power of 10
        ceil(1 + pmax * log10(b))	otherwise
*/

/* Versions of DECIMAL_DIG for each floating-point type.  */

/* Whether types support subnormal numbers.  */

/* Minimum positive values, including subnormals.  */
/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */

/* Use "..." so that we find syslimits.h only in this same directory.  */
/* syslimits.h stands for the system's own limits.h file.
   If we can use it ok unmodified, then we install this text.
   If fixincludes fixes it, then the fixed version is installed
   instead of this text.  */

/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
/* limits.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* features.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */

/* Various options should be defined here, but the framework to do this
   is not laid down so far.  Especially notable are the following defines,
   which can be used by the application to switch on or off various
   datatypes and function prototypes:

     _BSD_SOURCE   to include pure BSD functions which are not defined
                   under POSIX.

     _POSIX_SOURCE if the application requests a POSIX compatible system.

     _XOPEN_SOURCE if X/Open functions and datatypes are requested.  This
                   option includes _POSIX_SOURCE.

     _GNU_SOURCE   to turn on GNU extensions which might collide with defines
                   used in application or library headers.  This option
                   includes _BSD_SOURCE, _XOPEN_SOURCE and _POSIX_SOURCE.
*/
/* wordsize.h - Linux compatibility */

/* _MACH_MACHLIMITS_H_ is used on OSF/1.  */

/* Numerical limits */

/* Number of bits in a `char'.  */

/* Number of bits in a `long'.  */

/* Number of bits in a `int'.  */

/* Maximum length of a multibyte character.  */

/* Use value from newlib. */

/* Minimum and maximum values a `signed char' can hold.  */

/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */

/* Minimum and maximum values a `char' can hold.  */
/* Minimum and maximum values a `signed short int' can hold.  */

/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */

/* Minimum and maximum values a `signed int' can hold.  */
/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */

/* Minimum and maximum values a `signed long int' can hold.
   (Same as `int').  */
/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */

/* Minimum and maximum values a `signed long long int' can hold.  */
/* Minimum and maximum values a `signed long long int' can hold.  */

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */

/* Maximum size of ssize_t. Sadly, gcc doesn't give us __SSIZE_MAX__
   the way it does for __SIZE_MAX__.  On the other hand, we happen to
   know that for Cygwin, ssize_t is 'int' on 32-bit and 'long' on
   64-bit, and this particular header is specific to Cygwin, so we
   don't have to jump through hoops. */
/* Runtime Invariant Values */

/* Please note that symbolic names shall be omitted, on specific
   implementations where the corresponding value is equal to or greater
   than the stated minimum, but is unspecified.  This indetermination
   might depend on the amount of available memory space on a specific
   instance of a specific implementation. The actual value supported by
   a specific instance shall be provided by the sysconf() function. */

/* Maximum number of I/O operations in a single list I/O call supported by
   the implementation. */

/* Maximum number of outstanding asynchronous I/O operations supported by
   the implementation. */

/* The maximum amount by which a process can decrease its asynchronous I/O
   priority level from its own scheduling priority. Not yet implemented. */

/* Maximum number of bytes in arguments and environment passed in an exec
   call.  32000 is the safe value used for Windows processes when called
   from Cygwin processes. */

/* Maximum number of functions that may be registered with atexit(). */

/* Maximum number of simultaneous processes per real user ID. */

/* Maximum number of timer expiration overruns.  Not yet implemented. */

/* #define DELAYTIMER_MAX >= _POSIX_DELAYTIMER_MAX */

/* Maximum length of a host name. */

/* Maximum number of iovcnt in a writev (an arbitrary number) */

/* Maximum number of characters in a login name. */

/* The maximum number of open message queue descriptors a process may hold. */

/* The maximum number of message priorities supported by the implementation. */

/* # of open files per process. Actually it can be more since Cygwin
   grows the dtable as necessary. We define a reasonable limit here
   which is returned by getdtablesize(), sysconf(_SC_OPEN_MAX) and
   getrlimit(RLIMIT_NOFILE). */

/* Size in bytes of a page. */

/* Maximum number of attempts made to destroy a thread's thread-specific
   data values on thread exit. */
/* FIXME: I really don't understand this value.  Why should multiple
   attempts be necessary to destroy thread-specific data?!?  Anyway, the
   current value here is 1, taken originally from our pthread.h file,
   where it was mistakenly defined first.  Unfortunately this value is
   lower than the POSIX defined minimum value, which is 4. */

/* Maximum number of data keys that can be created by a process. */
/* Tls has 1088 items - and we don't want to use them all :] */

/* Minimum size in bytes of thread stack storage. */
/* Actually the minimum stack size is somewhat of a split personality.
   The size parameter in a CreateThread call is the size of the initially
   commited stack size, which can be specified as low as 4K.  However, the
   default *reserved* stack size is 1 Meg, unless the .def file specifies
   another STACKSIZE value.  And even if you specify a stack size below 64K,
   the allocation granularity is in the way.  You can never squeeze multiple
   threads in the same allocation granularity slot.  Oh well. */

/* Maximum number of threads that can be created per process. */
/* Windows allows any arbitrary number of threads per process. */

/* #define PTHREAD_THREADS_MAX unspecified */

/* Maximum number of realtime signals reserved for application use. */
/* FIXME: We only support one realtime signal in 32 bit mode, but
         _POSIX_RTSIG_MAX is 8. */

/* Maximum number of semaphores that a process may have. */
/* Windows allows any arbitrary number of semaphores per process. */

/* #define SEM_NSEMS_MAX unspecified */

/* The maximum value a semaphore may have. */

/* Maximum number of queued signals that a process may send and have pending
   at the receiver(s) at any time. */

/* The maximum number of replenishment operations that may be simultaneously
   pending for a particular sporadic server scheduler.  Not implemented. */

/* #define SS_REPL_MAX >= _POSIX_SS_REPL_MAX */

/* Number of streams that one process can have open at one time. */

/* Maximum number of nested symbolic links. */

/* Maximum number of timer expiration overruns. */

/* Maximum length of the trace event name.  Not implemented. */

/* #define TRACE_EVENT_NAME_MAX >= _POSIX_TRACE_EVENT_NAME_MAX */

/* Maximum length of the trace generation version string or of the trace
   stream name.  Not implemented. */

/* #define TRACE_NAME_MAX >= _POSIX_TRACE_NAME_MAX */

/* Maximum number of trace streams that may simultaneously exist in the
   system.  Not implemented. */

/* #define TRACE_SYS_MAX >= _POSIX_TRACE_SYS_MAX */

/* Maximum number of user trace event type identifiers that may simultaneously
   exist in a traced process, including the predefined user trace event
   POSIX_TRACE_UNNAMED_USER_EVENT.  Not implemented. */

/* #define TRACE_USER_EVENT_MAX >= _POSIX_TRACE_USER_EVENT_MAX */

/* Maximum number of characters in a tty name. */

/* Maximum number of bytes supported for the name of a timezone (not of the TZ
 * variable).  Not implemented. */

/* #define TZNAME_MAX >= _POSIX_TZNAME_MAX */

/* Pathname Variable Values */

/* Minimum bits needed to represent the maximum size of a regular file. */

/* Maximum number of hardlinks to a file. */

/* Maximum number of bytes in a terminal canonical input line. */

/* Minimum number of bytes available in a terminal input queue. */

/* Maximum length of a path component. */

/* Maximum length of a path given to API functions including trailing NUL.
   Deliberately set to the same default value as on Linux.  Internal paths
   may be longer. */
/* Keep in sync with __PATHNAME_MAX__ in cygwin/config.h */

/* # of bytes in a pipe buf. This is the max # of bytes which can be
   written to a pipe in one atomic operation. */

/* Minimum number of bytes of storage actually allocated for any portion
   of a file.  Not implemented. */

/* #define POSIX_ALLOC_SIZE_MIN unspecifed */

/* Recommended increment for file transfer sizes between the
   {POSIX_REC_MIN_XFER_SIZE} and {POSIX_REC_MAX_XFER_SIZE} values.
   Not implemented. */

/* #define POSIX_REC_INCR_XFER_SIZE unspecifed */

/* Maximum recommended file transfer size.  Not implemented. */

/* #define POSIX_REC_MAX_XFER_SIZE unspecifed */

/* Minimum recommended file transfer size.  Not implemented. */

/* #define POSIX_REC_MIN_XFER_SIZE unspecifed */

/* Recommended file transfer buffer alignment.  Not implemented. */

/* #define POSIX_REC_XFER_ALIGN unspecifed */

/* Maximum number of bytes in a symbolic link. */

/* Runtime Increasable Values */

/* Maximum obase values allowed by the bc utility. */

/* Maximum number of elements permitted in an array by the bc utility. */

/* Maximum scale value allowed by the bc utility. */

/* Maximum length of a string constant accepted by the bc utility. */

/* Maximum number of bytes in a character class name.  Not implemented. */

/* #define CHARCLASS_NAME_MAX >= _POSIX2_CHARCLASS_NAME_MAX */

/* Maximum number of weights that can be assigned to an entry of the
   LC_COLLATE order keyword in the locale definition file. */
/* FIXME: We don't support this at all right now, so this value is
   misleading at best.  It's also lower than _POSIX2_COLL_WEIGHTS_MAX
   which is not good.  So, for now we deliberately not define it even
   though it was defined in the former syslimits.h file. */

/* #define COLL_WEIGHTS_MAX >= _POSIX2_COLL_WEIGHTS_MAX */

/* Maximum number of expressions that can be nested within parentheses
   by the expr utility. */

/* Maximum bytes of a text utility's input line */

/* Max num groups for a user, value taken from NT documentation */
/* Must match <sys/param.h> NGROUPS */

/* Maximum number of repeated occurrences of a regular expression when
   using the interval notation \{m,n\} */

/* POSIX values */
/* These should never vary from one system type to another */
/* They represent the minimum values that POSIX systems must support.
   POSIX-conforming apps must not require larger values. */

/* Maximum Values */

/* Minimum Values */
/* Other Invariant Values */
/* Default process priority. */

/* Copyright (C) 1991-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */
/* This administrivia gets added to the end of limits.h
   if the system has its own version of limits.h.  */
/*
        locale.h
        Values appropriate for the formatting of monetary and other
        numberic quantities.
*/

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */

/* On FreeBSD 5, machine/ansi.h does not exist anymore... */

/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */

/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* If this symbol has done its job, get rid of it.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* A null pointer constant.  */
/* Offset of member MEMBER in a struct of type TYPE. */

struct lconv {
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_n_cs_precedes;
  char int_n_sep_by_space;
  char int_n_sign_posn;
  char int_p_cs_precedes;
  char int_p_sep_by_space;
  char int_p_sign_posn;
};

struct _reent;
char *_setlocale_r(struct _reent *, int, const char *);
struct lconv *_localeconv_r(struct _reent *);

struct __locale_t *_newlocale_r(struct _reent *, int, const char *,
                                struct __locale_t *);
void _freelocale_r(struct _reent *, struct __locale_t *);
struct __locale_t *_duplocale_r(struct _reent *, struct __locale_t *);
struct __locale_t *_uselocale_r(struct _reent *, struct __locale_t *);

char *setlocale(int, const char *);
struct lconv *localeconv(void);

/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */

/* Natural log of 2 */

/* gcc >= 3.3 implicitly defines builtins for HUGE_VALx values.  */
/* Reentrant ANSI C functions.  */

extern double atan(double);
extern double cos(double);
extern double sin(double);
extern double tan(double);
extern double tanh(double);
extern double frexp(double, int *);
extern double modf(double, double *);
extern double ceil(double);
extern double fabs(double);
extern double floor(double);

/* Non reentrant ANSI C functions.  */

extern double acos(double);
extern double asin(double);
extern double atan2(double, double);
extern double cosh(double);
extern double sinh(double);
extern double exp(double);
extern double ldexp(double, int);
extern double log(double);
extern double log10(double);
extern double pow(double, double);
extern double sqrt(double);
extern double fmod(double, double);
/* ISO C99 types and macros. */

/* FIXME:  FLT_EVAL_METHOD should somehow be gotten from float.h (which is hard,
 * considering that the standard says the includes it defines should not
 * include other includes that it defines) and that value used.  (This can be
 * solved, but autoconf has a bug which makes the solution more difficult, so
 * it has been skipped for now.)  */
typedef long double float_t;
typedef long double double_t;
extern int __isinff(float x);
extern int __isinfd(double x);
extern int __isnanf(float x);
extern int __isnand(double x);
extern int __fpclassifyf(float x);
extern int __fpclassifyd(double x);
extern int __signbitf(float x);
extern int __signbitd(double x);

/* Note: isinf and isnan were once functions in newlib that took double
 *       arguments.  C99 specifies that these names are reserved for macros
 *       supporting multiple floating point types.  Thus, they are
 *       now defined as macros.  Implementations of the old functions
 *       taking double arguments still exist for compatibility purposes
 *       (prototypes for them are earlier in this header).  */
/* Non ANSI double precision functions.  */

extern double infinity(void);
extern double nan(const char *);
extern double copysign(double, double);
extern double logb(double);
extern int ilogb(double);

extern double asinh(double);
extern double cbrt(double);
extern double nextafter(double, double);
extern double rint(double);
extern double scalbn(double, int);

extern double exp2(double);
extern double scalbln(double, long int);
extern double tgamma(double);
extern double nearbyint(double);
extern long int lrint(double);
extern long long int llrint(double);
extern double round(double);
extern long int lround(double);
extern long long int llround(double);
extern double trunc(double);
extern double remquo(double, double, int *);
extern double fdim(double, double);
extern double fmax(double, double);
extern double fmin(double, double);
extern double fma(double, double, double);

extern double log1p(double);
extern double expm1(double);

extern double acosh(double);
extern double atanh(double);
extern double remainder(double, double);
extern double gamma(double);
extern double lgamma(double);
extern double erf(double);
extern double erfc(double);
extern double log2(double);

extern double hypot(double, double);

/* Single precision versions of ANSI functions.  */

extern float atanf(float);
extern float cosf(float);
extern float sinf(float);
extern float tanf(float);
extern float tanhf(float);
extern float frexpf(float, int *);
extern float modff(float, float *);
extern float ceilf(float);
extern float fabsf(float);
extern float floorf(float);

extern float acosf(float);
extern float asinf(float);
extern float atan2f(float, float);
extern float coshf(float);
extern float sinhf(float);
extern float expf(float);
extern float ldexpf(float, int);
extern float logf(float);
extern float log10f(float);
extern float powf(float, float);
extern float sqrtf(float);
extern float fmodf(float, float);

/* Other single precision functions.  */

extern float exp2f(float);
extern float scalblnf(float, long int);
extern float tgammaf(float);
extern float nearbyintf(float);
extern long int lrintf(float);
extern long long int llrintf(float);
extern float roundf(float);
extern long int lroundf(float);
extern long long int llroundf(float);
extern float truncf(float);
extern float remquof(float, float, int *);
extern float fdimf(float, float);
extern float fmaxf(float, float);
extern float fminf(float, float);
extern float fmaf(float, float, float);

extern float infinityf(void);
extern float nanf(const char *);
extern float copysignf(float, float);
extern float logbf(float);
extern int ilogbf(float);

extern float asinhf(float);
extern float cbrtf(float);
extern float nextafterf(float, float);
extern float rintf(float);
extern float scalbnf(float, int);
extern float log1pf(float);
extern float expm1f(float);

extern float acoshf(float);
extern float atanhf(float);
extern float remainderf(float, float);
extern float gammaf(float);
extern float lgammaf(float);
extern float erff(float);
extern float erfcf(float);
extern float log2f(float);
extern float hypotf(float, float);

/* Newlib doesn't fully support long double math functions so far.
   On platforms where long double equals double the long double functions
   simply call the double functions.  On Cygwin the long double functions
   are implemented independently from newlib to be able to use optimized
   assembler functions despite using the Microsoft x86_64 ABI. */

/* Reentrant ANSI C functions.  */

extern long double atanl(long double);
extern long double cosl(long double);
extern long double sinl(long double);
extern long double tanl(long double);
extern long double tanhl(long double);
extern long double frexpl(long double, int *);
extern long double modfl(long double, long double *);
extern long double ceill(long double);
extern long double fabsl(long double);
extern long double floorl(long double);
extern long double log1pl(long double);
extern long double expm1l(long double);

/* Non reentrant ANSI C functions.  */

extern long double acosl(long double);
extern long double asinl(long double);
extern long double atan2l(long double, long double);
extern long double coshl(long double);
extern long double sinhl(long double);
extern long double expl(long double);
extern long double ldexpl(long double, int);
extern long double logl(long double);
extern long double log10l(long double);
extern long double powl(long double, long double);
extern long double sqrtl(long double);
extern long double fmodl(long double, long double);
extern long double hypotl(long double, long double);

extern long double copysignl(long double, long double);
extern long double nanl(const char *);
extern int ilogbl(long double);
extern long double asinhl(long double);
extern long double cbrtl(long double);
extern long double nextafterl(long double, long double);
extern float nexttowardf(float, long double);
extern double nexttoward(double, long double);
extern long double nexttowardl(long double, long double);
extern long double logbl(long double);
extern long double log2l(long double);
extern long double rintl(long double);
extern long double scalbnl(long double, int);
extern long double exp2l(long double);
extern long double scalblnl(long double, long);
extern long double tgammal(long double);
extern long double nearbyintl(long double);
extern long int lrintl(long double);
extern long long int llrintl(long double);
extern long double roundl(long double);
extern long lroundl(long double);
extern long long int llroundl(long double);
extern long double truncl(long double);
extern long double remquol(long double, long double, int *);
extern long double fdiml(long double, long double);
extern long double fmaxl(long double, long double);
extern long double fminl(long double, long double);
extern long double fmal(long double, long double, long double);

extern long double acoshl(long double);
extern long double atanhl(long double);
extern long double remainderl(long double, long double);
extern long double lgammal(long double);
extern long double erfl(long double);
extern long double erfcl(long double);
extern double y0(double);
extern double y1(double);
extern double yn(int, double);
extern double j0(double);
extern double j1(double);
extern double jn(int, double);

extern float y0f(float);
extern float y1f(float);
extern float ynf(int, float);
extern float j0f(float);
extern float j1f(float);
extern float jnf(int, float);

/* GNU extensions */
/* The gamma functions use a global variable, signgam.  */

extern int *__signgam(void);
/* Useful constants.  */

/*
        setjmp.h
        stubs for future use.
*/

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */

/* necv70 was 9 as well. */
/*
 * There are two versions of setjmp()/longjmp():
 *   1) Compiler (gcc) built-in versions.
 *   2) Function-call versions.
 *
 * The built-in versions are used most of the time.  When used, gcc replaces
 * calls to setjmp()/longjmp() with inline assembly code.  The built-in
 * versions save/restore a variable number of registers.

 * _JBLEN is set to 40 to be ultra-safe with the built-in versions.
 * It only needs to be 12 for the function-call versions
 * but this data structure is used by both versions.
 */
typedef int jmp_buf[(13 * 4)];

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/* sys/signal.h */

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */
/* unified sys/types.h:
   start with sef's sysvi386 version.
   merge go32 version -- a few ifdefs.
   h8300hms, h8300xray, and sysvnecv70 disagree on the following types:

   typedef int gid_t;
   typedef int uid_t;
   typedef int dev_t;
   typedef int ino_t;
   typedef int mode_t;
   typedef int caddr_t;

   however, these aren't "reasonable" values, the sysvi386 ones make far
   more sense, and should work sufficiently well (in particular, h8300
   doesn't have a stat, and the necv70 doesn't matter.) -- eichin
 */

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/* Cygwin's machine/_types.h */

/* BSD types permitted by POSIX and always exposed as in Glibc.  Only provided
   for backward compatibility with BSD code.  The uintN_t standard types should
   be preferred in new code. */

typedef __uint8_t u_int8_t;

typedef __uint16_t u_int16_t;

typedef __uint32_t u_int32_t;

typedef __uint64_t u_int64_t;

typedef int register_t;
/* <stddef.h> must be before <sys/_types.h> for __size_t considerations */
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  Targets shall use <machine/_types.h> to define their own
   internal types if desired.

   There are three define patterns used for type definitions.  Lets assume
   xyz_t is a user type.

   The internal type definition uses __machine_xyz_t_defined.  It is defined by
   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
   must not be used in other files.

   User type definitions are guarded by __xyz_t_defined in glibc and
   _XYZ_T_DECLARED in BSD compatible systems.
*/
/*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */

/*
 *  $Id$
 */

typedef __int8_t int8_t;

typedef __uint8_t uint8_t;

typedef __int16_t int16_t;

typedef __uint16_t uint16_t;

typedef __int32_t int32_t;

typedef __uint32_t uint32_t;

typedef __int64_t int64_t;

typedef __uint64_t uint64_t;

typedef __intmax_t intmax_t;

typedef __uintmax_t uintmax_t;

typedef __intptr_t intptr_t;

typedef __uintptr_t uintptr_t;
typedef __blkcnt_t blkcnt_t;

typedef __blksize_t blksize_t;

typedef unsigned long /* clock() */ clock_t;

typedef long time_t;

typedef long daddr_t;

typedef char *caddr_t;

typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;

typedef __id_t id_t; /* can hold a uid_t or pid_t */

typedef __ino_t ino_t; /* inode number */
/*
 * All these should be machine specific - right now they are all broken.
 * However, for all of Cygnus' embedded targets, we want them to all be
 * the same.  Otherwise things like sizeof (struct stat) might depend on
 * how the file was compiled (e.g. -mint16 vs -mint32, etc.).
 */

typedef __off_t off_t; /* file offset */

typedef __dev_t dev_t; /* device number or struct cdev */

typedef __uid_t uid_t; /* user id */

typedef __gid_t gid_t; /* group id */

typedef __pid_t pid_t; /* process id */

typedef __key_t key_t; /* IPC key */

typedef _ssize_t ssize_t;

typedef __mode_t mode_t; /* permissions */

typedef __nlink_t nlink_t; /* link count */

typedef __clockid_t clockid_t;

typedef __timer_t timer_t;

typedef __useconds_t useconds_t; /* microseconds (unsigned) */

typedef __suseconds_t suseconds_t;

typedef __int64_t sbintime_t;

/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */
/* machine/types.h
   Written by Robert Collins <rbtcollins@hotmail.com>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

typedef struct __pthread_t {
  char __dummy;
} * pthread_t;
typedef struct __pthread_mutex_t {
  char __dummy;
} * pthread_mutex_t;

typedef struct __pthread_key_t {
  char __dummy;
} * pthread_key_t;
typedef struct __pthread_attr_t {
  char __dummy;
} * pthread_attr_t;
typedef struct __pthread_mutexattr_t {
  char __dummy;
} * pthread_mutexattr_t;
typedef struct __pthread_condattr_t {
  char __dummy;
} * pthread_condattr_t;
typedef struct __pthread_cond_t {
  char __dummy;
} * pthread_cond_t;
typedef struct __pthread_barrierattr_t {
  char __dummy;
} * pthread_barrierattr_t;
typedef struct __pthread_barrier_t {
  char __dummy;
} * pthread_barrier_t;

/* These variables are not user alterable. This means you!. */
typedef struct {
  pthread_mutex_t mutex;
  int state;
} pthread_once_t;
typedef struct __pthread_spinlock_t {
  char __dummy;
} * pthread_spinlock_t;
typedef struct __pthread_rwlock_t {
  char __dummy;
} * pthread_rwlock_t;
typedef struct __pthread_rwlockattr_t {
  char __dummy;
} * pthread_rwlockattr_t;
/* machine/types.h
   Written by Robert Collins <rbtcollins@hotmail.com>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */
/* endian.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  Targets shall use <machine/_types.h> to define their own
   internal types if desired.

   There are three define patterns used for type definitions.  Lets assume
   xyz_t is a user type.

   The internal type definition uses __machine_xyz_t_defined.  It is defined by
   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
   must not be used in other files.

   User type definitions are guarded by __xyz_t_defined in glibc and
   _XYZ_T_DECLARED in BSD compatible systems.
*/
/* machine/_endian.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
/* bits/endian.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */
static __inline__ __uint32_t __ntohl(__uint32_t);
static __inline__ __uint16_t __ntohs(__uint16_t);

static __inline__ __uint32_t __ntohl(__uint32_t _x) {
  __asm__("bswap %0" : "=r"(_x) : "0"(_x));
  return _x;
}

static __inline__ __uint16_t __ntohs(__uint16_t _x) {
  __asm__("xchgb %b0,%h0" /* swap bytes		*/
          : "=Q"(_x)
          : "0"(_x));
  return _x;
}

/*#ifdef  __USE_BSD*/
/*#endif*/
/* wordsize.h - Linux compatibility */
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD$
 */

/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  Targets shall use <machine/_types.h> to define their own
   internal types if desired.

   There are three define patterns used for type definitions.  Lets assume
   xyz_t is a user type.

   The internal type definition uses __machine_xyz_t_defined.  It is defined by
   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
   must not be used in other files.

   User type definitions are guarded by __xyz_t_defined in glibc and
   _XYZ_T_DECLARED in BSD compatible systems.
*/

struct timespec {
  time_t tv_sec; /* seconds */
  long tv_nsec;  /* and nanoseconds */
};

typedef struct timespec timespec_t;

typedef struct timespec timestruc_t;

typedef __loff_t loff_t;
struct flock {
  short l_type;   /* F_RDLCK, F_WRLCK, or F_UNLCK */
  short l_whence; /* flag to choose starting offset */
  off_t l_start;  /* relative offset, in bytes */
  off_t l_len;    /* length, in bytes; 0 means lock to EOF */
  pid_t l_pid;    /* returned with F_GETLK */
};

typedef unsigned long vm_offset_t;

typedef unsigned long vm_size_t;

typedef void *vm_object_t;

typedef char *addr_t;

/* this header needs the dev_t typedef */
/* sys/sysmacros.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* unified sys/types.h:
   start with sef's sysvi386 version.
   merge go32 version -- a few ifdefs.
   h8300hms, h8300xray, and sysvnecv70 disagree on the following types:

   typedef int gid_t;
   typedef int uid_t;
   typedef int dev_t;
   typedef int ino_t;
   typedef int mode_t;
   typedef int caddr_t;

   however, these aren't "reasonable" values, the sysvi386 ones make far
   more sense, and should work sufficiently well (in particular, h8300
   doesn't have a stat, and the necv70 doesn't matter.) -- eichin
 */

static __inline__ int gnu_dev_major(dev_t);
static __inline__ int gnu_dev_minor(dev_t);
static __inline__ dev_t gnu_dev_makedev(int, int);

static __inline__ int gnu_dev_major(dev_t dev) {
  return (int)(((dev) >> 16) & 0xffff);
}

static __inline__ int gnu_dev_minor(dev_t dev) { return (int)((dev)&0xffff); }

static __inline__ dev_t gnu_dev_makedev(int maj, int min) {
  return (((maj) << 16) | ((min)&0xffff));
}
/*-
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)signal.h	8.4 (Berkeley) 5/4/95
 * $FreeBSD$
 */

typedef unsigned long __sigset_t;
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD$
 */

typedef __sigset_t sigset_t;

/* signal.h

  This file is part of Cygwin.

  This software is a copyrighted work licensed under the terms of the
  Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
  details. */

/* wordsize.h - Linux compatibility */

/*
  Define a struct __mcontext, which should be identical in layout to the Win32
  API type CONTEXT with the addition of oldmask and cr2 fields at the end.
*/
struct _uc_fpreg {
  __uint16_t significand[4];
  __uint16_t exponent;
};

struct _fpstate {
  __uint32_t cw;
  __uint32_t sw;
  __uint32_t tag;
  __uint32_t ipoff;
  __uint32_t cssel;
  __uint32_t dataoff;
  __uint32_t datasel;
  struct _uc_fpreg _st[8];
  __uint32_t nxst;
};

struct __mcontext {
  __uint32_t ctxflags;
  __uint32_t dr0;
  __uint32_t dr1;
  __uint32_t dr2;
  __uint32_t dr3;
  __uint32_t dr6;
  __uint32_t dr7;
  struct _fpstate fpstate;
  __uint32_t gs;
  __uint32_t fs;
  __uint32_t es;
  __uint32_t ds;
  __uint32_t edi;
  __uint32_t esi;
  __uint32_t ebx;
  __uint32_t edx;
  __uint32_t ecx;
  __uint32_t eax;
  __uint32_t ebp;
  __uint32_t eip;
  __uint32_t cs;
  __uint32_t eflags;
  __uint32_t esp;
  __uint32_t ss;
  __uint32_t reserved[128];
  __uint32_t oldmask;
  __uint32_t cr2;
};

/* Needed for GDB.  It only compiles in the context copy code if this macro is
   defined.  This is not sizeof(CONTEXT) due to historical accidents. */

typedef union sigval {
  int sival_int;   /* integer signal value */
  void *sival_ptr; /* pointer signal value */
} sigval_t;

typedef struct sigevent {
  sigval_t sigev_value;                    /* signal value */
  int sigev_signo;                         /* signal number */
  int sigev_notify;                        /* notification type */
  void (*sigev_notify_function)(sigval_t); /* notification function */
  pthread_attr_t *sigev_notify_attributes; /* notification attributes */
} sigevent_t;

struct _sigcommune {
  __uint32_t _si_code;
  void *_si_read_handle;
  void *_si_write_handle;
  void *_si_process_handle;
  __extension__ union {
    int _si_fd;
    int64_t _si_pipe_unique_id;
    char *_si_str;
  };
};
typedef struct {
  int si_signo; /* signal number */
  int si_code;  /* signal code */
  pid_t si_pid; /* sender's pid */
  uid_t si_uid; /* sender's uid */
  int si_errno; /* errno associated with signal */

  __extension__ union {
    __uint32_t __pad[32];           /* plan for future growth */
    struct _sigcommune _si_commune; /* cygwin ipc */
    __extension__ struct {
      __extension__ union {
        sigval_t si_sigval; /* signal value */
        sigval_t si_value;  /* signal value */
      };
      __extension__ struct {
        timer_t si_tid;          /* timer id */
        unsigned int si_overrun; /* overrun count */
      };
    };
    /* SIGCHLD */
    __extension__ struct {
      int si_status;    /* exit code */
      clock_t si_utime; /* user time */
      clock_t si_stime; /* system time */
    };

    void *si_addr; /* faulting address for core dumping
                                           signals */
    /* Cygwin internal fields */
  };
} siginfo_t;

enum {
  SI_USER = 0,    /* sent by kill, raise, pthread_kill */
  SI_ASYNCIO = 2, /* sent by AIO completion (currently
                                           unimplemented) */
  SI_MESGQ,       /* sent by real time mesq state change
                                                 (currently unimplemented) */
  SI_TIMER,       /* sent by timer expiration */
  SI_QUEUE,       /* sent by sigqueue */
  SI_KERNEL,      /* sent by system */

  ILL_ILLOPC = 7, /* illegal opcode */
  ILL_ILLOPN,     /* illegal operand */
  ILL_ILLADR,     /* illegal addressing mode */
  ILL_ILLTRP,     /* illegal trap*/
  ILL_PRVOPC,     /* privileged opcode */
  ILL_PRVREG,     /* privileged register */
  ILL_COPROC,     /* coprocessor error */
  ILL_BADSTK,     /* internal stack error */

  FPE_INTDIV = 15, /* integer divide by zero */
  FPE_INTOVF,      /* integer overflow */
  FPE_FLTDIV,      /* floating point divide by zero */
  FPE_FLTOVF,      /* floating point overflow */
  FPE_FLTUND,      /* floating point underflow */
  FPE_FLTRES,      /* floating point inexact result */
  FPE_FLTINV,      /* floating point invalid operation */
  FPE_FLTSUB,      /* subscript out of range */

  SEGV_MAPERR = 23, /* address not mapped to object */
  SEGV_ACCERR,      /* invalid permissions for mapped object */

  BUS_ADRALN = 25, /* invalid address alignment.  */
  BUS_ADRERR,      /* non-existant physical address.  */
  BUS_OBJERR,      /* object specific hardware error.  */

  CLD_EXITED = 28, /* child has exited */
  CLD_KILLED,      /* child was killed */
  CLD_DUMPED,      /* child terminated abnormally */
  CLD_TRAPPED,     /* traced child has trapped */
  CLD_STOPPED,     /* child has stopped */
  CLD_CONTINUED    /* stopped child has continued */
};
enum {
  SIGEV_SIGNAL = 0, /* a queued signal, with an application
                                           defined value, is generated when the
                                           event of interest occurs */
  SIGEV_NONE,       /* no asynchronous notification is
                                                 delivered when the event of interest
                                                 occurs */
  SIGEV_THREAD      /* a notification function is called to
                                                perform notification */
};

typedef void (*_sig_func_ptr)(int);

struct sigaction {
  __extension__ union {
    _sig_func_ptr sa_handler; /* SIG_DFL, SIG_IGN, or pointer to a function */

    void (*sa_sigaction)(int, siginfo_t *, void *);
  };
  sigset_t sa_mask;
  int sa_flags;
};
/* Used internally by cygwin.  Included here to group everything in one place.
   Do not use.  */
/* Real-Time signals per SUSv3.  RT_SIGMAX is defined as 8 in limits.h */
int sigwait(const sigset_t *, int *);

int sigwaitinfo(const sigset_t *, siginfo_t *);

int sighold(int);
int sigignore(int);
int sigrelse(int);
_sig_func_ptr sigset(int, _sig_func_ptr);

int sigqueue(pid_t, int, const union sigval);

int siginterrupt(int, int);
/*
 * Minimum and default signal stack constants. Allow for target overrides
 * from <sys/features.h>.
 */

/*
 * Possible values for ss_flags in stack_t below.
 */

/*
 * Structure used in sigaltstack call.
 */
typedef struct sigaltstack {
  void *ss_sp;    /* Stack base or pointer.  */
  int ss_flags;   /* Flags.  */
  size_t ss_size; /* Stack size.  */
} stack_t;

int sigprocmask(int, const sigset_t *, sigset_t *);

int pthread_sigmask(int, const sigset_t *, sigset_t *);

int kill(pid_t, int);

int killpg(pid_t, int);

int sigaction(int, const struct sigaction *, struct sigaction *);
int sigaddset(sigset_t *, const int);
int sigdelset(sigset_t *, const int);
int sigismember(const sigset_t *, int);
int sigfillset(sigset_t *);
int sigemptyset(sigset_t *);
int sigpending(sigset_t *);
int sigsuspend(const sigset_t *);
int sigwait(const sigset_t *, int *);
/* There are two common sigpause variants, both of which take an int argument.
   If you request _XOPEN_SOURCE or _GNU_SOURCE, you get the System V version,
   which removes the given signal from the process's signal mask; otherwise
   you get the BSD version, which sets the process's signal mask to the given
   value. */

int sigpause(int) __asm__("_" /* stringify without expanding x */
                          /* expand x, then stringify */ "__xpg_sigpause");
int sigaltstack(const stack_t *restrict, stack_t *restrict);

int pthread_kill(pthread_t, int);

/*  3.3.8 Synchronously Accept a Signal, P1003.1b-1993, p. 76
    NOTE: P1003.1c/D10, p. 39 adds sigwait().  */

int sigwaitinfo(const sigset_t *, siginfo_t *);
int sigtimedwait(const sigset_t *, siginfo_t *, const struct timespec *);
/*  3.3.9 Queue a Signal to a Process, P1003.1b-1993, p. 78 */
int sigqueue(pid_t, int, const union sigval);
/* ucontext.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

typedef struct __mcontext mcontext_t;

typedef __attribute__((__aligned__(16))) struct __ucontext {
  mcontext_t uc_mcontext;
  struct __ucontext *uc_link;
  sigset_t uc_sigmask;
  stack_t uc_stack;
  unsigned long int uc_flags;
} ucontext_t;

typedef int sig_atomic_t; /* Atomic entity type (ANSI) */
struct _reent;

_sig_func_ptr _signal_r(struct _reent *, int, _sig_func_ptr);
int _raise_r(struct _reent *, int);

_sig_func_ptr signal(int, _sig_func_ptr);
int raise(int);
void psignal(int, const char *);

/* POSIX sigsetjmp/siglongjmp macros */

typedef int sigjmp_buf[(13 * 4) + 1 + (sizeof(sigset_t) / sizeof(int))];
/* Per POSIX, siglongjmp has to be implemented as function.  Cygwin
   provides functions for both, siglongjmp and sigsetjmp since 2.2.0. */
extern void siglongjmp(sigjmp_buf, int) __attribute__((__noreturn__));
extern int sigsetjmp(sigjmp_buf, int);
/* POSIX _setjmp/_longjmp, maintained for XSI compatibility.  These
   are equivalent to sigsetjmp/siglongjmp when not saving the signal mask.
   New applications should use sigsetjmp/siglongjmp instead. */

extern void _longjmp(jmp_buf, int) __attribute__((__noreturn__));
extern int _setjmp(jmp_buf);

void longjmp(jmp_buf __jmpb, int __retval) __attribute__((__noreturn__));

int setjmp(jmp_buf __jmpb);

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
/* Define __gnuc_va_list.  */

typedef __builtin_va_list __gnuc_va_list;

/* Define the standard macros for the user,
   if this invocation was from the user program.  */
/* Define va_list, if desired, from __gnuc_va_list. */
/* We deliberately do not define va_list when called from
   stdio.h, because ANSI C says that stdio.h is not supposed to define
   va_list.  stdio.h needs to have access to that data type,
   but must not use that name.  It should use the name __gnuc_va_list,
   which is safe because it is reserved for the implementation.  */
/* The macro _VA_LIST_ is the same thing used by this file in Ultrix.
   But on BSD NET2 we must not test or define or undef it.
   (Note that the comments in NET 2's ansi.h
   are incorrect for _VA_LIST_--see stdio.h!)  */

/* The macro _VA_LIST_DEFINED is used in Windows NT 3.5  */

/* The macro _VA_LIST is used in SCO Unix 3.2.  */

/* The macro _VA_LIST_T_H is used in the Bull dpx2  */

/* The macro __va_list__ is used by BeOS.  */

typedef __gnuc_va_list va_list;
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */

/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */

/* On FreeBSD 5, machine/ansi.h does not exist anymore... */

/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */

/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* If this symbol has done its job, get rid of it.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* A null pointer constant.  */
/* Offset of member MEMBER in a struct of type TYPE. */

/* typedef only __gnuc_va_list, used throughout the header */

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */

/* typedef va_list only when required */
/*
 * <sys/reent.h> defines __FILE, _fpos_t.
 * They must be defined there because struct _reent needs them (and we don't
 * want reent.h to include this file.
 */

/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */
/* unified sys/types.h:
   start with sef's sysvi386 version.
   merge go32 version -- a few ifdefs.
   h8300hms, h8300xray, and sysvnecv70 disagree on the following types:

   typedef int gid_t;
   typedef int uid_t;
   typedef int dev_t;
   typedef int ino_t;
   typedef int mode_t;
   typedef int caddr_t;

   however, these aren't "reasonable" values, the sysvi386 ones make far
   more sense, and should work sufficiently well (in particular, h8300
   doesn't have a stat, and the necv70 doesn't matter.) -- eichin
 */

typedef __FILE FILE;

typedef _fpos64_t fpos_t;

/* sys/stdio.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/* sys/lock.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* These definitions should be kept in sync with those in the newlib
   header of the same name (newlib/libc/include/sys/stdio.h).  */

ssize_t getline(char **, size_t *, FILE *);
ssize_t getdelim(char **, size_t *, int, FILE *);

/* RD and WR are never simultaneously asserted */
/* _flags2 flags */

/*
 * The following three definitions are for ANSI C, which took them
 * from System V, which stupidly took internal interface macros and
 * made them official arguments to setvbuf(), without renaming them.
 * Hence, these ugly _IOxxx names are *supposed* to appear in user code.
 *
 * Although these happen to match their counterparts above, the
 * implementation does not rely on that (so these could be renumbered).
 */
/*
 * Functions defined in ANSI C standard.
 */
char *ctermid(char *);

FILE *tmpfile(void);
char *tmpnam(char *);

char *tempnam(const char *, const char *) __attribute__((__malloc__))
__attribute__((__warn_unused_result__));

int fclose(FILE *);
int fflush(FILE *);
FILE *freopen(const char *restrict, const char *restrict, FILE *restrict);
void setbuf(FILE *restrict, char *restrict);
int setvbuf(FILE *restrict, char *restrict, int, size_t);
int fprintf(FILE *restrict, const char *restrict, ...)
    __attribute__((__format__(__printf__, 2, 3)));
int fscanf(FILE *restrict, const char *restrict, ...)
    __attribute__((__format__(__scanf__, 2, 3)));
int printf(const char *restrict, ...)
    __attribute__((__format__(__printf__, 1, 2)));
int scanf(const char *restrict, ...)
    __attribute__((__format__(__scanf__, 1, 2)));
int sscanf(const char *restrict, const char *restrict, ...)
    __attribute__((__format__(__scanf__, 2, 3)));
int vfprintf(FILE *restrict, const char *restrict, __gnuc_va_list)
    __attribute__((__format__(__printf__, 2, 0)));
int vprintf(const char *, __gnuc_va_list)
    __attribute__((__format__(__printf__, 1, 0)));
int vsprintf(char *restrict, const char *restrict, __gnuc_va_list)
    __attribute__((__format__(__printf__, 2, 0)));
int fgetc(FILE *);
char *fgets(char *restrict, int, FILE *restrict);
int fputc(int, FILE *);
int fputs(const char *restrict, FILE *restrict);
int getc(FILE *);
int getchar(void);
char *gets(char *);
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int ungetc(int, FILE *);
size_t fread(void *restrict, size_t _size, size_t _n, FILE *restrict);
size_t fwrite(const void *restrict, size_t _size, size_t _n, FILE *);

int fgetpos(FILE *restrict, fpos_t *restrict);

int fseek(FILE *, long, int);

int fsetpos(FILE *, const fpos_t *);

long ftell(FILE *);
void rewind(FILE *);
void clearerr(FILE *);
int feof(FILE *);
int ferror(FILE *);
void perror(const char *);

FILE *fopen(const char *restrict _name, const char *restrict _type);
int sprintf(char *restrict, const char *restrict, ...)
    __attribute__((__format__(__printf__, 2, 3)));
int remove(const char *);
int rename(const char *, const char *);
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);

int snprintf(char *restrict, size_t, const char *restrict, ...)
    __attribute__((__format__(__printf__, 3, 4)));
int vsnprintf(char *restrict, size_t, const char *restrict, __gnuc_va_list)
    __attribute__((__format__(__printf__, 3, 0)));
int vfscanf(FILE *restrict, const char *restrict, __gnuc_va_list)
    __attribute__((__format__(__scanf__, 2, 0)));
int vscanf(const char *, __gnuc_va_list)
    __attribute__((__format__(__scanf__, 1, 0)));
int vsscanf(const char *restrict, const char *restrict, __gnuc_va_list)
    __attribute__((__format__(__scanf__, 2, 0)));
/*
 * Routines in POSIX 1003.1:2001.
 */

FILE *fdopen(int, const char *);

int fileno(FILE *);

int pclose(FILE *);
FILE *popen(const char *, const char *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);

/*
 * Routines in POSIX 1003.1:200x.
 */
/*
 * Recursive versions of the above.
 */

int _asiprintf_r(struct _reent *, char **, const char *, ...)
    __attribute__((__format__(__printf__, 3, 4)));
char *_asniprintf_r(struct _reent *, char *, size_t *, const char *, ...)
    __attribute__((__format__(__printf__, 4, 5)));
char *_asnprintf_r(struct _reent *, char *restrict, size_t *restrict,
                   const char *restrict, ...)
    __attribute__((__format__(__printf__, 4, 5)));
int _asprintf_r(struct _reent *, char **restrict, const char *restrict, ...)
    __attribute__((__format__(__printf__, 3, 4)));
int _diprintf_r(struct _reent *, int, const char *, ...)
    __attribute__((__format__(__printf__, 3, 4)));
int _dprintf_r(struct _reent *, int, const char *restrict, ...)
    __attribute__((__format__(__printf__, 3, 4)));
int _fclose_r(struct _reent *, FILE *);
int _fcloseall_r(struct _reent *);
FILE *_fdopen_r(struct _reent *, int, const char *);
int _fflush_r(struct _reent *, FILE *);
int _fgetc_r(struct _reent *, FILE *);
int _fgetc_unlocked_r(struct _reent *, FILE *);
char *_fgets_r(struct _reent *, char *restrict, int, FILE *restrict);
char *_fgets_unlocked_r(struct _reent *, char *restrict, int, FILE *restrict);

int _fgetpos_r(struct _reent *, FILE *, fpos_t *);
int _fsetpos_r(struct _reent *, FILE *, const fpos_t *);

int _fiprintf_r(struct _reent *, FILE *, const char *, ...)
    __attribute__((__format__(__printf__, 3, 4)));
int _fiscanf_r(struct _reent *, FILE *, const char *, ...)
    __attribute__((__format__(__scanf__, 3, 4)));
FILE *_fmemopen_r(struct _reent *, void *restrict, size_t,
                  const char *restrict);
FILE *_fopen_r(struct _reent *, const char *restrict, const char *restrict);
FILE *_freopen_r(struct _reent *, const char *restrict, const char *restrict,
                 FILE *restrict);
int _fprintf_r(struct _reent *, FILE *restrict, const char *restrict, ...)
    __attribute__((__format__(__printf__, 3, 4)));
int _fpurge_r(struct _reent *, FILE *);
int _fputc_r(struct _reent *, int, FILE *);
int _fputc_unlocked_r(struct _reent *, int, FILE *);
int _fputs_r(struct _reent *, const char *restrict, FILE *restrict);
int _fputs_unlocked_r(struct _reent *, const char *restrict, FILE *restrict);
size_t _fread_r(struct _reent *, void *restrict, size_t _size, size_t _n,
                FILE *restrict);
size_t _fread_unlocked_r(struct _reent *, void *restrict, size_t _size,
                         size_t _n, FILE *restrict);
int _fscanf_r(struct _reent *, FILE *restrict, const char *restrict, ...)
    __attribute__((__format__(__scanf__, 3, 4)));
int _fseek_r(struct _reent *, FILE *, long, int);
int _fseeko_r(struct _reent *, FILE *, _off_t, int);
long _ftell_r(struct _reent *, FILE *);
_off_t _ftello_r(struct _reent *, FILE *);
void _rewind_r(struct _reent *, FILE *);
size_t _fwrite_r(struct _reent *, const void *restrict, size_t _size, size_t _n,
                 FILE *restrict);
size_t _fwrite_unlocked_r(struct _reent *, const void *restrict, size_t _size,
                          size_t _n, FILE *restrict);
int _getc_r(struct _reent *, FILE *);
int _getc_unlocked_r(struct _reent *, FILE *);
int _getchar_r(struct _reent *);
int _getchar_unlocked_r(struct _reent *);
char *_gets_r(struct _reent *, char *);
int _iprintf_r(struct _reent *, const char *, ...)
    __attribute__((__format__(__printf__, 2, 3)));
int _iscanf_r(struct _reent *, const char *, ...)
    __attribute__((__format__(__scanf__, 2, 3)));
FILE *_open_memstream_r(struct _reent *, char **, size_t *);
void _perror_r(struct _reent *, const char *);
int _printf_r(struct _reent *, const char *restrict, ...)
    __attribute__((__format__(__printf__, 2, 3)));
int _putc_r(struct _reent *, int, FILE *);
int _putc_unlocked_r(struct _reent *, int, FILE *);
int _putchar_unlocked_r(struct _reent *, int);
int _putchar_r(struct _reent *, int);
int _puts_r(struct _reent *, const char *);
int _remove_r(struct _reent *, const char *);
int _rename_r(struct _reent *, const char *_old, const char *_new);
int _scanf_r(struct _reent *, const char *restrict, ...)
    __attribute__((__format__(__scanf__, 2, 3)));
int _siprintf_r(struct _reent *, char *, const char *, ...)
    __attribute__((__format__(__printf__, 3, 4)));
int _siscanf_r(struct _reent *, const char *, const char *, ...)
    __attribute__((__format__(__scanf__, 3, 4)));
int _sniprintf_r(struct _reent *, char *, size_t, const char *, ...)
    __attribute__((__format__(__printf__, 4, 5)));
int _snprintf_r(struct _reent *, char *restrict, size_t, const char *restrict,
                ...) __attribute__((__format__(__printf__, 4, 5)));
int _sprintf_r(struct _reent *, char *restrict, const char *restrict, ...)
    __attribute__((__format__(__printf__, 3, 4)));
int _sscanf_r(struct _reent *, const char *restrict, const char *restrict, ...)
    __attribute__((__format__(__scanf__, 3, 4)));
char *_tempnam_r(struct _reent *, const char *, const char *);
FILE *_tmpfile_r(struct _reent *);
char *_tmpnam_r(struct _reent *, char *);
int _ungetc_r(struct _reent *, int, FILE *);
int _vasiprintf_r(struct _reent *, char **, const char *, __gnuc_va_list)
    __attribute__((__format__(__printf__, 3, 0)));
char *_vasniprintf_r(struct _reent *, char *, size_t *, const char *,
                     __gnuc_va_list)
    __attribute__((__format__(__printf__, 4, 0)));
char *_vasnprintf_r(struct _reent *, char *, size_t *, const char *,
                    __gnuc_va_list)
    __attribute__((__format__(__printf__, 4, 0)));
int _vasprintf_r(struct _reent *, char **, const char *, __gnuc_va_list)
    __attribute__((__format__(__printf__, 3, 0)));
int _vdiprintf_r(struct _reent *, int, const char *, __gnuc_va_list)
    __attribute__((__format__(__printf__, 3, 0)));
int _vdprintf_r(struct _reent *, int, const char *restrict, __gnuc_va_list)
    __attribute__((__format__(__printf__, 3, 0)));
int _vfiprintf_r(struct _reent *, FILE *, const char *, __gnuc_va_list)
    __attribute__((__format__(__printf__, 3, 0)));
int _vfiscanf_r(struct _reent *, FILE *, const char *, __gnuc_va_list)
    __attribute__((__format__(__scanf__, 3, 0)));
int _vfprintf_r(struct _reent *, FILE *restrict, const char *restrict,
                __gnuc_va_list) __attribute__((__format__(__printf__, 3, 0)));
int _vfscanf_r(struct _reent *, FILE *restrict, const char *restrict,
               __gnuc_va_list) __attribute__((__format__(__scanf__, 3, 0)));
int _viprintf_r(struct _reent *, const char *, __gnuc_va_list)
    __attribute__((__format__(__printf__, 2, 0)));
int _viscanf_r(struct _reent *, const char *, __gnuc_va_list)
    __attribute__((__format__(__scanf__, 2, 0)));
int _vprintf_r(struct _reent *, const char *restrict, __gnuc_va_list)
    __attribute__((__format__(__printf__, 2, 0)));
int _vscanf_r(struct _reent *, const char *restrict, __gnuc_va_list)
    __attribute__((__format__(__scanf__, 2, 0)));
int _vsiprintf_r(struct _reent *, char *, const char *, __gnuc_va_list)
    __attribute__((__format__(__printf__, 3, 0)));
int _vsiscanf_r(struct _reent *, const char *, const char *, __gnuc_va_list)
    __attribute__((__format__(__scanf__, 3, 0)));
int _vsniprintf_r(struct _reent *, char *, size_t, const char *, __gnuc_va_list)
    __attribute__((__format__(__printf__, 4, 0)));
int _vsnprintf_r(struct _reent *, char *restrict, size_t, const char *restrict,
                 __gnuc_va_list) __attribute__((__format__(__printf__, 4, 0)));
int _vsprintf_r(struct _reent *, char *restrict, const char *restrict,
                __gnuc_va_list) __attribute__((__format__(__printf__, 3, 0)));
int _vsscanf_r(struct _reent *, const char *restrict, const char *restrict,
               __gnuc_va_list) __attribute__((__format__(__scanf__, 3, 0)));

/* Other extensions.  */

int fpurge(FILE *);
ssize_t __getdelim(char **, size_t *, int, FILE *);
ssize_t __getline(char **, size_t *, FILE *);
/*
 * Routines internal to the implementation.
 */

int __srget_r(struct _reent *, FILE *);
int __swbuf_r(struct _reent *, int, FILE *);

/*
 * Stdio function-access interface.
 */
/*
 * The __sfoo macros are here so that we can
 * define function versions in the C library.
 */

/*  For a platform with CR/LF, additional logic is required by
  __sgetc_r which would otherwise simply be a macro; therefore we
  use an inlined function.  The function is only meant to be inlined
  in place as used and the function body should never be emitted.

  There are two possible means to this end when compiling with GCC,
  one when compiling with a standard C99 compiler, and for other
  compilers we're just stuck.  At the moment, this issue only
  affects the Cygwin target, so we'll most likely be using GCC. */

static __inline__ int __sgetc_r(struct _reent *__ptr, FILE *__p);

static __inline__ int __sgetc_r(struct _reent *__ptr, FILE *__p) {
  int __c = (--(__p)->_r < 0 ? __srget_r(__ptr, __p) : (int)(*(__p)->_p++));
  if ((__p->_flags & 0x4000 /* convert line endings CR/LF <-> NL */) &&
      (__c == '\r')) {
    int __c2 = (--(__p)->_r < 0 ? __srget_r(__ptr, __p) : (int)(*(__p)->_p++));
    if (__c2 == '\n')
      __c = __c2;
    else
      ungetc(__c2, __p);
  }
  return __c;
}

static __inline__ int __sputc_r(struct _reent *_ptr, int _c, FILE *_p) {

  if ((_p->_flags & 0x4000 /* convert line endings CR/LF <-> NL */) &&
      _c == '\n')
    __sputc_r(_ptr, '\r', _p);

  if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
    return (*_p->_p++ = _c);
  else
    return (__swbuf_r(_ptr, _c, _p));
}
static __inline int _getchar_unlocked(void) {
  struct _reent *_ptr;

  _ptr = (__getreent());
  return (__sgetc_r(_ptr, ((_ptr)->_stdin)));
}

static __inline int _putchar_unlocked(int _c) {
  struct _reent *_ptr;

  _ptr = (__getreent());
  return (__sputc_r(_ptr, _c, ((_ptr)->_stdout)));
}

/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */

/* On FreeBSD 5, machine/ansi.h does not exist anymore... */

/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */

/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* If this symbol has done its job, get rid of it.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* A null pointer constant.  */
/* Offset of member MEMBER in a struct of type TYPE. */

/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/* machine/stdlib.h

  This file is part of Cygwin.

  This software is a copyrighted work licensed under the terms of the
  Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
  details. */

char *mkdtemp(char *);

/* libc/include/alloca.h - Allocate memory on stack */

/* Written 2000 by Werner Almesberger */
/* Rearranged for general inclusion by stdlib.h.
   2001, Corinna Vinschen <vinschen@redhat.com> */

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */

/* stdlib.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/* cygwin/wait.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */
/* A status is 16 bits, and looks like:
      <1 byte info> <1 byte code>

      <code> == 0, child has exited, info is the exit value
      <code> == 1..7e, child has exited, info is the signal number.
      <code> == 7f, child has stopped, info was the signal number.
      <code> == 80, there was a core dump.
*/

const char *getprogname(void);
void setprogname(const char *);

int unsetenv(const char *);

char *ptsname(int);
int grantpt(int);
int unlockpt(int);

int posix_openpt(int);

extern void *memalign(size_t, size_t);

typedef struct {
  int quot; /* quotient */
  int rem;  /* remainder */
} div_t;

typedef struct {
  long quot; /* quotient */
  long rem;  /* remainder */
} ldiv_t;

typedef struct {
  long long int quot; /* quotient */
  long long int rem;  /* remainder */
} lldiv_t;

typedef int (*__compar_fn_t)(const void *, const void *);

int __locale_mb_cur_max(void);

void abort(void) __attribute__((__noreturn__));
int abs(int);

int atexit(void (*__func)(void));
double atof(const char *__nptr);

int atoi(const char *__nptr);
int _atoi_r(struct _reent *, const char *__nptr);
long atol(const char *__nptr);
long _atol_r(struct _reent *, const char *__nptr);
void *bsearch(const void *__key, const void *__base, size_t __nmemb,
              size_t __size, __compar_fn_t _compar);
void *calloc(size_t, size_t) __attribute__((__malloc__))
__attribute__((__warn_unused_result__)) __attribute__((__alloc_size__(1, 2)));
div_t div(int __numer, int __denom);
void exit(int __status) __attribute__((__noreturn__));
void free(void *);
char *getenv(const char *__string);
char *_getenv_r(struct _reent *, const char *__string);
char *_findenv(const char *, int *);
char *_findenv_r(struct _reent *, const char *, int *);

long labs(long);
ldiv_t ldiv(long __numer, long __denom);
void *malloc(size_t) __attribute__((__malloc__))
__attribute__((__warn_unused_result__)) __attribute__((__alloc_size__(1)));
int mblen(const char *, size_t);
int _mblen_r(struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc(wchar_t *restrict, const char *restrict, size_t);
int _mbtowc_r(struct _reent *, wchar_t *restrict, const char *restrict, size_t,
              _mbstate_t *);
int wctomb(char *, wchar_t);
int _wctomb_r(struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t);
size_t _mbstowcs_r(struct _reent *, wchar_t *restrict, const char *restrict,
                   size_t, _mbstate_t *);
size_t wcstombs(char *restrict, const wchar_t *restrict, size_t);
size_t _wcstombs_r(struct _reent *, char *restrict, const wchar_t *restrict,
                   size_t, _mbstate_t *);
int mkstemp(char *);
char *_mkdtemp_r(struct _reent *, char *);
int _mkostemp_r(struct _reent *, char *, int);
int _mkostemps_r(struct _reent *, char *, int, int);
int _mkstemp_r(struct _reent *, char *);
int _mkstemps_r(struct _reent *, char *, int);
char *_mktemp_r(struct _reent *, char *) __attribute__((
    __deprecated__("the use of `mktemp' is dangerous; use `mkstemp' instead")));
void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t _compar);
int rand(void);
void *realloc(void *, size_t) __attribute__((__warn_unused_result__))
__attribute__((__alloc_size__(2)));

char *realpath(const char *restrict path, char *restrict resolved_path);

void setkey(const char *__key);

void srand(unsigned __seed);
double strtod(const char *restrict __n, char **restrict __end_PTR);
double _strtod_r(struct _reent *, const char *restrict __n,
                 char **restrict __end_PTR);

float strtof(const char *restrict __n, char **restrict __end_PTR);

long strtol(const char *restrict __n, char **restrict __end_PTR, int __base);
long _strtol_r(struct _reent *, const char *restrict __n,
               char **restrict __end_PTR, int __base);
unsigned long strtoul(const char *restrict __n, char **restrict __end_PTR,
                      int __base);
unsigned long _strtoul_r(struct _reent *, const char *restrict __n,
                         char **restrict __end_PTR, int __base);
int system(const char *__string);

long a64l(const char *__input);
char *l64a(long __input);
char *_l64a_r(struct _reent *, long __input);

void _Exit(int __status) __attribute__((__noreturn__));

int putenv(char *__string);

int _putenv_r(struct _reent *, char *__string);
void *_reallocf_r(struct _reent *, void *, size_t);

int setenv(const char *__string, const char *__value, int __overwrite);

int _setenv_r(struct _reent *, const char *__string, const char *__value,
              int __overwrite);
char *__itoa(int, char *, int);
char *__utoa(unsigned, char *, int);

int rand_r(unsigned *__seed);

double drand48(void);
double _drand48_r(struct _reent *);
double erand48(unsigned short[3]);
double _erand48_r(struct _reent *, unsigned short[3]);
long jrand48(unsigned short[3]);
long _jrand48_r(struct _reent *, unsigned short[3]);
void lcong48(unsigned short[7]);
void _lcong48_r(struct _reent *, unsigned short[7]);
long lrand48(void);
long _lrand48_r(struct _reent *);
long mrand48(void);
long _mrand48_r(struct _reent *);
long nrand48(unsigned short[3]);
long _nrand48_r(struct _reent *, unsigned short[3]);
unsigned short *seed48(unsigned short[3]);
unsigned short *_seed48_r(struct _reent *, unsigned short[3]);
void srand48(long);
void _srand48_r(struct _reent *, long);

char *initstate(unsigned, char *, size_t);
long random(void);
char *setstate(char *);
void srandom(unsigned);

long long atoll(const char *__nptr);

long long _atoll_r(struct _reent *, const char *__nptr);

long long llabs(long long);
lldiv_t lldiv(long long __numer, long long __denom);
long long strtoll(const char *restrict __n, char **restrict __end_PTR,
                  int __base);

long long _strtoll_r(struct _reent *, const char *restrict __n,
                     char **restrict __end_PTR, int __base);

unsigned long long strtoull(const char *restrict __n, char **restrict __end_PTR,
                            int __base);

unsigned long long _strtoull_r(struct _reent *, const char *restrict __n,
                               char **restrict __end_PTR, int __base);
int posix_memalign(void **, size_t, size_t) __attribute__((__nonnull__(1)))
__attribute__((__warn_unused_result__));

char *_dtoa_r(struct _reent *, double, int, int, int *, int *, char **);

int _system_r(struct _reent *, const char *);

void __eprintf(const char *, const char *, unsigned int, const char *);

/* There are two common qsort_r variants.  If you request
   _BSD_SOURCE, you get the BSD version; otherwise you get the GNU
   version.  We want that #undef qsort_r will still let you
   invoke the underlying function, but that requires gcc support. */
/* On platforms where long double equals double.  */

extern long double _strtold_r(struct _reent *, const char *restrict,
                              char **restrict);

extern long double strtold(const char *restrict, char **restrict);

/*
 * If we're in a mode greater than C99, expose C11 functions.
 */

void *aligned_alloc(size_t, size_t) __attribute__((__malloc__))
__attribute__((__alloc_align__(1))) __attribute__((__alloc_size__(2)))
__attribute__((__warn_unused_result__));
int at_quick_exit(void (*)(void));
_Noreturn void quick_exit(int);

/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */

/* On FreeBSD 5, machine/ansi.h does not exist anymore... */

/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */

/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* If this symbol has done its job, get rid of it.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* A null pointer constant.  */
/* Offset of member MEMBER in a struct of type TYPE. */

void *memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
void *memcpy(void *restrict, const void *restrict, size_t);
void *memmove(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *restrict, const char *restrict);
char *strchr(const char *, int);
int strcmp(const char *, const char *);
int strcoll(const char *, const char *);
char *strcpy(char *restrict, const char *restrict);
size_t strcspn(const char *, const char *);
char *strerror(int);
size_t strlen(const char *);
char *strncat(char *restrict, const char *restrict, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *restrict, const char *restrict, size_t);
char *strpbrk(const char *, const char *);
char *strrchr(const char *, int);
size_t strspn(const char *, const char *);
char *strstr(const char *, const char *);

char *strtok(char *restrict, const char *restrict);

size_t strxfrm(char *restrict, const char *restrict, size_t);

char *strtok_r(char *restrict, const char *restrict, char **restrict);

void *memccpy(void *restrict, const void *restrict, int, size_t);
char *strdup(const char *) __attribute__((__malloc__))
__attribute__((__warn_unused_result__));

char *_strdup_r(struct _reent *, const char *);

char *_strndup_r(struct _reent *, const char *, size_t);

/* There are two common strerror_r variants.  If you request
   _GNU_SOURCE, you get the GNU version; otherwise you get the POSIX
   version.  POSIX requires that #undef strerror_r will still let you
   invoke the underlying function, but that requires gcc support.  */

int strerror_r(int, char *, size_t)

    __asm__("_" /* stringify without expanding x */
            /* expand x, then stringify */ "__xpg_strerror_r")

        ;

/* Reentrant version of strerror.  */
char *_strerror_r(struct _reent *, int, int, int *);
char *strsignal(int __signo);

int strtosigno(const char *__name);
/* There are two common basename variants.  If you do NOT #include <libgen.h>
   and you do

     #define _GNU_SOURCE
     #include <string.h>

   you get the GNU version.  Otherwise you get the POSIX versionfor which you
   should #include <libgen.h>i for the function prototype.  POSIX requires that
   #undef basename will still let you invoke the underlying function.  However,
   this also implies that the POSIX version is used in this case.  That's made
   sure here. */

/* This is a dummy <sys/string.h> used as a placeholder for
   systems that need to have a special header file.  */

/*
 * time.h
 *
 * Struct and function declarations for dealing with time.
 */

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */

/* On FreeBSD 5, machine/ansi.h does not exist anymore... */

/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */

/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* If this symbol has done its job, get rid of it.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* A null pointer constant.  */
/* Offset of member MEMBER in a struct of type TYPE. */

/* Get _CLOCKS_PER_SEC_ */
/* unified sys/types.h:
   start with sef's sysvi386 version.
   merge go32 version -- a few ifdefs.
   h8300hms, h8300xray, and sysvnecv70 disagree on the following types:

   typedef int gid_t;
   typedef int uid_t;
   typedef int dev_t;
   typedef int ino_t;
   typedef int mode_t;
   typedef int caddr_t;

   however, these aren't "reasonable" values, the sysvi386 ones make far
   more sense, and should work sufficiently well (in particular, h8300
   doesn't have a stat, and the necv70 doesn't matter.) -- eichin
 */
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD$
 */

/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD$
 */
/*
 * Structure defined by POSIX.1b to be like a itimerval, but with
 * timespecs. Used in the timer_*() system calls.
 */
struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};

struct tm {
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;

  long tm_gmtoff;

  const char *tm_zone;
};

clock_t clock(void);
double difftime(time_t _time2, time_t _time1);
time_t mktime(struct tm *_timeptr);
time_t time(time_t *_timer);

char *asctime(const struct tm *_tblock);
char *ctime(const time_t *_time);
struct tm *gmtime(const time_t *_timer);
struct tm *localtime(const time_t *_timer);

size_t strftime(char *restrict _s, size_t _maxsize, const char *restrict _fmt,
                const struct tm *restrict _t);

char *asctime_r(const struct tm *restrict, char *restrict);
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t *restrict, struct tm *restrict);
struct tm *localtime_r(const time_t *restrict, struct tm *restrict);

char *strptime(const char *restrict, const char *restrict, struct tm *restrict);

void tzset(void);

void _tzset_r(struct _reent *);

typedef struct __tzrule_struct {
  char ch;
  int m;
  int n;
  int d;
  int s;
  time_t change;
  long offset; /* Match type of _timezone. */
} __tzrule_type;

typedef struct __tzinfo_struct {
  int __tznorth;
  int __tzyear;
  __tzrule_type __tzrule[2];
} __tzinfo_type;

__tzinfo_type *__gettzinfo(void);

/* getdate functions */
/* defines for the opengroup specifications Derived from Issue 1 of the SVID. */

extern __attribute__((dllimport)) long _timezone;
extern __attribute__((dllimport)) int _daylight;

extern __attribute__((dllimport)) char *_tzname[2];

/* POSIX defines the external tzname being defined in time.h */
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */

/* time.h

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */
/* Not defined in main time.h */
int __attribute__((__cdecl__)) clock_setres(clockid_t, struct timespec *);

/* GNU extensions. */
time_t __attribute__((__cdecl__)) timelocal(struct tm *);
time_t __attribute__((__cdecl__)) timegm(struct tm *);
extern int daylight __asm__("_"
                            "_daylight");

extern long timezone __asm__("_"
                             "_timezone");
/* Clocks, P1003.1b-1993, p. 263 */

int clock_settime(clockid_t clock_id, const struct timespec *tp);
int clock_gettime(clockid_t clock_id, struct timespec *tp);
int clock_getres(clockid_t clock_id, struct timespec *res);

/* Create a Per-Process Timer, P1003.1b-1993, p. 264 */

int timer_create(clockid_t clock_id, struct sigevent *restrict evp,
                 timer_t *restrict timerid);

/* Delete a Per_process Timer, P1003.1b-1993, p. 266 */

int timer_delete(timer_t timerid);

/* Per-Process Timers, P1003.1b-1993, p. 267 */

int timer_settime(timer_t timerid, int flags,
                  const struct itimerspec *restrict value,
                  struct itimerspec *restrict ovalue);
int timer_gettime(timer_t timerid, struct itimerspec *value);
int timer_getoverrun(timer_t timerid);

/* High Resolution Sleep, P1003.1b-1993, p. 269 */

int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);
int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *rqtp,
                    struct timespec *rmtp);
/* CPU-time Clock Attributes, P1003.4b/D8, p. 54 */

/* values for the clock enable attribute */

/* values for the pthread cputime_clock_allowed attribute */

/*   CPU-time clock attached to that thread */
/*   shall be accessible. */

/*   thread shall not have a CPU-time clock */
/*   accessible. */

/* Manifest Constants, P1003.1b-1993, p. 262 */

/* Flag indicating time is "absolute" with respect to the clock
   associated with a time.  */

/* Manifest Constants, P1003.4b/D8, p. 55 */

/* When used in a clock or timer function call, this is interpreted as
   the identifier of the CPU_time clock associated with the PROCESS
   making the function call.  */

/*  When used in a clock or timer function call, this is interpreted as
    the identifier of the CPU_time clock associated with the THREAD
    making the function call.  */

/*  The identifier for the system-wide monotonic clock, which is defined
 *      as a clock whose value cannot be set via clock_settime() and which
 *          cannot have backward clock jumps. */

/* Accessing a Process CPU-time CLock, P1003.4b/D8, p. 55 */

int clock_getcpuclockid(pid_t pid, clockid_t *clock_id);

/* CPU-time Clock Attribute Access, P1003.4b/D8, p. 56 */

int clock_setenable_attr(clockid_t clock_id, int attr);
int clock_getenable_attr(clockid_t clock_id, int *attr);

/* setup for luaconf.h */

/*
** $Id: luaconf.h $
** Configuration file for Lua
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/*
** ===================================================================
** Search for "@@" to find all configurable definitions.
** ===================================================================
*/

/*
** {====================================================================
** System Configuration: macros to adapt (if needed) Lua to some
** particular platform, for instance compiling it with 32-bit numbers or
** restricting it to C89.
** =====================================================================
*/

/*
@@ LUAI_MAXCSTACK defines the maximum depth for nested calls and
** also limits the maximum depth of other recursive algorithms in
** the implementation, such as syntactic analysis. A value too
** large may allow the interpreter to crash (C-stack overflow).
** The default value seems ok for regular machines, but may be
** too high for restricted hardware.
** The test file 'cstack.lua' may help finding a good limit.
** (It will crash with a limit too high.)
*/

/*
@@ LUA_32BITS enables Lua with 32-bit integers and 32-bit floats. You
** can also define LUA_32BITS in the make file, but changing here you
** ensure that all software connected to Lua will be compiled with the
** same configuration.
*/
/* #define LUA_32BITS */

/*
@@ LUA_USE_C89 controls the use of non-ISO-C89 features.
** Define it if you want Lua to avoid the use of a few C99 features
** or Windows-specific features on Windows.
*/
/* #define LUA_USE_C89 */

/*
** By default, Lua on Windows use (some) specific Windows features
*/
/*
@@ LUA_C89_NUMBERS ensures that Lua uses the largest types available for
** C89 ('long' and 'double'); Windows always has '__int64', so it does
** not need to use this case.
*/

/*
@@ LUAI_BITSINT defines the (minimum) number of bits in an 'int'.
*/
/* avoid undefined shifts */
/*
@@ LUA_INT_TYPE defines the type for Lua integers.
@@ LUA_FLOAT_TYPE defines the type for Lua floats.
** Lua should work fine with any mix of these options (if supported
** by your C compiler). The usual configurations are 64-bit integers
** and 'double' (the default), 32-bit integers and 'float' (for
** restricted platforms), and 'long'/'double' (for C compilers not
** compliant with C99, which may not have support for 'long long').
*/

/* predefined options for LUA_INT_TYPE */

/* predefined options for LUA_FLOAT_TYPE */
/*
** default configuration for 64-bit Lua ('long long' and 'double')
*/
/* }================================================================== */

/*
** {==================================================================
** Configuration for Paths.
** ===================================================================
*/

/*
** LUA_PATH_SEP is the character that separates templates in a path.
** LUA_PATH_MARK is the string that marks the substitution points in a
** template.
** LUA_EXEC_DIR in a Windows path is replaced by the executable's
** directory.
*/

/*
@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
** Lua libraries.
@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
** C libraries.
** CHANGE them if your machine has a non-conventional directory
** hierarchy or if you want to install your libraries in
** non-conventional directories.
*/
/*
@@ LUA_DIRSEP is the directory separator (for submodules).
** CHANGE it if your machine does not use "/" as the directory separator
** and is not Windows. (On Windows Lua automatically uses "\".)
*/

/* }================================================================== */

/*
** {==================================================================
** Marks for exported symbols in the C code
** ===================================================================
*/

/*
@@ LUA_API is a mark for all core API functions.
@@ LUALIB_API is a mark for all auxiliary library functions.
@@ LUAMOD_API is a mark for all standard library opening functions.
** CHANGE them if you need to define those functions in some special way.
** For instance, if you want to create one Windows DLL with the core and
** the libraries, you may want to use the following definition (define
** LUA_BUILD_AS_DLL to get it).
*/
/*
** More often than not the libs go together with the core.
*/

/*
@@ LUAI_FUNC is a mark for all extern functions that are not to be
** exported to outside modules.
@@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables,
** none of which to be exported to outside modules (LUAI_DDEF for
** definitions and LUAI_DDEC for declarations).
** CHANGE them if you need to mark them in some special way. Elf/gcc
** (versions 3.2 and later) mark them as "hidden" to optimize access
** when Lua is compiled as a shared library. Not all elf targets support
** this attribute. Unfortunately, gcc does not offer a way to check
** whether the target offers that support, and those without support
** give a warning about it. To avoid these warnings, change to the
** default definition.
*/
/* }================================================================== */

/*
** {==================================================================
** Compatibility with previous versions
** ===================================================================
*/

/*
@@ LUA_COMPAT_5_3 controls other macros for compatibility with Lua 5.3.
** You can define it to get all options, or change specific options
** to fit your specific needs.
*/
/*
@@ The following macros supply trivial compatibility for some
** changes in the API. The macros themselves document how to
** change your code to avoid using them.
*/

/* }================================================================== */

/*
** {==================================================================
** Configuration for Numbers.
** Change these definitions if no predefined LUA_FLOAT_* / LUA_INT_*
** satisfy your needs.
** ===================================================================
*/

/*
@@ LUA_NUMBER is the floating-point type used by Lua.
@@ LUAI_UACNUMBER is the result of a 'default argument promotion'
@@ over a floating number.
@@ l_mathlim(x) corrects limit name 'x' to the proper float type
** by prefixing it with one of FLT/DBL/LDBL.
@@ LUA_NUMBER_FRMLEN is the length modifier for writing floats.
@@ LUA_NUMBER_FMT is the format for writing floats.
@@ lua_number2str converts a float to a string.
@@ l_mathop allows the addition of an 'l' or 'f' to all math operations.
@@ l_floor takes the floor of a float.
@@ lua_str2number converts a decimal numeric string to a number.
*/

/* The following definitions are good for most cases here */

/*
@@ lua_numbertointeger converts a float number with an integral value
** to an integer, or returns 0 if float is not within the range of
** a lua_Integer.  (The range comparisons are tricky because of
** rounding. The tests here assume a two-complement representation,
** where MININTEGER always has an exact representation as a float;
** MAXINTEGER may not have one, and therefore its conversion to float
** may have an ill-defined value.)
*/

/* now the variable definitions */
/*
@@ LUA_INTEGER is the integer type used by Lua.
**
@@ LUA_UNSIGNED is the unsigned version of LUA_INTEGER.
**
@@ LUAI_UACINT is the result of a 'default argument promotion'
@@ over a lUA_INTEGER.
@@ LUA_INTEGER_FRMLEN is the length modifier for reading/writing integers.
@@ LUA_INTEGER_FMT is the format for writing integers.
@@ LUA_MAXINTEGER is the maximum value for a LUA_INTEGER.
@@ LUA_MININTEGER is the minimum value for a LUA_INTEGER.
@@ LUA_MAXUNSIGNED is the maximum value for a LUA_UNSIGNED.
@@ LUA_UNSIGNEDBITS is the number of bits in a LUA_UNSIGNED.
@@ lua_integer2str converts an integer to a string.
*/

/* The following definitions are good for most cases here */
/*
** use LUAI_UACINT here to avoid problems with promotions (which
** can turn a comparison between unsigneds into a signed comparison)
*/

/* now the variable definitions */
/* use presence of macro LLONG_MAX as proxy for C99 compliance */

/* use ISO C99 stuff */
/* }================================================================== */

/*
** {==================================================================
** Dependencies with C99 and other C details
** ===================================================================
*/

/*
@@ l_sprintf is equivalent to 'snprintf' or 'sprintf' in C89.
** (All uses in Lua have only one format item.)
*/

/*
@@ lua_strx2number converts a hexadecimal numeric string to a number.
** In C99, 'strtod' does that conversion. Otherwise, you can
** leave 'lua_strx2number' undefined and Lua will provide its own
** implementation.
*/

/*
@@ lua_pointer2str converts a pointer to a readable string in a
** non-specified way.
*/

/*
@@ lua_number2strx converts a float to a hexadecimal numeric string.
** In C99, 'sprintf' (with format specifiers '%a'/'%A') does that.
** Otherwise, you can leave 'lua_number2strx' undefined and Lua will
** provide its own implementation.
*/

/*
** 'strtof' and 'opf' variants for math functions are not valid in
** C89. Otherwise, the macro 'HUGE_VALF' is a good proxy for testing the
** availability of these variants. ('math.h' is already included in
** all files that use these macros.)
*/
/*
@@ LUA_KCONTEXT is the type of the context ('ctx') for continuation
** functions.  It must be a numerical type; Lua will use 'intptr_t' if
** available, otherwise it will use 'ptrdiff_t' (the nearest thing to
** 'intptr_t' in C89)
*/

/*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */

/*
 *  $Id$
 */
/*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */

/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */

/* gcc > 3.2 implicitly defines the values we are interested */

/* Determine how intptr_t and intN_t fastN_t and leastN_t are defined by gcc
   for this target.  This is used to determine the correct printf() constant in
   inttypes.h and other  constants in stdint.h.
   So we end up with
   ?(signed|unsigned) char == 0
   ?(signed|unsigned) short == 1
   ?(signed|unsigned) int == 2
   ?(signed|unsigned) short int == 3
   ?(signed|unsigned) long == 4
   ?(signed|unsigned) long int == 6
   ?(signed|unsigned) long long == 8
   ?(signed|unsigned) long long int == 10
 */

/* Nothing to define because int32_t is safe to print as an int. */

/*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */

typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;

typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;

typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;

typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;

/*
 * Fastest minimum-width integer types
 *
 * Assume int to be the fastest type for all types with a width
 * less than __INT_MAX__ rsp. INT_MAX
 */

typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef int int_fast16_t;
typedef unsigned int uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
typedef long long int int_fast64_t;
typedef long long unsigned int uint_fast64_t;

/*
 * Fall back to [u]int_least<N>_t for [u]int_fast<N>_t types
 * not having been defined, yet.
 * Leave undefined, if [u]int_least<N>_t should not be available.
 */
/* Limits of Specified-Width Integer Types */
/* This must match size_t in stddef.h, currently long unsigned int */

/* This must match sig_atomic_t in <signal.h> (currently int) */

/* This must match ptrdiff_t  in <stddef.h> (currently long int) */

/* This must match definition in <wchar.h> */
/* This must match definition in <wchar.h> */
/* wint_t is unsigned int on almost all GCC targets.  */
/** Macros for minimum-width integer constant expressions */
/** Macros for greatest-width integer constant expression */

/*
@@ lua_getlocaledecpoint gets the locale "radix character" (decimal point).
** Change that if you do not want to use C locales. (Code using this
** macro must include header 'locale.h'.)
*/

/* }================================================================== */

/*
** {==================================================================
** Language Variations
** =====================================================================
*/

/*
@@ LUA_NOCVTN2S/LUA_NOCVTS2N control how Lua performs some
** coercions. Define LUA_NOCVTN2S to turn off automatic coercion from
** numbers to strings. Define LUA_NOCVTS2N to turn off automatic
** coercion from strings to numbers.
*/
/* #define LUA_NOCVTN2S */
/* #define LUA_NOCVTS2N */

/*
@@ LUA_USE_APICHECK turns on several consistency checks on the C API.
** Define it as a help when debugging C code.
*/

/* }================================================================== */

/*
** {==================================================================
** Macros that affect the API and must be stable (that is, must be the
** same when you compile Lua and when you compile code that links to
** Lua). You probably do not want/need to change them.
** =====================================================================
*/

/*
@@ LUAI_MAXSTACK limits the size of the Lua stack.
** CHANGE it if you need a different limit. This limit is arbitrary;
** its only purpose is to stop Lua from consuming unlimited stack
** space (and to reserve some numbers for pseudo-indices).
** (It must fit into max(size_t)/32.)
*/

/*
@@ LUA_EXTRASPACE defines the size of a raw memory area associated with
** a Lua state with very fast access.
** CHANGE it if you need a different size.
*/

/*
@@ LUA_IDSIZE gives the maximum size for the description of the source
@@ of a function in debug information.
** CHANGE it if you want a different size.
*/

/*
@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
** CHANGE it if it uses too much C-stack space. (For long double,
** 'string.format("%.99f", -1e4932)' needs 5052 bytes, so a
** smaller buffer would force a memory allocation for each call to
** 'string.format'.)
*/

/*
@@ LUAI_MAXALIGN defines fields that, when used in a union, ensure
** maximum alignment for the other items in that union.
*/

/* }================================================================== */

/* =================================================================== */

/*
** Local configuration. You can use this space to add your redefinitions
** without modifying the main part of the file.
*/

/* do not export internal symbols */

/* core -- used by all */
/*
** $Id: lzio.c $
** Buffered streams
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/*
** $Id: luaconf.h $
** Configuration file for Lua
** See Copyright Notice in lua.h
*/
/* mark for precompiled code ('<esc>Lua') */

/* option for multiple returns in 'lua_pcall' and 'lua_call' */

/*
** Pseudo-indices
** (-LUAI_MAXSTACK is the minimum valid index; we keep some free empty
** space after that to help overflow detection)
*/

/* thread status */
typedef struct lua_State lua_State;

/*
** basic types
*/
/* minimum Lua stack available to a C function */

/* predefined values in the registry */

/* type of numbers in Lua */
typedef double lua_Number;

/* type for integer functions */
typedef long long lua_Integer;

/* unsigned integer type */
typedef unsigned long long lua_Unsigned;

/* type for continuation-function contexts */
typedef intptr_t lua_KContext;

/*
** Type for C functions registered with Lua
*/
typedef int (*lua_CFunction)(lua_State *L);

/*
** Type for continuation functions
*/
typedef int (*lua_KFunction)(lua_State *L, int status, lua_KContext ctx);

/*
** Type for functions that read/write blocks when loading/dumping Lua chunks
*/
typedef const char *(*lua_Reader)(lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer)(lua_State *L, const void *p, size_t sz, void *ud);

/*
** Type for memory-allocation functions
*/
typedef void *(*lua_Alloc)(void *ud, void *ptr, size_t osize, size_t nsize);

/*
** Type for warning functions
*/
typedef void (*lua_WarnFunction)(void *ud, const char *msg, int tocont);

/*
** generic extra include file
*/

/*
** RCS ident string
*/
extern const char lua_ident[];

/*
** state manipulation
*/
extern lua_State *(lua_newstate)(lua_Alloc f, void *ud);
extern void(lua_close)(lua_State *L);
extern lua_State *(lua_newthread)(lua_State *L);
extern int(lua_resetthread)(lua_State *L);

extern lua_CFunction(lua_atpanic)(lua_State *L, lua_CFunction panicf);

extern lua_Number(lua_version)(lua_State *L);

/*
** basic stack manipulation
*/
extern int(lua_absindex)(lua_State *L, int idx);
extern int(lua_gettop)(lua_State *L);
extern void(lua_settop)(lua_State *L, int idx);
extern void(lua_pushvalue)(lua_State *L, int idx);
extern void(lua_rotate)(lua_State *L, int idx, int n);
extern void(lua_copy)(lua_State *L, int fromidx, int toidx);
extern int(lua_checkstack)(lua_State *L, int n);

extern void(lua_xmove)(lua_State *from, lua_State *to, int n);

/*
** access functions (stack -> C)
*/

extern int(lua_isnumber)(lua_State *L, int idx);
extern int(lua_isstring)(lua_State *L, int idx);
extern int(lua_iscfunction)(lua_State *L, int idx);
extern int(lua_isinteger)(lua_State *L, int idx);
extern int(lua_isuserdata)(lua_State *L, int idx);
extern int(lua_type)(lua_State *L, int idx);
extern const char *(lua_typename)(lua_State *L, int tp);

extern lua_Number(lua_tonumberx)(lua_State *L, int idx, int *isnum);
extern lua_Integer(lua_tointegerx)(lua_State *L, int idx, int *isnum);
extern int(lua_toboolean)(lua_State *L, int idx);
extern const char *(lua_tolstring)(lua_State *L, int idx, size_t *len);
extern lua_Unsigned(lua_rawlen)(lua_State *L, int idx);
extern lua_CFunction(lua_tocfunction)(lua_State *L, int idx);
extern void *(lua_touserdata)(lua_State *L, int idx);
extern lua_State *(lua_tothread)(lua_State *L, int idx);
extern const void *(lua_topointer)(lua_State *L, int idx);

/*
** Comparison and arithmetic functions
*/
extern void(lua_arith)(lua_State *L, int op);

extern int(lua_rawequal)(lua_State *L, int idx1, int idx2);
extern int(lua_compare)(lua_State *L, int idx1, int idx2, int op);

/*
** push functions (C -> stack)
*/
extern void(lua_pushnil)(lua_State *L);
extern void(lua_pushnumber)(lua_State *L, lua_Number n);
extern void(lua_pushinteger)(lua_State *L, lua_Integer n);
extern const char *(lua_pushlstring)(lua_State *L, const char *s, size_t len);
extern const char *(lua_pushstring)(lua_State *L, const char *s);
extern const char *(lua_pushvfstring)(lua_State *L, const char *fmt,
                                      va_list argp);
extern const char *(lua_pushfstring)(lua_State *L, const char *fmt, ...);
extern void(lua_pushcclosure)(lua_State *L, lua_CFunction fn, int n);
extern void(lua_pushboolean)(lua_State *L, int b);
extern void(lua_pushlightuserdata)(lua_State *L, void *p);
extern int(lua_pushthread)(lua_State *L);

/*
** get functions (Lua -> stack)
*/
extern int(lua_getglobal)(lua_State *L, const char *name);
extern int(lua_gettable)(lua_State *L, int idx);
extern int(lua_getfield)(lua_State *L, int idx, const char *k);
extern int(lua_geti)(lua_State *L, int idx, lua_Integer n);
extern int(lua_rawget)(lua_State *L, int idx);
extern int(lua_rawgeti)(lua_State *L, int idx, lua_Integer n);
extern int(lua_rawgetp)(lua_State *L, int idx, const void *p);

extern void(lua_createtable)(lua_State *L, int narr, int nrec);
extern void *(lua_newuserdatauv)(lua_State *L, size_t sz, int nuvalue);
extern int(lua_getmetatable)(lua_State *L, int objindex);
extern int(lua_getiuservalue)(lua_State *L, int idx, int n);

/*
** set functions (stack -> Lua)
*/
extern void(lua_setglobal)(lua_State *L, const char *name);
extern void(lua_settable)(lua_State *L, int idx);
extern void(lua_setfield)(lua_State *L, int idx, const char *k);
extern void(lua_seti)(lua_State *L, int idx, lua_Integer n);
extern void(lua_rawset)(lua_State *L, int idx);
extern void(lua_rawseti)(lua_State *L, int idx, lua_Integer n);
extern void(lua_rawsetp)(lua_State *L, int idx, const void *p);
extern int(lua_setmetatable)(lua_State *L, int objindex);
extern int(lua_setiuservalue)(lua_State *L, int idx, int n);

/*
** 'load' and 'call' functions (load and run Lua code)
*/
extern void(lua_callk)(lua_State *L, int nargs, int nresults, lua_KContext ctx,
                       lua_KFunction k);

extern int(lua_pcallk)(lua_State *L, int nargs, int nresults, int errfunc,
                       lua_KContext ctx, lua_KFunction k);

extern int(lua_load)(lua_State *L, lua_Reader reader, void *dt,
                     const char *chunkname, const char *mode);

extern int(lua_dump)(lua_State *L, lua_Writer writer, void *data, int strip);

/*
** coroutine functions
*/
extern int(lua_yieldk)(lua_State *L, int nresults, lua_KContext ctx,
                       lua_KFunction k);
extern int(lua_resume)(lua_State *L, lua_State *from, int narg, int *nres);
extern int(lua_status)(lua_State *L);
extern int(lua_isyieldable)(lua_State *L);

/*
** Warning-related functions
*/
extern void(lua_setwarnf)(lua_State *L, lua_WarnFunction f, void *ud);
extern void(lua_warning)(lua_State *L, const char *msg, int tocont);

/*
** garbage-collection function and options
*/
extern int(lua_gc)(lua_State *L, int what, ...);

/*
** miscellaneous functions
*/

extern int(lua_error)(lua_State *L);

extern int(lua_next)(lua_State *L, int idx);

extern void(lua_concat)(lua_State *L, int n);
extern void(lua_len)(lua_State *L, int idx);

extern size_t(lua_stringtonumber)(lua_State *L, const char *s);

extern lua_Alloc(lua_getallocf)(lua_State *L, void **ud);
extern void(lua_setallocf)(lua_State *L, lua_Alloc f, void *ud);

extern void(lua_toclose)(lua_State *L, int idx);

/*
** {==============================================================
** some useful macros
** ===============================================================
*/
/* }============================================================== */

/*
** {==============================================================
** compatibility macros
** ===============================================================
*/
/* }============================================================== */

/*
** {======================================================================
** Debug API
** =======================================================================
*/

/*
** Event codes
*/

/*
** Event masks
*/

typedef struct lua_Debug lua_Debug; /* activation record */

/* Functions to be called by the debugger in specific events */
typedef void (*lua_Hook)(lua_State *L, lua_Debug *ar);

extern int(lua_getstack)(lua_State *L, int level, lua_Debug *ar);
extern int(lua_getinfo)(lua_State *L, const char *what, lua_Debug *ar);
extern const char *(lua_getlocal)(lua_State *L, const lua_Debug *ar, int n);
extern const char *(lua_setlocal)(lua_State *L, const lua_Debug *ar, int n);
extern const char *(lua_getupvalue)(lua_State *L, int funcindex, int n);
extern const char *(lua_setupvalue)(lua_State *L, int funcindex, int n);

extern void *(lua_upvalueid)(lua_State *L, int fidx, int n);
extern void(lua_upvaluejoin)(lua_State *L, int fidx1, int n1, int fidx2,
                             int n2);

extern void(lua_sethook)(lua_State *L, lua_Hook func, int mask, int count);
extern lua_Hook(lua_gethook)(lua_State *L);
extern int(lua_gethookmask)(lua_State *L);
extern int(lua_gethookcount)(lua_State *L);

struct lua_Debug {
  int event;
  const char *name;         /* (n) */
  const char *namewhat;     /* (n) 'global', 'local', 'field', 'method' */
  const char *what;         /* (S) 'Lua', 'C', 'main', 'tail' */
  const char *source;       /* (S) */
  size_t srclen;            /* (S) */
  int currentline;          /* (l) */
  int linedefined;          /* (S) */
  int lastlinedefined;      /* (S) */
  unsigned char nups;       /* (u) number of upvalues */
  unsigned char nparams;    /* (u) number of parameters */
  char isvararg;            /* (u) */
  char istailcall;          /* (t) */
  unsigned short ftransfer; /* (r) index of first value transferred */
  unsigned short ntransfer; /* (r) number of transferred values */
  char short_src[60];       /* (S) */
  /* private part */
  struct CallInfo *i_ci; /* active function */
};

/* }====================================================================== */

/******************************************************************************
 * Copyright (C) 1994-2019 Lua.org, PUC-Rio.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/*
** $Id: llimits.h $
** Limits, basic types, and some other 'installation-dependent' definitions
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** 'lu_mem' and 'l_mem' are unsigned/signed integers big enough to count
** the total memory used by Lua (in bytes). Usually, 'size_t' and
** 'ptrdiff_t' should work, but we use 'long' for 16-bit machines.
*/

typedef size_t lu_mem;
typedef ptrdiff_t l_mem;

/* chars used as small naturals (so that 'char' is reserved for characters) */
typedef unsigned char lu_byte;
typedef signed char ls_byte;

/* maximum value for size_t */

/* maximum size visible for Lua (must be representable in a lua_Integer */
/*
** floor of the log2 of the maximum signed value for integral type 't'.
** (That is, maximum 'n' such that '2^n' fits in the given signed type.)
*/

/*
** test whether an unsigned value is a power of 2 (or zero)
*/

/* number of chars of a literal string without the ending \0 */

/*
** conversion of pointer to unsigned integer:
** this is for hashing only; there is no problem if the integer
** cannot hold the whole pointer value
*/

/* types of 'usual argument conversions' for lua_Number and lua_Integer */
typedef double l_uacNumber;
typedef long long l_uacInt;

/* internal assertions for in-house debugging */
/*
** assertion for checking API calls
*/

/* macro to avoid warnings about unused variables */

/* type casts (a macro highlights casts in the code) */
/* cast a signed lua_Integer to lua_Unsigned */

/*
** cast a lua_Unsigned to a signed lua_Integer; this cast is
** not strict ISO C, but two-complement architectures should
** work fine.
*/

/*
** macros to improve jump prediction (used mainly for error handling)
*/
/*
** non-return type
*/
/*
** type for virtual-machine instructions;
** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
*/

typedef unsigned int l_uint32;

typedef l_uint32 Instruction;

/*
** Maximum length for short strings, that is, strings that are
** internalized. (Cannot be smaller than reserved words or tags for
** metamethods, as these strings must be internalized;
** #("function") = 8, #("__newindex") = 10.)
*/

/*
** Initial size for the string table (must be power of 2).
** The Lua core alone registers ~50 strings (reserved words +
** metaevent keys + a few others). Libraries would typically add
** a few dozens more.
*/

/*
** Size of cache for strings in the API. 'N' is the number of
** sets (better be a prime) and "M" is the size of each set (M == 1
** makes a direct cache.)
*/

/* minimum size for string buffer */

/*
** macros that are executed whenever program enters the Lua core
** ('lua_lock') and leaves the core ('lua_unlock')
*/

/*
** macro executed during Lua functions at points where the
** function can yield.
*/

/*
** these macros allow user-specific actions when a thread is
** created/deleted/resumed/yielded.
*/
/*
** The luai_num* macros define the primitive operations over numbers.
*/

/* floor division (defined as 'floor(a/b)') */

/* float division */

/*
** modulo: defined as 'a - floor(a/b)*b'; the direct computation
** using this definition has several problems with rounding errors,
** so it is better to use 'fmod'. 'fmod' gives the result of
** 'a - trunc(a/b)*b', and therefore must be corrected when
** 'trunc(a/b) ~= floor(a/b)'. That happens when the division has a
** non-integer negative result: non-integer result is equivalent to
** a non-zero remainder 'm'; negative result is equivalent to 'a' and
** 'b' with different signs, or 'm' and 'b' with different signs
** (as the result 'm' of 'fmod' has the same sign of 'a').
*/

/* exponentiation */

/* the others are quite standard operations */
/*
** macro to control inclusion of some hard tests on stack reallocation
*/
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/*
** $Id: llimits.h $
** Limits, basic types, and some other 'installation-dependent' definitions
** See Copyright Notice in lua.h
*/
/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** This macro tests whether it is safe to multiply 'n' by the size of
** type 't' without overflows. Because 'e' is always constant, it avoids
** the runtime division MAX_SIZET/(e).
** (The macro is somewhat complex to avoid warnings:  The 'sizeof'
** comparison avoids a runtime comparison when overflow cannot occur.
** The compiler should be able to optimize the real test by itself, but
** when it does it, it may give a warning about "comparison is always
** false due to limited range of data type"; the +1 tricks the compiler,
** avoiding this warning but also this optimization.)
*/

/*
** Computes the minimum between 'n' and 'MAX_SIZET/sizeof(t)', so that
** the result is not larger than 'n' and cannot overflow a 'size_t'
** when multiplied by the size of type 't'. (Assumes that 'n' is an
** 'int' or 'unsigned int' and that 'int' is not larger than 'size_t'.)
*/

/*
** Arrays of chars do not need any test
*/
static void __attribute__((noreturn)) luaM_toobig(lua_State *L);

/* not to be called directly */
static void *luaM_realloc_(lua_State *L, void *block, size_t oldsize,
                           size_t size);
static void *luaM_saferealloc_(lua_State *L, void *block, size_t oldsize,
                               size_t size);
static void luaM_free_(lua_State *L, void *block, size_t osize);
static void *luaM_growaux_(lua_State *L, void *block, int nelems, int *size,
                           int size_elem, int limit, const char *what);
static void *luaM_shrinkvector_(lua_State *L, void *block, int *nelem,
                                int final_n, int size_elem);
static void *luaM_malloc_(lua_State *L, size_t size, int tag);
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */

/*
** $Id: llimits.h $
** Limits, basic types, and some other 'installation-dependent' definitions
** See Copyright Notice in lua.h
*/
/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** Extra tags for non-values
*/

/*
** number of all possible tags (including LUA_TNONE)
*/

/*
** tags for Tagged Values have the following use of bits:
** bits 0-3: actual tag (a LUA_T* value)
** bits 4-5: variant bits
** bit 6: whether value is collectable
*/

/*
** Union of all Lua values
*/
typedef union Value {
  struct GCObject *gc; /* collectable objects */
  void *p;             /* light userdata */
  int b;               /* booleans */
  lua_CFunction f;     /* light C functions */
  lua_Integer i;       /* integer numbers */
  lua_Number n;        /* float numbers */
} Value;

/*
** Tagged Values. This is the basic representation of values in Lua:
** an actual value plus a tag with its type.
*/

typedef struct TValue {
  Value value_;
  lu_byte tt_;
} TValue;

/* raw type tag of a TValue */

/* tag with no variants (bits 0-3) */

/* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */

/* type of a TValue */

/* Macros to test type */

/* Macros for internal tests */

/* Macros to set values */
/*
** different types of assignments, according to destination
*/

/* from stack to stack */

/* to stack (not from same stack) */

/* from table to same table */

/* to new object */

/* to table */

typedef union StackValue {
  TValue val;
} StackValue;

typedef StackValue *StkId; /* index to stack elements */

/* convert a 'StackValue' to a 'TValue' */

/*
** {==================================================================
** Nil
** ===================================================================
*/

/* macro to test for (any kind of) nil */

/* macro to test for a "pure" nil */

/*
** Variant tag, used only in tables to signal an empty slot
** (which might be different from a slot containing nil)
*/

/*
** Variant used only in the value returned for a key not found in a
** table (absent key).
*/

/*
** macro to detect non-standard nils (used only in assertions)
*/

/*
** By default, entries with any kind of nil are considered empty.
** (In any definition, values associated with absent keys must also
** be accepted as empty.)
*/

/* macro defining a value corresponding to an absent key */

/* mark an entry as empty */

/* }================================================================== */

/*
** {==================================================================
** Booleans
** ===================================================================
*/
/* }================================================================== */

/*
** {==================================================================
** Threads
** ===================================================================
*/
/* }================================================================== */

/*
** {==================================================================
** Collectable Objects
** ===================================================================
*/

/*
** Common Header for all collectable objects (in macro form, to be
** included in other objects)
*/

/* Common type for all collectable objects */
typedef struct GCObject {
  struct GCObject *next;
  lu_byte tt;
  lu_byte marked;
} GCObject;

/* Bit mark for collectable types */

/* mark a tag as collectable */
/* }================================================================== */

/*
** {==================================================================
** Numbers
** ===================================================================
*/

/* Variant tags for numbers */
/* }================================================================== */

/*
** {==================================================================
** Strings
** ===================================================================
*/

/* Variant tags for strings */
/* set a string to the stack */

/* set a string to a new object */

/*
** Header for string value; string bytes follow the end of this structure
** (aligned according to 'UTString'; see next).
*/
typedef struct TString {
  struct GCObject *next;
  lu_byte tt;
  lu_byte marked;
  lu_byte extra;  /* reserved words for short strings; "has hash" for longs */
  lu_byte shrlen; /* length for short strings */
  unsigned int hash;
  union {
    size_t lnglen;         /* length for long strings */
    struct TString *hnext; /* linked list for hash table */
  } u;
} TString;

/*
** Get the actual string (array of bytes) from a 'TString'.
** (Access to 'extra' ensures that value is really a 'TString'.)
*/

/* get the actual string (array of bytes) from a Lua value */

/* get string length from 'TString *s' */

/* get string length from 'TValue *o' */

/* }================================================================== */

/*
** {==================================================================
** Userdata
** ===================================================================
*/
/* Ensures that addresses after this type are always fully aligned. */
typedef union UValue {
  TValue uv;
  lua_Number n;
  double u;
  void *s;
  lua_Integer i;
  long l; /* ensures maximum alignment for udata bytes */
} UValue;

/*
** Header for userdata with user values;
** memory area follows the end of this structure.
*/
typedef struct Udata {
  struct GCObject *next;
  lu_byte tt;
  lu_byte marked;
  unsigned short nuvalue; /* number of user values */
  size_t len;             /* number of bytes */
  struct Table *metatable;
  GCObject *gclist;
  UValue uv[1]; /* user values */
} Udata;

/*
** Header for userdata with no user values. These userdata do not need
** to be gray during GC, and therefore do not need a 'gclist' field.
** To simplify, the code always use 'Udata' for both kinds of userdata,
** making sure it never accesses 'gclist' on userdata with no user values.
** This structure here is used only to compute the correct size for
** this representation. (The 'bindata' field in its end ensures correct
** alignment for binary data following this header.)
*/
typedef struct Udata0 {
  struct GCObject *next;
  lu_byte tt;
  lu_byte marked;
  unsigned short nuvalue; /* number of user values */
  size_t len;             /* number of bytes */
  struct Table *metatable;
  union {
    lua_Number n;
    double u;
    void *s;
    lua_Integer i;
    long l;
  } bindata;
} Udata0;

/* compute the offset of the memory area of a userdata */

/* get the address of the memory block inside 'Udata' */

/* compute the size of a userdata */

/* }================================================================== */

/*
** {==================================================================
** Prototypes
** ===================================================================
*/

/*
** Description of an upvalue for function prototypes
*/
typedef struct Upvaldesc {
  TString *name;   /* upvalue name (for debug information) */
  lu_byte instack; /* whether it is in stack (register) */
  lu_byte idx;     /* index of upvalue (in stack or in outer function's list) */
} Upvaldesc;

/*
** Description of a local variable for function prototypes
** (used for debug information)
*/
typedef struct LocVar {
  TString *varname;
  int startpc; /* first point where variable is active */
  int endpc;   /* first point where variable is dead */
} LocVar;

/*
** Associates the absolute line source for a given instruction ('pc').
** The array 'lineinfo' gives, for each instruction, the difference in
** lines from the previous instruction. When that difference does not
** fit into a byte, Lua saves the absolute line for that instruction.
** (Lua also saves the absolute line periodically, to speed up the
** computation of a line number: we can use binary search in the
** absolute-line array, but we must traverse the 'lineinfo' array
** linearly to compute a line.)
*/
typedef struct AbsLineInfo {
  int pc;
  int line;
} AbsLineInfo;

/*
** Function Prototypes
*/
typedef struct Proto {
  struct GCObject *next;
  lu_byte tt;
  lu_byte marked;
  lu_byte numparams; /* number of fixed (named) parameters */
  lu_byte is_vararg;
  lu_byte maxstacksize; /* number of registers needed by this function */
  int sizeupvalues;     /* size of 'upvalues' */
  int sizek;            /* size of 'k' */
  int sizecode;
  int sizelineinfo;
  int sizep; /* size of 'p' */
  int sizelocvars;
  int sizeabslineinfo; /* size of 'abslineinfo' */
  int linedefined;     /* debug information  */
  int lastlinedefined; /* debug information  */
  TValue *k;           /* constants used by the function */
  Instruction *code;   /* opcodes */
  struct Proto **p;    /* functions defined inside the function */
  Upvaldesc *upvalues; /* upvalue information */
  ls_byte *lineinfo;   /* information about source lines (debug information) */
  AbsLineInfo *abslineinfo; /* idem */
  LocVar *locvars; /* information about local variables (debug information) */
  TString *source; /* used for debug information */
  GCObject *gclist;
} Proto;

/* }================================================================== */

/*
** {==================================================================
** Closures
** ===================================================================
*/

/* Variant tags for functions */
/*
** Upvalues for Lua closures
*/
typedef struct UpVal {
  struct GCObject *next;
  lu_byte tt;
  lu_byte marked;
  TValue *v; /* points to stack or to its own value */
  union {
    struct {              /* (when open) */
      struct UpVal *next; /* linked list */
      struct UpVal **previous;
    } open;
    TValue value; /* the value (when closed) */
  } u;
} UpVal;

/* variant for "To Be Closed" upvalues */

typedef struct CClosure {
  struct GCObject *next;
  lu_byte tt;
  lu_byte marked;
  lu_byte nupvalues;
  GCObject *gclist;
  lua_CFunction f;
  TValue upvalue[1]; /* list of upvalues */
} CClosure;

typedef struct LClosure {
  struct GCObject *next;
  lu_byte tt;
  lu_byte marked;
  lu_byte nupvalues;
  GCObject *gclist;
  struct Proto *p;
  UpVal *upvals[1]; /* list of upvalues */
} LClosure;

typedef union Closure {
  CClosure c;
  LClosure l;
} Closure;

/* }================================================================== */

/*
** {==================================================================
** Tables
** ===================================================================
*/
/*
** Nodes for Hash tables: A pack of two TValue's (key-value pairs)
** plus a 'next' field to link colliding entries. The distribution
** of the key's fields ('key_tt' and 'key_val') not forming a proper
** 'TValue' allows for a smaller size for 'Node' both in 4-byte
** and 8-byte alignments.
*/
typedef union Node {
  struct NodeKey {
    Value value_;
    lu_byte tt_;    /* fields for value */
    lu_byte key_tt; /* key type */
    int next;       /* for chaining */
    Value key_val;  /* key value */
  } u;
  TValue i_val; /* direct access to node's value as a proper 'TValue' */
} Node;

/* copy a value into a key */

/* copy a value from a key */

/*
** About 'alimit': if 'isrealasize(t)' is true, then 'alimit' is the
** real size of 'array'. Otherwise, the real size of 'array' is the
** smallest power of two not smaller than 'alimit' (or zero iff 'alimit'
** is zero); 'alimit' is then used as a hint for #t.
*/

typedef struct Table {
  struct GCObject *next;
  lu_byte tt;
  lu_byte marked;
  lu_byte flags;       /* 1<<p means tagmethod(p) is not present */
  lu_byte lsizenode;   /* log2 of size of 'node' array */
  unsigned int alimit; /* "limit" of 'array' array */
  TValue *array;       /* array part */
  Node *node;
  Node *lastfree; /* any free position is before this position */
  struct Table *metatable;
  GCObject *gclist;
} Table;

/*
** Macros to manipulate keys inserted in nodes
*/
/*
** Use a "nil table" to mark dead keys in a table. Those keys serve
** to keep space for removed entries, which may still be part of
** chains. Note that the 'keytt' does not have the BIT_ISCOLLECTABLE
** set, so these values are considered not collectable and are different
** from any valid value.
*/

/* }================================================================== */

/*
** 'module' operation for hashing (size is always a power of 2)
*/
/* size of buffer for 'luaO_utf8esc' function */

static int luaO_int2fb(unsigned int x);
static int luaO_fb2int(int x);
static int luaO_utf8esc(char *buff, unsigned long x);
static int luaO_ceillog2(unsigned int x);
static int luaO_rawarith(lua_State *L, int op, const TValue *p1,
                         const TValue *p2, TValue *res);
static void luaO_arith(lua_State *L, int op, const TValue *p1, const TValue *p2,
                       StkId res);
static size_t luaO_str2num(const char *s, TValue *o);
static int luaO_hexavalue(int c);
static void luaO_tostring(lua_State *L, TValue *obj);
static const char *luaO_pushvfstring(lua_State *L, const char *fmt,
                                     va_list argp);
static const char *luaO_pushfstring(lua_State *L, const char *fmt, ...);
static void luaO_chunkid(char *out, const char *source, size_t srclen);
/*
** $Id: ltm.h $
** Tag methods
** See Copyright Notice in lua.h
*/

/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/

/*
 * WARNING: if you change the order of this enumeration,
 * grep "ORDER TM" and "ORDER OP"
 */
typedef enum {
  TM_INDEX,
  TM_NEWINDEX,
  TM_GC,
  TM_MODE,
  TM_LEN,
  TM_EQ, /* last tag method with fast access */
  TM_ADD,
  TM_SUB,
  TM_MUL,
  TM_MOD,
  TM_POW,
  TM_DIV,
  TM_IDIV,
  TM_BAND,
  TM_BOR,
  TM_BXOR,
  TM_SHL,
  TM_SHR,
  TM_UNM,
  TM_BNOT,
  TM_LT,
  TM_LE,
  TM_CONCAT,
  TM_CALL,
  TM_CLOSE,
  TM_N /* number of elements in the enum */
} TMS;

/*
** Test whether there is no tagmethod.
** (Because tagmethods use raw accesses, the result may be an "empty" nil.)
*/
/* empty */

static const char *luaT_objtypename(lua_State *L, const TValue *o);

static const TValue *luaT_gettm(Table *events, TMS event, TString *ename);
static const TValue *luaT_gettmbyobj(lua_State *L, const TValue *o, TMS event);
static void luaT_init(lua_State *L);

static void luaT_callTM(lua_State *L, const TValue *f, const TValue *p1,
                        const TValue *p2, const TValue *p3);
static void luaT_callTMres(lua_State *L, const TValue *f, const TValue *p1,
                           const TValue *p2, StkId p3);
static void luaT_trybinTM(lua_State *L, const TValue *p1, const TValue *p2,
                          StkId res, TMS event);
static void luaT_trybinassocTM(lua_State *L, const TValue *p1, const TValue *p2,
                               StkId res, int inv, TMS event);
static void luaT_trybiniTM(lua_State *L, const TValue *p1, lua_Integer i2,
                           int inv, StkId res, TMS event);
static int luaT_callorderTM(lua_State *L, const TValue *p1, const TValue *p2,
                            TMS event);
static int luaT_callorderiTM(lua_State *L, const TValue *p1, int v2, int inv,
                             int isfloat, TMS event);

static void luaT_adjustvarargs(lua_State *L, int nfixparams,
                               struct CallInfo *ci, const Proto *p);
static void luaT_getvarargs(lua_State *L, struct CallInfo *ci, StkId where,
                            int wanted);
/*
** $Id: lzio.h $
** Buffered streams
** See Copyright Notice in lua.h
*/

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/

typedef struct Zio ZIO;

typedef struct Mbuffer {
  char *buffer;
  size_t n;
  size_t buffsize;
} Mbuffer;
static void luaZ_init(lua_State *L, ZIO *z, lua_Reader reader, void *data);
static size_t luaZ_read(ZIO *z, void *b, size_t n); /* read next n bytes */

/* --------- Private Part ------------------ */

struct Zio {
  size_t n;          /* bytes still unread */
  const char *p;     /* current position in buffer */
  lua_Reader reader; /* reader function */
  void *data;        /* additional data */
  lua_State *L;      /* Lua state (for reader) */
};

static int luaZ_fill(ZIO *z);

/*
** Some notes about garbage-collected objects: All objects in Lua must
** be kept somehow accessible until being freed, so all objects always
** belong to one (and only one) of these lists, using field 'next' of
** the 'CommonHeader' for the link:
**
** 'allgc': all objects not marked for finalization;
** 'finobj': all objects marked for finalization;
** 'tobefnz': all objects ready to be finalized;
** 'fixedgc': all objects that are not to be collected (currently
** only small strings, such as reserved words).
**
** Moreover, there is another set of lists that control gray objects.
** These lists are linked by fields 'gclist'. (All objects that
** can become gray have such a field. The field is not the same
** in all objects, but it always has this name.)  Any gray object
** must belong to one of these lists, and all objects in these lists
** must be gray:
**
** 'gray': regular gray objects, still waiting to be visited.
** 'grayagain': objects that must be revisited at the atomic phase.
**   That includes
**   - black objects got in a write barrier;
**   - all kinds of weak tables during propagation phase;
**   - all threads.
** 'weak': tables with weak values to be cleared;
** 'ephemeron': ephemeron tables with white->white entries;
** 'allweak': tables with weak keys and/or weak values to be cleared.
*/

/*
** About 'nCcalls': each thread in Lua (a lua_State) keeps a count of
** how many "C calls" it can do in the C stack, to avoid C-stack overflow.
** This count is very rough approximation; it considers only recursive
** functions inside the interpreter, as non-recursive calls can be
** considered using a fixed (although unknown) amount of stack space.
**
** The count itself has two parts: the lower part is the count itself;
** the higher part counts the number of non-yieldable calls in the stack.
**
** Because calls to external C functions can use of unkown amount
** of space (e.g., functions using an auxiliary buffer), calls
** to these functions add more than one to the count.
**
** The proper count also includes the number of CallInfo structures
** allocated by Lua, as a kind of "potential" calls. So, when Lua
** calls a function (and "consumes" one CallInfo), it needs neither to
** increment nor to check 'nCcalls', as its use of C stack is already
** accounted for.
*/

/* number of "C stack slots" used by an external C function */

/* true if this thread does not have non-yieldable calls in the stack */

/* real number of C calls */

/* Increment the number of non-yieldable calls */

/* Decrement the number of non-yieldable calls */

/* Increment the number of non-yieldable calls and nCcalls */

/* Decrement the number of non-yieldable calls and nCcalls */

struct lua_longjmp; /* defined in ldo.c */

/*
** Atomic type (relative to signals) to better ensure that 'lua_sethook'
** is thread safe
*/

/* extra stack space to handle TM calls and some other extras */

/* kinds of Garbage Collection */

typedef struct stringtable {
  TString **hash;
  int nuse; /* number of elements */
  int size;
} stringtable;

/*
** Information about a call.
*/
typedef struct CallInfo {
  StkId func;                       /* function index in the stack */
  StkId top;                        /* top for this function */
  struct CallInfo *previous, *next; /* dynamic call link */
  union {
    struct { /* only for Lua functions */
      const Instruction *savedpc;
      sig_atomic_t trap;
      int nextraargs; /* # of extra arguments in vararg functions */
    } l;
    struct {           /* only for C functions */
      lua_KFunction k; /* continuation in case of yields */
      ptrdiff_t old_errfunc;
      lua_KContext ctx; /* context info. in case of yields */
    } c;
  } u;
  union {
    int funcidx; /* called-function index */
    int nyield;  /* number of values yielded */
    struct {     /* info about transfered values (for call/return hooks) */
      unsigned short ftransfer; /* offset of first value transfered */
      unsigned short ntransfer; /* number of values transfered */
    } transferinfo;
  } u2;
  short nresults; /* expected number of results from this function */
  unsigned short callstatus;
} CallInfo;

/*
** Bits in CallInfo status
*/
/* active function is a Lua function */

/* call is running Lua code (not a hook) */

/* assume that CIST_OAH has offset 0 and that 'v' is strictly 0/1 */

/*
** 'global state', shared by all threads of this state
*/
typedef struct global_State {
  lua_Alloc frealloc; /* function to reallocate memory */
  void *ud;           /* auxiliary data to 'frealloc' */
  l_mem totalbytes;   /* number of bytes currently allocated - GCdebt */
  l_mem GCdebt;       /* bytes allocated not yet compensated by the collector */
  lu_mem GCestimate;  /* an estimate of the non-garbage memory in use */
  lu_mem lastatomic;  /* see function 'genstep' in file 'lgc.c' */
  stringtable strt;   /* hash table for strings */
  TValue l_registry;
  TValue nilvalue;   /* a nil value */
  unsigned int seed; /* randomized seed for hashes */
  lu_byte currentwhite;
  lu_byte gcstate;     /* state of garbage collector */
  lu_byte gckind;      /* kind of GC running */
  lu_byte genminormul; /* control for minor generational collections */
  lu_byte genmajormul; /* control for major generational collections */
  lu_byte gcrunning;   /* true if GC is running */
  lu_byte gcemergency; /* true if this is an emergency collection */
  lu_byte gcpause;     /* size of pause between successive GCs */
  lu_byte gcstepmul;   /* GC "speed" */
  lu_byte gcstepsize;  /* (log2 of) GC granularity */
  GCObject *allgc;     /* list of all collectable objects */
  GCObject **sweepgc;  /* current position of sweep in list */
  GCObject *finobj;    /* list of collectable objects with finalizers */
  GCObject *gray;      /* list of gray objects */
  GCObject *grayagain; /* list of objects to be traversed atomically */
  GCObject *weak;      /* list of tables with weak values */
  GCObject *ephemeron; /* list of ephemeron tables (weak keys) */
  GCObject *allweak;   /* list of all-weak tables */
  GCObject *tobefnz;   /* list of userdata to be GC */
  GCObject *fixedgc;   /* list of objects not to be collected */
  /* fields for generational collector */
  GCObject *survival;      /* start of objects that survived one GC cycle */
  GCObject *old;           /* start of old objects */
  GCObject *reallyold;     /* old objects with more than one cycle */
  GCObject *finobjsur;     /* list of survival objects with finalizers */
  GCObject *finobjold;     /* list of old objects with finalizers */
  GCObject *finobjrold;    /* list of really old objects with finalizers */
  struct lua_State *twups; /* list of threads with open upvalues */
  lua_CFunction panic;     /* to be called in unprotected errors */
  struct lua_State *mainthread;
  TString *memerrmsg;       /* message for memory-allocation errors */
  TString *tmname[TM_N];    /* array with tag-method names */
  struct Table *mt[9];      /* metatables for basic types */
  TString *strcache[53][2]; /* cache for strings in API */
  lua_WarnFunction warnf;   /* warning function */
  void *ud_warn;            /* auxiliary data to 'warnf' */
} global_State;

/*
** 'per thread' state
*/
struct lua_State {
  struct GCObject *next;
  lu_byte tt;
  lu_byte marked;
  lu_byte status;
  lu_byte allowhook;
  unsigned short nci; /* number of items in 'ci' list */
  StkId top;          /* first free slot in the stack */
  global_State *l_G;
  CallInfo *ci;             /* call info for current function */
  const Instruction *oldpc; /* last pc traced */
  StkId stack_last;         /* last free slot in the stack */
  StkId stack;              /* stack base */
  UpVal *openupval;         /* list of open upvalues in this stack */
  GCObject *gclist;
  struct lua_State *twups;      /* list of threads with open upvalues */
  struct lua_longjmp *errorJmp; /* current error recover point */
  CallInfo base_ci;             /* CallInfo for first level (C calling Lua) */
  volatile lua_Hook hook;
  ptrdiff_t errfunc; /* current error handling function (stack index) */
  l_uint32 nCcalls;  /* number of allowed nested C calls - 'nci' */
  int stacksize;
  int basehookcount;
  int hookcount;
  sig_atomic_t hookmask;
};

/*
** Union of all collectable objects (only for conversions)
*/
union GCUnion {
  GCObject gc; /* common header */
  struct TString ts;
  struct Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct lua_State th; /* thread */
  struct UpVal upv;
};

/* macros to convert a GCObject into a specific value */
/*
** macro to convert a Lua object into a GCObject
** (The access to 'tt' tries to ensure that 'v' is actually a Lua object.)
*/

/* actual number of total bytes allocated */

static void luaE_setdebt(global_State *g, l_mem debt);
static void luaE_freethread(lua_State *L, lua_State *L1);
static CallInfo *luaE_extendCI(lua_State *L);
static void luaE_freeCI(lua_State *L);
static void luaE_shrinkCI(lua_State *L);
static void luaE_enterCcall(lua_State *L);
static void luaE_warning(lua_State *L, const char *msg, int tocont);
/*
** $Id: lzio.h $
** Buffered streams
** See Copyright Notice in lua.h
*/

int luaZ_fill(ZIO *z) {
  size_t size;
  lua_State *L = z->L;
  const char *buff;
  ((void)0);
  buff = z->reader(L, z->data, &size);
  ((void)0);
  if (buff == ((void *)0) || size == 0)
    return (-1) /* end of stream */;
  z->n = size - 1; /* discount char being returned */
  z->p = buff;
  return ((unsigned char)((*(z->p++))));
}

void luaZ_init(lua_State *L, ZIO *z, lua_Reader reader, void *data) {
  z->L = L;
  z->reader = reader;
  z->data = data;
  z->n = 0;
  z->p = ((void *)0);
}

/* --------------------------------------------------------------- read --- */
size_t luaZ_read(ZIO *z, void *b, size_t n) {
  while (n) {
    size_t m;
    if (z->n == 0) {                                /* no bytes in buffer? */
      if (luaZ_fill(z) == (-1) /* end of stream */) /* try to read more */
        return n; /* no more input; return number of missing bytes */
      else {
        z->n++; /* luaZ_fill consumed first byte; put it back */
        z->p--;
      }
    }
    m = (n <= z->n) ? n : z->n; /* min. between n and z->n */
    memcpy(b, z->p, m);
    z->n -= m;
    z->p += m;
    b = (char *)b + m;
    n -= m;
  }
  return 0;
}
/*
** $Id: lctype.c $
** 'ctype' functions for Lua
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
** $Id: lctype.h $
** 'ctype' functions for Lua
** See Copyright Notice in lua.h
*/

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** WARNING: the functions defined here do not necessarily correspond
** to the similar functions in the standard C ctype.h. They are
** optimized for the specific needs of Lua
*/

/* ASCII case: can use its own tables; faster and fixed */

/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */

/*
** $Id: llimits.h $
** Limits, basic types, and some other 'installation-dependent' definitions
** See Copyright Notice in lua.h
*/
/*
** add 1 to char to allow index -1 (EOZ)
*/

/*
** 'lalpha' (Lua alphabetic) and 'lalnum' (Lua alphanumeric) both include '_'
*/

/*
** this 'ltolower' only works for alphabetic characters
*/

/* two more entries for 0 and -1 (EOZ) */
/* empty */

/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */

static const lu_byte luai_ctype_[255 + 2] = {
    0x00,                                           /* EOZ */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0. */
    0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 1. */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0c, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, /* 2. */
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, /* 3. */
    0x16, 0x16, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x05, /* 4. */
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, /* 5. */
    0x05, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04, 0x05,
    0x04, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x05, /* 6. */
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, /* 7. */
    0x05, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 8. */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 9. */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* a. */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* b. */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* c. */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* d. */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* e. */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* f. */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
/*
** $Id: lopcodes.c $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/*
** $Id: lopcodes.h $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/

/*
** $Id: llimits.h $
** Limits, basic types, and some other 'installation-dependent' definitions
** See Copyright Notice in lua.h
*/

/*===========================================================================
  We assume that instructions are unsigned 32-bit integers.
  All instructions have an opcode in the first 7 bits.
  Instructions can have the following formats:

        3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
        1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
iABC         C(8)     |      B(8)     |k|     A(8)      |   Op(7)     |
iABx               Bx(17)               |     A(8)      |   Op(7)     |
iAsB              sBx (signed)(17)      |     A(8)      |   Op(7)     |
iAx                           Ax(25)                    |   Op(7)     |
isJ                          sJ(25)                     |   Op(7)     |

  A signed argument is represented in excess K: the represented value is
  the written unsigned value minus K, where K is half the maximum for the
  corresponding unsigned argument.
===========================================================================*/

enum OpMode { iABC, iABx, iAsBx, iAx, isJ }; /* basic instruction formats */

/*
** size and position of opcode arguments.
*/
/*
** limits for opcode arguments.
** we use (signed) int to manipulate most arguments,
** so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
*/
/* creates a mask with 'n' 1 bits at position 'p' */

/* creates a mask with 'n' 0 bits at position 'p' */

/*
** the following macros help to manipulate instructions
*/
/*
** invalid register that fits in 8 bits
*/

/*
** R(x) - register
** K(x) - constant (in constant table)
** RK(x) == if k(i) then K(x) else R(x)
*/

/*
** grep "ORDER OP" if you change these enums
*/

typedef enum {
  /*----------------------------------------------------------------------
  name		args	description
  ------------------------------------------------------------------------*/
  OP_MOVE,     /*	A B	R(A) := R(B)					*/
  OP_LOADI,    /*	A sBx	R(A) := sBx					*/
  OP_LOADF,    /*	A sBx	R(A) := (lua_Number)sBx				*/
  OP_LOADK,    /*	A Bx	R(A) := K(Bx)					*/
  OP_LOADKX,   /*	A 	R(A) := K(extra arg)				*/
  OP_LOADBOOL, /*	A B C	R(A) := (Bool)B; if (C) pc++ */
  OP_LOADNIL,  /*	A B	R(A), R(A+1), ..., R(A+B) := nil
                */
  OP_GETUPVAL, /*	A B	R(A) := UpValue[B] */
  OP_SETUPVAL, /*	A B	UpValue[B] := R(A) */

  OP_GETTABUP, /*	A B C	R(A) := UpValue[B][K(C):string] */
  OP_GETTABLE, /*	A B C	R(A) := R(B)[R(C)] */
  OP_GETI,     /*	A B C	R(A) := R(B)[C]					*/
  OP_GETFIELD, /*	A B C	R(A) := R(B)[K(C):string] */

  OP_SETTABUP, /*	A B C	UpValue[A][K(B):string] := RK(C)
                */
  OP_SETTABLE, /*	A B C	R(A)[R(B)] := RK(C) */
  OP_SETI,     /*	A B C	R(A)[B] := RK(C)				*/
  OP_SETFIELD, /*	A B C	R(A)[K(B):string] := RK(C) */

  OP_NEWTABLE, /*	A B C	R(A) := {} (size = B,C) */

  OP_SELF, /*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C):string]	*/

  OP_ADDI,  /*	A B sC	R(A) := R(B) + C				*/
  OP_SUBI,  /*	A B sC	R(A) := R(B) - C				*/
  OP_MULI,  /*	A B sC	R(A) := R(B) * C				*/
  OP_MODI,  /*	A B sC	R(A) := R(B) % C				*/
  OP_POWI,  /*	A B sC	R(A) := R(B) ^ C				*/
  OP_DIVI,  /*	A B sC	R(A) := R(B) / C				*/
  OP_IDIVI, /*	A B sC	R(A) := R(B) // C				*/

  OP_ADDK,  /*	A B C	R(A) := R(B) + K(C)				*/
  OP_SUBK,  /*	A B C	R(A) := R(B) - K(C)				*/
  OP_MULK,  /*	A B C	R(A) := R(B) * K(C)				*/
  OP_MODK,  /*	A B C	R(A) := R(B) % K(C)				*/
  OP_POWK,  /*	A B C	R(A) := R(B) ^ K(C)				*/
  OP_DIVK,  /*	A B C	R(A) := R(B) / K(C)				*/
  OP_IDIVK, /*	A B C	R(A) := R(B) // K(C)				*/

  OP_BANDK, /*	A B C	R(A) := R(B) & K(C):integer			*/
  OP_BORK,  /*	A B C	R(A) := R(B) | K(C):integer			*/
  OP_BXORK, /*	A B C	R(A) := R(B) ~ K(C):integer			*/

  OP_SHRI, /*	A B sC	R(A) := R(B) >> C				*/
  OP_SHLI, /*	A B sC	R(A) := C << R(B)				*/

  OP_ADD,  /*	A B C	R(A) := R(B) + R(C)				*/
  OP_SUB,  /*	A B C	R(A) := R(B) - R(C)				*/
  OP_MUL,  /*	A B C	R(A) := R(B) * R(C)				*/
  OP_MOD,  /*	A B C	R(A) := R(B) % R(C)				*/
  OP_POW,  /*	A B C	R(A) := R(B) ^ R(C)				*/
  OP_DIV,  /*	A B C	R(A) := R(B) / R(C)				*/
  OP_IDIV, /*	A B C	R(A) := R(B) // R(C)				*/

  OP_BAND, /*	A B C	R(A) := R(B) & R(C)				*/
  OP_BOR,  /*	A B C	R(A) := R(B) | R(C)				*/
  OP_BXOR, /*	A B C	R(A) := R(B) ~ R(C)				*/
  OP_SHL,  /*	A B C	R(A) := R(B) << R(C)				*/
  OP_SHR,  /*	A B C	R(A) := R(B) >> R(C)				*/

  OP_UNM,  /*	A B	R(A) := -R(B)					*/
  OP_BNOT, /*	A B	R(A) := ~R(B)					*/
  OP_NOT,  /*	A B	R(A) := not R(B)				*/
  OP_LEN,  /*	A B	R(A) := length of R(B)				*/

  OP_CONCAT, /*	A B  	R(A) := R(A).. ... ..R(A + B - 1)		*/

  OP_CLOSE, /*	A	close all upvalues >= R(A)			*/
  OP_TBC,   /*	A	mark variable A "to be closed"			*/
  OP_JMP,   /*	k sJ	pc += sJ  (k is used in code generation)	*/
  OP_EQ,    /*	A B	if ((R(A) == R(B)) ~= k) then pc++		*/
  OP_LT,    /*	A B	if ((R(A) <  R(B)) ~= k) then pc++		*/
  OP_LE,    /*	A B	if ((R(A) <= R(B)) ~= k) then pc++		*/

  OP_EQK, /*	A B	if ((R(A) == K(B)) ~= k) then pc++		*/
  OP_EQI, /*	A sB	if ((R(A) == sB) ~= k) then pc++		*/
  OP_LTI, /*	A sB	if ((R(A) < sB) ~= k) then pc++			*/
  OP_LEI, /*	A sB	if ((R(A) <= sB) ~= k) then pc++		*/
  OP_GTI, /*	A sB	if ((R(A) > sB) ~= k) then pc++			*/
  OP_GEI, /*	A sB	if ((R(A) >= sB) ~= k) then pc++		*/

  OP_TEST,    /*	A 	if (not R(A) == k) then pc++			*/
  OP_TESTSET, /*	A B	if (not R(B) == k) then pc++ else R(A) := R(B)
               */

  OP_CALL,     /*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
  OP_TAILCALL, /*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))
                */

  OP_RETURN,  /*	A B C	return R(A), ... ,R(A+B-2)	(see note)	*/
  OP_RETURN0, /*	  	return */
  OP_RETURN1, /*	A 	return R(A) */

  OP_FORLOOP, /*	A Bx	R(A)+=R(A+2);
                           if R(A) <?= R(A+1) then { pc-=Bx; R(A+3)=R(A) }
               */
  OP_FORPREP, /*	A Bx	R(A)-=R(A+2); pc+=Bx */

  OP_TFORPREP, /*	A Bx	create upvalue for R(A + 3); pc+=Bx
                */
  OP_TFORCALL, /*	A C	R(A+4), ... ,R(A+3+C) := R(A)(R(A+1), R(A+2));
                */
  OP_TFORLOOP, /*	A Bx	if R(A+2) ~= nil then { R(A)=R(A+2); pc -= Bx
                  }	*/

  OP_SETLIST, /*	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B
               */

  OP_CLOSURE, /*	A Bx	R(A) := closure(KPROTO[Bx]) */

  OP_VARARG, /*	A C  	R(A), R(A+1), ..., R(A+C-2) = vararg		*/

  OP_VARARGPREP, /*A 	(adjust vararg parameters)			*/

  OP_EXTRAARG /*	Ax	extra (larger) argument for previous opcode
               */
} OpCode;

/*===========================================================================
  Notes:
  (*) In OP_CALL, if (B == 0) then B = top - A. If (C == 0), then
  'top' is set to last_result+1, so next open instruction (OP_CALL,
  OP_RETURN*, OP_SETLIST) may use 'top'.

  (*) In OP_VARARG, if (C == 0) then use actual number of varargs and
  set top (like in OP_CALL with C == 0).

  (*) In OP_RETURN, if (B == 0) then return up to 'top'.

  (*) In OP_SETLIST, if (B == 0) then real B = 'top'; if (C == 0) then
  next 'instruction' is EXTRAARG(real C).

  (*) In OP_LOADKX, the next 'instruction' is always EXTRAARG.

  (*) For comparisons, k specifies what condition the test should accept
  (true or false).

  (*) All 'skips' (pc++) assume that next instruction is a jump.

  (*) In instructions OP_RETURN/OP_TAILCALL, 'k' specifies that the
  function either builds upvalues, which may need to be closed, or is
  vararg, which must be corrected before returning. When 'k' is true,
  C > 0 means the function is vararg and (C - 1) is its number of
  fixed parameters.

  (*) In comparisons with an immediate operand, C signals whether the
  original operand was a float.

===========================================================================*/

/*
** masks for instruction properties. The format is:
** bits 0-2: op mode
** bit 3: instruction set register A
** bit 4: operator is a test (next instruction must be a jump)
** bit 5: instruction uses 'L->top' set by previous instruction (when B == 0)
** bit 6: instruction sets 'L->top' for next instruction (when C == 0)
*/

/* empty */

/* "out top" (set top for next instruction) */

/* "in top" (uses top from previous instruction) */

/* number of list items to accumulate before a SETLIST instruction */

/* ORDER OP */

static const lu_byte luaP_opmodes[((int)(OP_EXTRAARG) + 1)] = {
    /*       OT IT T  A  mode		   opcode  */
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_MOVE */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iAsBx)) /* OP_LOADI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iAsBx)) /* OP_LOADF */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABx)) /* OP_LOADK */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABx)) /* OP_LOADKX */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABC)) /* OP_LOADBOOL */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABC)) /* OP_LOADNIL */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABC)) /* OP_GETUPVAL */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) |
     (iABC)) /* OP_SETUPVAL */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABC)) /* OP_GETTABUP */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABC)) /* OP_GETTABLE */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_GETI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABC)) /* OP_GETFIELD */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) |
     (iABC)) /* OP_SETTABUP */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) |
     (iABC)) /* OP_SETTABLE */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) | (iABC)) /* OP_SETI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) |
     (iABC)) /* OP_SETFIELD */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABC)) /* OP_NEWTABLE */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_SELF */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_ADDI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_SUBI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_MULI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_MODI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_POWI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_DIVI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_IDIVI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_ADDK */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_SUBK */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_MULK */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_MODK */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_POWK */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_DIVK */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_IDIVK */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_BANDK */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_BORK */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_BXORK */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_SHRI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_SHLI */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_ADD */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_SUB */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_MUL */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_MOD */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_POW */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_DIV */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_IDIV */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_BAND */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_BOR */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_BXOR */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_SHL */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_SHR */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_UNM */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_BNOT */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_NOT */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_LEN */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_CONCAT */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) | (iABC)) /* OP_CLOSE */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) | (iABC)) /* OP_TBC */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) | (isJ)) /* OP_JMP */
    ,
    (((0) << 6) | ((0) << 5) | ((1) << 4) | ((0) << 3) | (iABC)) /* OP_EQ */
    ,
    (((0) << 6) | ((0) << 5) | ((1) << 4) | ((0) << 3) | (iABC)) /* OP_LT */
    ,
    (((0) << 6) | ((0) << 5) | ((1) << 4) | ((0) << 3) | (iABC)) /* OP_LE */
    ,
    (((0) << 6) | ((0) << 5) | ((1) << 4) | ((0) << 3) | (iABC)) /* OP_EQK */
    ,
    (((0) << 6) | ((0) << 5) | ((1) << 4) | ((0) << 3) | (iABC)) /* OP_EQI */
    ,
    (((0) << 6) | ((0) << 5) | ((1) << 4) | ((0) << 3) | (iABC)) /* OP_LTI */
    ,
    (((0) << 6) | ((0) << 5) | ((1) << 4) | ((0) << 3) | (iABC)) /* OP_LEI */
    ,
    (((0) << 6) | ((0) << 5) | ((1) << 4) | ((0) << 3) | (iABC)) /* OP_GTI */
    ,
    (((0) << 6) | ((0) << 5) | ((1) << 4) | ((0) << 3) | (iABC)) /* OP_GEI */
    ,
    (((0) << 6) | ((0) << 5) | ((1) << 4) | ((0) << 3) | (iABC)) /* OP_TEST */
    ,
    (((0) << 6) | ((0) << 5) | ((1) << 4) | ((1) << 3) |
     (iABC)) /* OP_TESTSET */
    ,
    (((1) << 6) | ((1) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_CALL */
    ,
    (((1) << 6) | ((1) << 5) | ((0) << 4) | ((1) << 3) |
     (iABC)) /* OP_TAILCALL */
    ,
    (((0) << 6) | ((1) << 5) | ((0) << 4) | ((0) << 3) | (iABC)) /* OP_RETURN */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) |
     (iABC)) /* OP_RETURN0 */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) |
     (iABC)) /* OP_RETURN1 */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABx)) /* OP_FORLOOP */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABx)) /* OP_FORPREP */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) |
     (iABx)) /* OP_TFORPREP */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) |
     (iABC)) /* OP_TFORCALL */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABx)) /* OP_TFORLOOP */
    ,
    (((0) << 6) | ((1) << 5) | ((0) << 4) | ((0) << 3) |
     (iABC)) /* OP_SETLIST */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABx)) /* OP_CLOSURE */
    ,
    (((1) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) | (iABC)) /* OP_VARARG */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((1) << 3) |
     (iABC)) /* OP_VARARGPREP */
    ,
    (((0) << 6) | ((0) << 5) | ((0) << 4) | ((0) << 3) |
     (iAx)) /* OP_EXTRAARG */
};
/*
** $Id: lmem.c $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/

/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/

/*
** mark for entries in 'lineinfo' array that has absolute information in
** 'abslineinfo' array
*/

static int luaG_getfuncline(const Proto *f, int pc);
static const char *luaG_findlocal(lua_State *L, CallInfo *ci, int n,
                                  StkId *pos);
static void __attribute__((noreturn))
luaG_typeerror(lua_State *L, const TValue *o, const char *opname);
static void __attribute__((noreturn))
luaG_forerror(lua_State *L, const TValue *o, const char *what);
static void __attribute__((noreturn))
luaG_concaterror(lua_State *L, const TValue *p1, const TValue *p2);
static void __attribute__((noreturn))
luaG_opinterror(lua_State *L, const TValue *p1, const TValue *p2,
                const char *msg);
static void __attribute__((noreturn))
luaG_tointerror(lua_State *L, const TValue *p1, const TValue *p2);
static void __attribute__((noreturn))
luaG_ordererror(lua_State *L, const TValue *p1, const TValue *p2);
static void __attribute__((noreturn))
luaG_runerror(lua_State *L, const char *fmt, ...);
static const char *luaG_addinfo(lua_State *L, const char *msg, TString *src,
                                int line);
static void __attribute__((noreturn)) luaG_errormsg(lua_State *L);
static int luaG_traceexec(lua_State *L, const Instruction *pc);
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/

/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lzio.h $
** Buffered streams
** See Copyright Notice in lua.h
*/

/*
** Macro to check stack size and grow stack if needed.  Parameters
** 'pre'/'pos' allow the macro to preserve a pointer into the
** stack across reallocations, doing the work only when needed.
** 'condmovestack' is used in heavy tests to force a stack reallocation
** at every check.
*/

/* In general, 'pre'/'pos' are empty (nothing to save) */
/* macro to check stack size, preserving 'p' */

/* macro to check stack size and GC */

/* type of protected functions, to be ran by 'runprotected' */
typedef void (*Pfunc)(lua_State *L, void *ud);

static void luaD_seterrorobj(lua_State *L, int errcode, StkId oldtop);
static int luaD_protectedparser(lua_State *L, ZIO *z, const char *name,
                                const char *mode);
static void luaD_hook(lua_State *L, int event, int line, int fTransfer,
                      int nTransfer);
static void luaD_hookcall(lua_State *L, CallInfo *ci);
static void luaD_pretailcall(lua_State *L, CallInfo *ci, StkId func, int n);
static void luaD_call(lua_State *L, StkId func, int nResults);
static void luaD_callnoyield(lua_State *L, StkId func, int nResults);
static void luaD_tryfuncTM(lua_State *L, StkId func);
static int luaD_pcall(lua_State *L, Pfunc func, void *u, ptrdiff_t oldtop,
                      ptrdiff_t ef);
static void luaD_poscall(lua_State *L, CallInfo *ci, int nres);
static int luaD_reallocstack(lua_State *L, int newsize, int raiseerror);
static int luaD_growstack(lua_State *L, int n, int raiseerror);
static void luaD_shrinkstack(lua_State *L);
static void luaD_inctop(lua_State *L);

static void __attribute__((noreturn)) luaD_throw(lua_State *L, int errcode);
static int luaD_rawrunprotected(lua_State *L, Pfunc f, void *ud);
/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/

/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/

/*
** Collectable objects may have one of three colors: white, which
** means the object is not marked; gray, which means the
** object is marked, but its references may be not marked; and
** black, which means that the object and all its references are marked.
** The main invariant of the garbage collector, while marking objects,
** is that a black object can never point to a white one. Moreover,
** any gray object must be in a "gray list" (gray, grayagain, weak,
** allweak, ephemeron) so that it can be visited again before finishing
** the collection cycle. These lists have no meaning when the invariant
** is not being enforced (e.g., sweep phase).
*/

/*
** Possible states of the Garbage Collector
*/
/*
** macro to tell when main invariant (white objects cannot point to black
** ones) must be kept. During a collection, the sweep
** phase may break the invariant, as objects turned white may point to
** still-black objects. The invariant is restored when sweep ends and
** all objects are white again.
*/

/*
** some useful bit tricks
*/
/*
** Layout for bit use in 'marked' field. First three bits are
** used for object "age" in generational mode. Last bit is free
** to be used by respective objects.
*/
/* object age in generational mode */
/* Default Values for GC parameters */

/* wait memory to double before starting new cycle */

/*
** some gc parameters are stored divided by 4 to allow a maximum value
** larger than 1000 in a 'lu_byte'.
*/

/* how much to allocate before next GC step (log2) */

/*
** Check whether the declared GC mode is generational. While in
** generational mode, the collector can go temporarily to incremental
** mode to improve performance. This is signaled by 'g->lastatomic != 0'.
*/

/*
** Does one step of collection when debt becomes positive. 'pre'/'pos'
** allows some adjustments to be done only when needed. macro
** 'condchangemem' is used only for heavy tests (forcing a full
** GC cycle on every opportunity)
*/

/* more often than not, 'pre'/'pos' are empty */
static void luaC_fix(lua_State *L, GCObject *o);
static void luaC_freeallobjects(lua_State *L);
static void luaC_step(lua_State *L);
static void luaC_runtilstate(lua_State *L, int statesmask);
static void luaC_fullgc(lua_State *L, int isemergency);
static GCObject *luaC_newobj(lua_State *L, int tt, size_t sz);
static void luaC_barrier_(lua_State *L, GCObject *o, GCObject *v);
static void luaC_barrierback_(lua_State *L, GCObject *o);
static void luaC_checkfinalizer(lua_State *L, GCObject *o, Table *mt);
static void luaC_changemode(lua_State *L, int newmode);
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** About the realloc function:
** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);
** ('osize' is the old size, 'nsize' is the new size)
**
** * frealloc(ud, NULL, x, s) creates a new block of size 's' (no
** matter 'x').
**
** * frealloc(ud, p, x, 0) frees the block 'p'
** (in this specific case, frealloc must return NULL);
** particularly, frealloc(ud, NULL, 0, 0) does nothing
** (which is equivalent to free(NULL) in ISO C)
**
** frealloc returns NULL if it cannot create or reallocate the area
** (any reallocation to an equal or smaller size cannot fail!)
*/

void *luaM_growaux_(lua_State *L, void *block, int nelems, int *psize,
                    int size_elems, int limit, const char *what) {
  void *newblock;
  int size = *psize;
  if (nelems + 1 <= size)  /* does one extra element still fit? */
    return block;          /* nothing to be done */
  if (size >= limit / 2) { /* cannot double it? */
    if ((__builtin_expect(((size >= limit) != 0),
                          0))) /* cannot grow even a little? */
      luaG_runerror(L, "too many %s (limit is %d)", what, limit);
    size = limit; /* still have at least one free place */
  } else {
    size *= 2;
    if (size < 4)
      size = 4; /* minimum size */
  }
  ((void)0);
  /* 'limit' ensures that multiplication will not overflow */
  newblock = luaM_realloc_(L, block, ((size_t)((*psize))) * size_elems,
                           ((size_t)((size))) * size_elems);
  if ((__builtin_expect(((newblock == ((void *)0)) != 0), 0)))
    luaD_throw(L, 4);
  *psize = size; /* update only when everything else is OK */
  return newblock;
}

void *luaM_shrinkvector_(lua_State *L, void *block, int *size, int final_n,
                         int size_elem) {
  global_State *g = (L->l_G);
  void *newblock;
  size_t oldsize = ((size_t)(((*size) * size_elem)));
  size_t newsize = ((size_t)((final_n * size_elem)));
  ((void)0);
  newblock = (*g->frealloc)(g->ud, block, oldsize, newsize);
  if ((__builtin_expect(((newblock == ((void *)0) && final_n > 0) != 0),
                        0))) /* allocation failed? */
    luaD_throw(L, 4);
  else {
    g->GCdebt += newsize - oldsize;
    *size = final_n;
    return newblock;
  }
}

void __attribute__((noreturn)) luaM_toobig(lua_State *L) {
  luaG_runerror(L, "memory allocation error: block too big");
}

/*
** Free memory
*/
void luaM_free_(lua_State *L, void *block, size_t osize) {
  global_State *g = (L->l_G);
  ((void)0);
  (*g->frealloc)(g->ud, block, osize, 0);
  g->GCdebt -= osize;
}

/*
** In case of allocation fail, this function will call the GC to try
** to free some memory and then try the allocation again.
** (It should not be called when shrinking a block, because then the
** interpreter may be in the middle of a collection step.)
*/
static void *tryagain(lua_State *L, void *block, size_t osize, size_t nsize) {
  global_State *g = (L->l_G);
  if ((((((((&g->nilvalue))->tt_)) & 0x0F)) ==
       (0))) {         /* is state fully build? */
    luaC_fullgc(L, 1); /* try to free some memory... */
    return (*g->frealloc)(g->ud, block, osize, nsize); /* try again */
  } else
    return ((void *)0); /* cannot free any memory without a full state */
}

/*
** generic allocation routine.
*/
void *luaM_realloc_(lua_State *L, void *block, size_t osize, size_t nsize) {
  void *newblock;
  global_State *g = (L->l_G);
  ((void)0);
  ((void)0);
  newblock = (*g->frealloc)(g->ud, block, osize, nsize);
  if ((__builtin_expect(((newblock == ((void *)0) && nsize > 0) != 0), 0))) {
    if (nsize > osize) /* not shrinking a block? */
      newblock = tryagain(L, block, osize, nsize);
    if (newblock == ((void *)0)) /* still no memory? */
      return ((void *)0);
  }
  ((void)0);
  g->GCdebt = (g->GCdebt + nsize) - osize;
  return newblock;
}

void *luaM_saferealloc_(lua_State *L, void *block, size_t osize, size_t nsize) {
  void *newblock = luaM_realloc_(L, block, osize, nsize);
  if ((__builtin_expect(((newblock == ((void *)0) && nsize > 0) != 0),
                        0))) /* allocation failed? */
    luaD_throw(L, 4);
  return newblock;
}

void *luaM_malloc_(lua_State *L, size_t size, int tag) {
  ((void)0);
  if (size == 0)
    return ((void *)0); /* that's all */
  else {
    global_State *g = (L->l_G);
    void *newblock = (*g->frealloc)(g->ud, ((void *)0), tag, size);
    if ((__builtin_expect(((newblock == ((void *)0)) != 0), 0))) {
      newblock = tryagain(L, ((void *)0), tag, size);
      if (newblock == ((void *)0))
        luaD_throw(L, 4);
    }
    g->GCdebt += size;
    return newblock;
  }
}
/*
** $Id: lundump.c $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lfunc.h $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/

/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/* test whether thread is in 'twups' list */

/*
** maximum number of upvalues in a closure (both C and Lua). (Value
** must fit in a VM register.)
*/
/*
** maximum number of misses before giving up the cache of closures
** in prototypes
*/

/*
** Special "status" for 'luaF_close'
*/

/* close upvalues without running their closing methods */

/* close upvalues running all closing methods in protected mode */

static Proto *luaF_newproto(lua_State *L);
static CClosure *luaF_newCclosure(lua_State *L, int nelems);
static LClosure *luaF_newLclosure(lua_State *L, int nelems);
static void luaF_initupvals(lua_State *L, LClosure *cl);
static UpVal *luaF_findupval(lua_State *L, StkId level);
static void luaF_newtbcupval(lua_State *L, StkId level);
static int luaF_close(lua_State *L, StkId level, int status);
static void luaF_unlinkupval(UpVal *uv);
static void luaF_freeproto(lua_State *L, Proto *f);
static const char *luaF_getlocalname(const Proto *func, int local_number,
                                     int pc);
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/

/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/

/*
** Memory-allocation error message must be preallocated (it cannot
** be created after memory is exhausted)
*/
/*
** test whether a string is a reserved word
*/

/*
** equality for short strings, which are always internalized
*/

static unsigned int luaS_hash(const char *str, size_t l, unsigned int seed);
static unsigned int luaS_hashlongstr(TString *ts);
static int luaS_eqlngstr(TString *a, TString *b);
static void luaS_resize(lua_State *L, int newsize);
static void luaS_clearcache(global_State *g);
static void luaS_init(lua_State *L);
static void luaS_remove(lua_State *L, TString *ts);
static Udata *luaS_newudata(lua_State *L, size_t s, int nuvalue);
static TString *luaS_newlstr(lua_State *L, const char *str, size_t l);
static TString *luaS_new(lua_State *L, const char *str);
static TString *luaS_createlngstrobj(lua_State *L, size_t l);
/*
** $Id: lundump.h $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/

/*
** $Id: llimits.h $
** Limits, basic types, and some other 'installation-dependent' definitions
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lzio.h $
** Buffered streams
** See Copyright Notice in lua.h
*/

/* data to catch conversion errors */
/* load one chunk; from lundump.c */
static LClosure *luaU_undump(lua_State *L, ZIO *Z, const char *name);

/* dump one chunk; from ldump.c */
static int luaU_dump(lua_State *L, const Proto *f, lua_Writer w, void *data,
                     int strip);
/*
** $Id: lzio.h $
** Buffered streams
** See Copyright Notice in lua.h
*/

typedef struct {
  lua_State *L;
  ZIO *Z;
  const char *name;
} LoadState;

static void __attribute__((noreturn)) error(LoadState *S, const char *why) {
  luaO_pushfstring(S->L, "%s: bad binary format (%s)", S->name, why);
  luaD_throw(S->L, 3);
}

/*
** All high-level loads go through LoadVector; you can change it to
** adapt to the endianness of the input
*/

static void LoadBlock(LoadState *S, void *b, size_t size) {
  if (luaZ_read(S->Z, b, size) != 0)
    error(S, "truncated chunk");
}

static lu_byte LoadByte(LoadState *S) {
  int b =
      (((S->Z)->n--) > 0 ? ((unsigned char)((*(S->Z)->p++))) : luaZ_fill(S->Z));
  if (b == (-1) /* end of stream */)
    error(S, "truncated chunk");
  return ((lu_byte)((b)));
}

static size_t LoadUnsigned(LoadState *S, size_t limit) {
  size_t x = 0;
  int b;
  limit >>= 7;
  do {
    b = LoadByte(S);
    if (x >= limit)
      error(S, "integer overflow");
    x = (x << 7) | (b & 0x7f);
  } while ((b & 0x80) == 0);
  return x;
}

static size_t LoadSize(LoadState *S) { return LoadUnsigned(S, ~(size_t)0); }

static int LoadInt(LoadState *S) {
  return ((int)((LoadUnsigned(S, 0x7fffffff))));
}

static lua_Number LoadNumber(LoadState *S) {
  lua_Number x;
  LoadBlock(S, &x, (1) * sizeof((&x)[0]));
  return x;
}

static lua_Integer LoadInteger(LoadState *S) {
  lua_Integer x;
  LoadBlock(S, &x, (1) * sizeof((&x)[0]));
  return x;
}

/*
** Load a nullable string
*/
static TString *LoadStringN(LoadState *S) {
  size_t size = LoadSize(S);
  if (size == 0)
    return ((void *)0);
  else if (--size <= 40) { /* short string? */
    char buff[40];
    LoadBlock(S, buff, (size) * sizeof((buff)[0]));
    return luaS_newlstr(S->L, buff, size);
  } else { /* long string */
    TString *ts = luaS_createlngstrobj(S->L, size);
    LoadBlock(
        S, (((char *)(((ts)))) + sizeof(TString)),
        (size) *
            sizeof(((((char *)(((ts)))) +
                     sizeof(TString)))[0])); /* load directly in final place */
    return ts;
  }
}

/*
** Load a non-nullable string.
*/
static TString *LoadString(LoadState *S) {
  TString *st = LoadStringN(S);
  if (st == ((void *)0))
    error(S, "bad format for constant string");
  return st;
}

static void LoadCode(LoadState *S, Proto *f) {
  int n = LoadInt(S);
  f->code =
      (((sizeof(n) >= sizeof(size_t) &&
         ((size_t)(((n)))) + 1 > ((size_t)(~(size_t)0)) / (sizeof(Instruction)))
            ? luaM_toobig(S->L)
            : ((void)((0)))),
       ((Instruction *)(luaM_malloc_(S->L, (n) * sizeof(Instruction), 0))));
  f->sizecode = n;
  LoadBlock(S, f->code, (n) * sizeof((f->code)[0]));
}

static void LoadFunction(LoadState *S, Proto *f, TString *psource);

static void LoadConstants(LoadState *S, Proto *f) {
  int i;
  int n = LoadInt(S);
  f->k = (((sizeof(n) >= sizeof(size_t) &&
            ((size_t)(((n)))) + 1 > ((size_t)(~(size_t)0)) / (sizeof(TValue)))
               ? luaM_toobig(S->L)
               : ((void)((0)))),
          ((TValue *)(luaM_malloc_(S->L, (n) * sizeof(TValue), 0))));
  f->sizek = n;
  for (i = 0; i < n; i++)
    ((&f->k[i])->tt_ = (0));
  for (i = 0; i < n; i++) {
    TValue *o = &f->k[i];
    int t = LoadByte(S);
    switch (t) {
    case 0:
      ((o)->tt_ = (0));
      break;
    case 1: {
      TValue *io = (o);
      ((io)->value_).b = (LoadByte(S));
      ((io)->tt_ = (1));
    }; break;
    case (3 | (1 << 4)) /* float numbers */: {
      TValue *io = (o);
      ((io)->value_).n = (LoadNumber(S));
      ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
    }; break;
    case (3 | (2 << 4)) /* integer numbers */: {
      TValue *io = (o);
      ((io)->value_).i = (LoadInteger(S));
      ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
    }; break;
    case (4 | (1 << 4)) /* short strings */:
    case (4 | (2 << 4)) /* long strings */: {
      TValue *io = (o);
      TString *x_ = (LoadString(S));
      ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
      ((io)->tt_ = (((x_->tt) | (1 << 6))));
      ((void)0);
    }; break;
    default:
      ((void)0);
    }
  }
}

static void LoadProtos(LoadState *S, Proto *f) {
  int i;
  int n = LoadInt(S);
  f->p = (((sizeof(n) >= sizeof(size_t) &&
            ((size_t)(((n)))) + 1 > ((size_t)(~(size_t)0)) / (sizeof(Proto *)))
               ? luaM_toobig(S->L)
               : ((void)((0)))),
          ((Proto **)(luaM_malloc_(S->L, (n) * sizeof(Proto *), 0))));
  f->sizep = n;
  for (i = 0; i < n; i++)
    f->p[i] = ((void *)0);
  for (i = 0; i < n; i++) {
    f->p[i] = luaF_newproto(S->L);
    LoadFunction(S, f->p[i], f->source);
  }
}

static void LoadUpvalues(LoadState *S, Proto *f) {
  int i, n;
  n = LoadInt(S);
  f->upvalues =
      (((sizeof(n) >= sizeof(size_t) &&
         ((size_t)(((n)))) + 1 > ((size_t)(~(size_t)0)) / (sizeof(Upvaldesc)))
            ? luaM_toobig(S->L)
            : ((void)((0)))),
       ((Upvaldesc *)(luaM_malloc_(S->L, (n) * sizeof(Upvaldesc), 0))));
  f->sizeupvalues = n;
  for (i = 0; i < n; i++)
    f->upvalues[i].name = ((void *)0);
  for (i = 0; i < n; i++) {
    f->upvalues[i].instack = LoadByte(S);
    f->upvalues[i].idx = LoadByte(S);
  }
}

static void LoadDebug(LoadState *S, Proto *f) {
  int i, n;
  n = LoadInt(S);
  f->lineinfo =
      (((sizeof(n) >= sizeof(size_t) &&
         ((size_t)(((n)))) + 1 > ((size_t)(~(size_t)0)) / (sizeof(ls_byte)))
            ? luaM_toobig(S->L)
            : ((void)((0)))),
       ((ls_byte *)(luaM_malloc_(S->L, (n) * sizeof(ls_byte), 0))));
  f->sizelineinfo = n;
  LoadBlock(S, f->lineinfo, (n) * sizeof((f->lineinfo)[0]));
  n = LoadInt(S);
  f->abslineinfo =
      (((sizeof(n) >= sizeof(size_t) &&
         ((size_t)(((n)))) + 1 > ((size_t)(~(size_t)0)) / (sizeof(AbsLineInfo)))
            ? luaM_toobig(S->L)
            : ((void)((0)))),
       ((AbsLineInfo *)(luaM_malloc_(S->L, (n) * sizeof(AbsLineInfo), 0))));
  f->sizeabslineinfo = n;
  for (i = 0; i < n; i++) {
    f->abslineinfo[i].pc = LoadInt(S);
    f->abslineinfo[i].line = LoadInt(S);
  }
  n = LoadInt(S);
  f->locvars =
      (((sizeof(n) >= sizeof(size_t) &&
         ((size_t)(((n)))) + 1 > ((size_t)(~(size_t)0)) / (sizeof(LocVar)))
            ? luaM_toobig(S->L)
            : ((void)((0)))),
       ((LocVar *)(luaM_malloc_(S->L, (n) * sizeof(LocVar), 0))));
  f->sizelocvars = n;
  for (i = 0; i < n; i++)
    f->locvars[i].varname = ((void *)0);
  for (i = 0; i < n; i++) {
    f->locvars[i].varname = LoadStringN(S);
    f->locvars[i].startpc = LoadInt(S);
    f->locvars[i].endpc = LoadInt(S);
  }
  n = LoadInt(S);
  for (i = 0; i < n; i++)
    f->upvalues[i].name = LoadStringN(S);
}

static void LoadFunction(LoadState *S, Proto *f, TString *psource) {
  f->source = LoadStringN(S);
  if (f->source == ((void *)0)) /* no source in dump? */
    f->source = psource;        /* reuse parent's source */
  f->linedefined = LoadInt(S);
  f->lastlinedefined = LoadInt(S);
  f->numparams = LoadByte(S);
  f->is_vararg = LoadByte(S);
  f->maxstacksize = LoadByte(S);
  LoadCode(S, f);
  LoadConstants(S, f);
  LoadUpvalues(S, f);
  LoadProtos(S, f);
  LoadDebug(S, f);
}

static void checkliteral(LoadState *S, const char *s, const char *msg) {
  char buff[sizeof("\x1bLua") +
            sizeof("\x19\x93\r\n\x1a\n")]; /* larger than both */
  size_t len = strlen(s);
  LoadBlock(S, buff, (len) * sizeof((buff)[0]));
  if (memcmp(s, buff, len) != 0)
    error(S, msg);
}

static void fchecksize(LoadState *S, size_t size, const char *tname) {
  if (LoadByte(S) != size)
    error(S, luaO_pushfstring(S->L, "%s size mismatch", tname));
}

static void checkHeader(LoadState *S) {
  /* 1st char already checked */
  checkliteral(S, "\x1bLua" + 1, "not a binary chunk");
  if (LoadInt(S) != 504)
    error(S, "version mismatch");
  if (LoadByte(S) != 0 /* this is the official format */)
    error(S, "format mismatch");
  checkliteral(S, "\x19\x93\r\n\x1a\n", "corrupted chunk");
  fchecksize(S, sizeof(Instruction), "Instruction");
  fchecksize(S, sizeof(lua_Integer), "lua_Integer");
  fchecksize(S, sizeof(lua_Number), "lua_Number");
  if (LoadInteger(S) != 0x5678)
    error(S, "integer format mismatch");
  if (LoadNumber(S) != ((lua_Number)((370.5))))
    error(S, "float format mismatch");
}

/*
** load precompiled chunk
*/
LClosure *luaU_undump(lua_State *L, ZIO *Z, const char *name) {
  LoadState S;
  LClosure *cl;
  if (*name == '@' || *name == '=')
    S.name = name + 1;
  else if (*name == "\x1bLua"[0])
    S.name = "binary string";
  else
    S.name = name;
  S.L = L;
  S.Z = Z;
  checkHeader(&S);
  cl = luaF_newLclosure(L, LoadByte(&S));
  {
    TValue *io = ((&(L->top)->val));
    LClosure *x_ = (cl);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = ((((6 | (1 << 4)) /* Lua closure */) | (1 << 6))));
    ((void)0);
  };
  luaD_inctop(L);
  cl->p = luaF_newproto(L);
  LoadFunction(&S, cl->p, ((void *)0));
  ((void)0);
  /* empty */;
  return cl;
}
/*
** $Id: ldump.c $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lundump.h $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/

typedef struct {
  lua_State *L;
  lua_Writer writer;
  void *data;
  int strip;
  int status;
} DumpState;

/*
** All high-level dumps go through DumpVector; you can change it to
** change the endianness of the result
*/

static void DumpBlock(const void *b, size_t size, DumpState *D) {
  if (D->status == 0 && size > 0) {
    ((void)0);
    D->status = (*D->writer)(D->L, b, size, D->data);
    ((void)0);
  }
}

static void DumpByte(int y, DumpState *D) {
  lu_byte x = (lu_byte)y;
  DumpBlock(&x, (1) * sizeof((&x)[0]), D);
}

/* DumpInt Buff Size */

static void DumpSize(size_t x, DumpState *D) {
  lu_byte buff[((sizeof(size_t) * 8 / 7) + 1)];
  int n = 0;
  do {
    buff[((sizeof(size_t) * 8 / 7) + 1) - (++n)] =
        x & 0x7f; /* fill buffer in reverse order */
    x >>= 7;
  } while (x != 0);
  buff[((sizeof(size_t) * 8 / 7) + 1) - 1] |= 0x80; /* mark last byte */
  DumpBlock(buff + ((sizeof(size_t) * 8 / 7) + 1) - n,
            (n) * sizeof((buff + ((sizeof(size_t) * 8 / 7) + 1) - n)[0]), D);
}

static void DumpInt(int x, DumpState *D) { DumpSize(x, D); }

static void DumpNumber(lua_Number x, DumpState *D) {
  DumpBlock(&x, (1) * sizeof((&x)[0]), D);
}

static void DumpInteger(lua_Integer x, DumpState *D) {
  DumpBlock(&x, (1) * sizeof((&x)[0]), D);
}

static void DumpString(const TString *s, DumpState *D) {
  if (s == ((void *)0))
    DumpSize(0, D);
  else {
    size_t size =
        ((s)->tt == (4 | (1 << 4)) /* short strings */ ? (s)->shrlen
                                                       : (s)->u.lnglen);
    const char *str = (((char *)(((s)))) + sizeof(TString));
    DumpSize(size + 1, D);
    DumpBlock(str, (size) * sizeof((str)[0]), D);
  }
}

static void DumpCode(const Proto *f, DumpState *D) {
  DumpInt(f->sizecode, D);
  DumpBlock(f->code, (f->sizecode) * sizeof((f->code)[0]), D);
}

static void DumpFunction(const Proto *f, TString *psource, DumpState *D);

static void DumpConstants(const Proto *f, DumpState *D) {
  int i;
  int n = f->sizek;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    const TValue *o = &f->k[i];
    DumpByte(((((o)->tt_)) & 0x3F), D);
    switch (((((o)->tt_)) & 0x3F)) {
    case 0:
      break;
    case 1:
      DumpByte((((o)->value_).b), D);
      break;
    case (3 | (1 << 4)) /* float numbers */:
      DumpNumber((((o)->value_).n), D);
      break;
    case (3 | (2 << 4)) /* integer numbers */:
      DumpInteger((((o)->value_).i), D);
      break;
    case (4 | (1 << 4)) /* short strings */:
    case (4 | (2 << 4)) /* long strings */:
      DumpString(((&((((union GCUnion *)((((o)->value_).gc))))->ts))), D);
      break;
    default:
      ((void)0);
    }
  }
}

static void DumpProtos(const Proto *f, DumpState *D) {
  int i;
  int n = f->sizep;
  DumpInt(n, D);
  for (i = 0; i < n; i++)
    DumpFunction(f->p[i], f->source, D);
}

static void DumpUpvalues(const Proto *f, DumpState *D) {
  int i, n = f->sizeupvalues;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    DumpByte(f->upvalues[i].instack, D);
    DumpByte(f->upvalues[i].idx, D);
  }
}

static void DumpDebug(const Proto *f, DumpState *D) {
  int i, n;
  n = (D->strip) ? 0 : f->sizelineinfo;
  DumpInt(n, D);
  DumpBlock(f->lineinfo, (n) * sizeof((f->lineinfo)[0]), D);
  n = (D->strip) ? 0 : f->sizeabslineinfo;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    DumpInt(f->abslineinfo[i].pc, D);
    DumpInt(f->abslineinfo[i].line, D);
  }
  n = (D->strip) ? 0 : f->sizelocvars;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    DumpString(f->locvars[i].varname, D);
    DumpInt(f->locvars[i].startpc, D);
    DumpInt(f->locvars[i].endpc, D);
  }
  n = (D->strip) ? 0 : f->sizeupvalues;
  DumpInt(n, D);
  for (i = 0; i < n; i++)
    DumpString(f->upvalues[i].name, D);
}

static void DumpFunction(const Proto *f, TString *psource, DumpState *D) {
  if (D->strip || f->source == psource)
    DumpString(((void *)0), D); /* no debug info or same source as its parent */
  else
    DumpString(f->source, D);
  DumpInt(f->linedefined, D);
  DumpInt(f->lastlinedefined, D);
  DumpByte(f->numparams, D);
  DumpByte(f->is_vararg, D);
  DumpByte(f->maxstacksize, D);
  DumpCode(f, D);
  DumpConstants(f, D);
  DumpUpvalues(f, D);
  DumpProtos(f, D);
  DumpDebug(f, D);
}

static void DumpHeader(DumpState *D) {
  DumpBlock("\x1bLua", sizeof("\x1bLua") - sizeof(char), D);
  DumpInt(504, D);
  DumpByte(0 /* this is the official format */, D);
  DumpBlock("\x19\x93\r\n\x1a\n", sizeof("\x19\x93\r\n\x1a\n") - sizeof(char),
            D);
  DumpByte(sizeof(Instruction), D);
  DumpByte(sizeof(lua_Integer), D);
  DumpByte(sizeof(lua_Number), D);
  DumpInteger(0x5678, D);
  DumpNumber(((lua_Number)((370.5))), D);
}

/*
** dump Lua function as precompiled chunk
*/
int luaU_dump(lua_State *L, const Proto *f, lua_Writer w, void *data,
              int strip) {
  DumpState D;
  D.L = L;
  D.writer = w;
  D.data = data;
  D.strip = strip;
  D.status = 0;
  DumpHeader(&D);
  DumpByte(f->sizeupvalues, &D);
  DumpFunction(f, ((void *)0), &D);
  return D.status;
}
/*
** $Id: lstate.c $
** Global State
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lapi.h $
** Auxiliary functions from Lua API
** See Copyright Notice in lua.h
*/

/*
** $Id: llimits.h $
** Limits, basic types, and some other 'installation-dependent' definitions
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** To reduce the overhead of returning from C functions, the presence of
** to-be-closed variables in these functions is coded in the CallInfo's
** field 'nresults', in a way that functions with no to-be-closed variables
** with zero, one, or "all" wanted results have no overhead. Functions
** with other number of wanted results, as well as functions with
** variables to be closed, have an extra check.
*/
/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lfunc.h $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/
/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/
/*
** $Id: llex.h $
** Lexical Analyzer
** See Copyright Notice in lua.h
*/

/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lzio.h $
** Buffered streams
** See Copyright Notice in lua.h
*/
/*
 * WARNING: if you change the order of this enumeration,
 * grep "ORDER RESERVED"
 */
enum RESERVED {
  /* terminal symbols denoted by reserved words */
  TK_AND = 257,
  TK_BREAK,
  TK_DO,
  TK_ELSE,
  TK_ELSEIF,
  TK_END,
  TK_FALSE,
  TK_FOR,
  TK_FUNCTION,
  TK_GOTO,
  TK_IF,
  TK_IN,
  TK_LOCAL,
  TK_NIL,
  TK_NOT,
  TK_OR,
  TK_REPEAT,
  TK_RETURN,
  TK_THEN,
  TK_TRUE,
  TK_UNTIL,
  TK_WHILE,
  /* other terminal symbols */
  TK_IDIV,
  TK_CONCAT,
  TK_DOTS,
  TK_EQ,
  TK_GE,
  TK_LE,
  TK_NE,
  TK_SHL,
  TK_SHR,
  TK_DBCOLON,
  TK_EOS,
  TK_FLT,
  TK_INT,
  TK_NAME,
  TK_STRING
};

/* number of reserved words */

typedef union {
  lua_Number r;
  lua_Integer i;
  TString *ts;
} SemInfo; /* semantics information */

typedef struct Token {
  int token;
  SemInfo seminfo;
} Token;

/* state of the lexer plus state of the parser when shared by all
   functions */
typedef struct LexState {
  int current;          /* current character (charint) */
  int linenumber;       /* input line counter */
  int lastline;         /* line of last token 'consumed' */
  Token t;              /* current token */
  Token lookahead;      /* look ahead token */
  struct FuncState *fs; /* current function (parser) */
  struct lua_State *L;
  ZIO *z;              /* input stream */
  Mbuffer *buff;       /* buffer for tokens */
  Table *h;            /* to avoid collection/reuse strings */
  struct Dyndata *dyd; /* dynamic structures used by the parser */
  TString *source;     /* current source name */
  TString *envn;       /* environment variable name */
} LexState;

static void luaX_init(lua_State *L);
static void luaX_setinput(lua_State *L, LexState *ls, ZIO *z, TString *source,
                          int firstchar);
static TString *luaX_newstring(LexState *ls, const char *str, size_t l);
static void luaX_next(LexState *ls);
static int luaX_lookahead(LexState *ls);
static void __attribute__((noreturn))
luaX_syntaxerror(LexState *ls, const char *s);
static const char *luaX_token2str(LexState *ls, int token);
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltable.h $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/

/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/* true when 't' is using 'dummynode' as its hash part */

/* allocated size for hash nodes */

/* returns the Node, given the value of a table entry */

static const TValue *luaH_getint(Table *t, lua_Integer key);
static void luaH_setint(lua_State *L, Table *t, lua_Integer key, TValue *value);
static const TValue *luaH_getshortstr(Table *t, TString *key);
static const TValue *luaH_getstr(Table *t, TString *key);
static const TValue *luaH_get(Table *t, const TValue *key);
static TValue *luaH_newkey(lua_State *L, Table *t, const TValue *key);
static TValue *luaH_set(lua_State *L, Table *t, const TValue *key);
static Table *luaH_new(lua_State *L);
static void luaH_resize(lua_State *L, Table *t, unsigned int nasize,
                        unsigned int nhsize);
static void luaH_resizearray(lua_State *L, Table *t, unsigned int nasize);
static void luaH_free(lua_State *L, Table *t);
static int luaH_next(lua_State *L, Table *t, StkId key);
static lua_Unsigned luaH_getn(Table *t);
static unsigned int luaH_realasize(const Table *t);
/*
** $Id: ltm.h $
** Tag methods
** See Copyright Notice in lua.h
*/

/*
** thread state + extra space
*/
typedef struct LX {
  lu_byte extra_[(sizeof(void *))];
  lua_State l;
} LX;

/*
** Main thread combines a thread state and the global state
*/
typedef struct LG {
  LX l;
  global_State g;
} LG;

/*
** A macro to create a "random" seed when a state is created;
** the seed is used to randomize string hashes.
*/

/*
 * time.h
 *
 * Struct and function declarations for dealing with time.
 */

/*
** Compute an initial seed with some level of randomness.
** Rely on Address Space Layout Randomization (if present) and
** current time.
*/

static unsigned int luai_makeseed(lua_State *L) {
  char buff[3 * sizeof(size_t)];
  unsigned int h = ((unsigned int)((time(((void *)0)))));
  int p = 0;
  {
    size_t t = ((size_t)((L)));
    memcpy(buff + p, &t, sizeof(t));
    p += sizeof(t);
  }; /* heap variable */
  {
    size_t t = ((size_t)((&h)));
    memcpy(buff + p, &t, sizeof(t));
    p += sizeof(t);
  }; /* local variable */
  {
    size_t t = ((size_t)((&lua_newstate)));
    memcpy(buff + p, &t, sizeof(t));
    p += sizeof(t);
  }; /* public function */
  ((void)0);
  return luaS_hash(buff, p, h);
}

/*
** set GCdebt to a new value keeping the value (totalbytes + GCdebt)
** invariant (and avoiding underflows in 'totalbytes')
*/
void luaE_setdebt(global_State *g, l_mem debt) {
  l_mem tb = ((lu_mem)((g)->totalbytes + (g)->GCdebt));
  ((void)0);
  if (debt < tb - ((l_mem)(((lu_mem)(~(lu_mem)0)) >> 1)))
    debt = tb - ((l_mem)(((lu_mem)(~(lu_mem)0)) >>
                         1)); /* will make 'totalbytes == MAX_LMEM' */
  g->totalbytes = tb - debt;
  g->GCdebt = debt;
}

/*
** Increment count of "C calls" and check for overflows. In case of
** a stack overflow, check appropriate error ("regular" overflow or
** overflow while handling stack overflow).
** If 'nCcalls' is larger than LUAI_MAXCSTACK but smaller than
** LUAI_MAXCSTACK + CSTACKCF (plus 2 to avoid by-one errors), it means
** it has just entered the "overflow zone", so the function raises an
** overflow error.
** If 'nCcalls' is larger than LUAI_MAXCSTACK + CSTACKCF + 2
** (which means it is already handling an overflow) but smaller than
** 9/8 of LUAI_MAXCSTACK, does not report an error (to allow message
** handling to work).
** Otherwise, report a stack overflow while handling a stack overflow
** (probably caused by a repeating error in the message handling
** function).
*/
void luaE_enterCcall(lua_State *L) {
  int ncalls = ((L)->nCcalls & 0xffff);
  L->nCcalls++;
  if (ncalls >= 2200) {               /* possible overflow? */
    luaE_freeCI(L);                   /* release unused CIs */
    ncalls = ((L)->nCcalls & 0xffff); /* update call count */
    if (ncalls >= 2200) {             /* still overflow? */
      if (ncalls <= 2200 + 10 + 2) {
        /* no error before increments; raise the error now */
        L->nCcalls += (10 + 4); /* avoid raising it again */
        luaG_runerror(L, "C stack overflow");
      } else if (ncalls >= (2200 + (2200 >> 3)))
        luaD_throw(L, 5); /* error while handling stack error */
    }
  }
}

CallInfo *luaE_extendCI(lua_State *L) {
  CallInfo *ci;
  ((void)0);
  luaE_enterCcall(L);
  ci = ((CallInfo *)(luaM_malloc_(L, sizeof(CallInfo), 0)));
  ((void)0);
  L->ci->next = ci;
  ci->previous = L->ci;
  ci->next = ((void *)0);
  ci->u.l.trap = 0;
  L->nci++;
  return ci;
}

/*
** free all CallInfo structures not in use by a thread
*/
void luaE_freeCI(lua_State *L) {
  CallInfo *ci = L->ci;
  CallInfo *next = ci->next;
  ci->next = ((void *)0);
  L->nCcalls -= L->nci; /* subtract removed elements from 'nCcalls' */
  while ((ci = next) != ((void *)0)) {
    next = ci->next;
    luaM_free_(L, (ci), sizeof(*(ci)));
    L->nci--;
  }
  L->nCcalls += L->nci; /* adjust result */
}

/*
** free half of the CallInfo structures not in use by a thread
*/
void luaE_shrinkCI(lua_State *L) {
  CallInfo *ci = L->ci;
  CallInfo *next2;      /* next's next */
  L->nCcalls -= L->nci; /* subtract removed elements from 'nCcalls' */
  /* while there are two nexts */
  while (ci->next != ((void *)0) && (next2 = ci->next->next) != ((void *)0)) {
    luaM_free_(L, (ci->next), sizeof(*(ci->next))); /* free next */
    L->nci--;
    ci->next = next2; /* remove 'next' from the list */
    next2->previous = ci;
    ci = next2; /* keep next's next */
  }
  L->nCcalls += L->nci; /* adjust result */
}

static void stack_init(lua_State *L1, lua_State *L) {
  int i;
  CallInfo *ci;
  /* initialize stack array */
  L1->stack =
      ((StackValue *)(luaM_malloc_(L, ((2 * 20)) * sizeof(StackValue), 0)));
  L1->stacksize = (2 * 20);
  for (i = 0; i < (2 * 20); i++)
    (((&(L1->stack + i)->val))->tt_ = (0)); /* erase new stack */
  L1->top = L1->stack;
  L1->stack_last = L1->stack + L1->stacksize - 5;
  /* initialize first ci */
  ci = &L1->base_ci;
  ci->next = ci->previous = ((void *)0);
  ci->callstatus = (1 << 1) /* call is running a C function */;
  ci->func = L1->top;
  (((&(L1->top)->val))->tt_ = (0)); /* 'function' entry for this 'ci' */
  L1->top++;
  ci->top = L1->top + 20;
  L1->ci = ci;
}

static void freestack(lua_State *L) {
  if (L->stack == ((void *)0))
    return;            /* stack not completely built yet */
  L->ci = &L->base_ci; /* free the entire 'ci' list */
  luaE_freeCI(L);
  ((void)0);
  luaM_free_(L, (L->stack),
             (L->stacksize) * sizeof(*(L->stack))); /* free stack array */
}

/*
** Create registry table and its predefined values
*/
static void init_registry(lua_State *L, global_State *g) {
  TValue temp;
  /* create registry */
  Table *registry = luaH_new(L);
  {
    TValue *io = (&g->l_registry);
    Table *x_ = (registry);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((5) | (1 << 6))));
    ((void)0);
  };
  luaH_resize(L, registry, 2, 0);
  /* registry[LUA_RIDX_MAINTHREAD] = L */
  {
    TValue *io = (&temp);
    lua_State *x_ = (L);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((8) | (1 << 6))));
    ((void)0);
  }; /* temp = L */
  luaH_setint(L, registry, 1, &temp);
  /* registry[LUA_RIDX_GLOBALS] = table of globals */
  {
    TValue *io = (&temp);
    Table *x_ = (luaH_new(L));
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((5) | (1 << 6))));
    ((void)0);
  }; /* temp = new table (global table) */
  luaH_setint(L, registry, 2, &temp);
}

/*
** open parts of the state that may cause memory-allocation errors.
** ('g->nilvalue' being a nil value flags that the state was completely
** build.)
*/
static void f_luaopen(lua_State *L, void *ud) {
  global_State *g = (L->l_G);
  ((void)(ud));
  stack_init(L, L); /* init stack */
  init_registry(L, g);
  luaS_init(L);
  luaT_init(L);
  luaX_init(L);
  g->gcrunning = 1; /* allow gc */
  ((&g->nilvalue)->tt_ = (0));
  ((void)L);
}

/*
** preinitialize a thread with consistent values without allocating
** any memory (to avoid errors)
*/
static void preinit_thread(lua_State *L, global_State *g) {
  (L->l_G) = g;
  L->stack = ((void *)0);
  L->ci = ((void *)0);
  L->nci = 0;
  L->stacksize = 0;
  L->twups = L; /* thread has no upvalues */
  L->errorJmp = ((void *)0);
  L->nCcalls = 0;
  L->hook = ((void *)0);
  L->hookmask = 0;
  L->basehookcount = 0;
  L->allowhook = 1;
  (L->hookcount = L->basehookcount);
  L->openupval = ((void *)0);
  L->status = 0;
  L->errfunc = 0;
}

static void close_state(lua_State *L) {
  global_State *g = (L->l_G);
  luaF_close(L, L->stack, (-2)); /* close all upvalues */
  luaC_freeallobjects(L);        /* collect all objects */
  if ((((((((&g->nilvalue))->tt_)) & 0x0F)) ==
       (0))) /* closing a fully built state? */
    ((void)L);
  luaM_free_(L, ((L->l_G)->strt.hash),
             ((L->l_G)->strt.size) * sizeof(*((L->l_G)->strt.hash)));
  freestack(L);
  ((void)0);
  (*g->frealloc)(g->ud,
                 (((LX *)(((lu_byte *)((L))) - __builtin_offsetof(LX, l)))),
                 sizeof(LG), 0); /* free main block */
}

extern lua_State *lua_newthread(lua_State *L) {
  global_State *g = (L->l_G);
  lua_State *L1;
  ((void)0);
  {
    if ((L->l_G)->GCdebt > 0) {
      (void)0;
      luaC_step(L);
      (void)0;
    };
    ((void)0);
  };
  /* create new thread */
  L1 = &((LX *)(luaM_malloc_(L, (sizeof(LX)), 8)))->l;
  L1->marked = ((lu_byte)(
      ((g)->currentwhite & ((1 << (3 /* object is white (type 0) */)) |
                            (1 << (4 /* object is white (type 1) */))))));
  L1->tt = 8;
  /* link it on list 'allgc' */
  L1->next = g->allgc;
  g->allgc = (&(((union GCUnion *)((L1)))->gc));
  /* anchor it on L stack */
  {
    TValue *io = ((&(L->top)->val));
    lua_State *x_ = (L1);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((8) | (1 << 6))));
    ((void)0);
  };
  {
    L->top++;
    ((void)0);
  };
  preinit_thread(L1, g);
  L1->hookmask = L->hookmask;
  L1->basehookcount = L->basehookcount;
  L1->hook = L->hook;
  (L1->hookcount = L1->basehookcount);
  /* initialize L1 extra space */
  memcpy(((void *)((char *)(L1) - (sizeof(void *)))),
         ((void *)((char *)(g->mainthread) - (sizeof(void *)))),
         (sizeof(void *)));
  ((void)L);
  stack_init(L1, L); /* init stack */
  ((void)0);
  return L1;
}

void luaE_freethread(lua_State *L, lua_State *L1) {
  LX *l = (((LX *)(((lu_byte *)((L1))) - __builtin_offsetof(LX, l))));
  luaF_close(L1, L1->stack, (-1)); /* close all upvalues */
  ((void)0);
  ((void)L);
  freestack(L1);
  luaM_free_(L, (l), sizeof(*(l)));
}

int lua_resetthread(lua_State *L) {
  CallInfo *ci;
  int status;
  ((void)0);
  ci = &L->base_ci;
  status = luaF_close(L, L->stack, (-2));
  (((&(L->stack)->val))->tt_ = (0)); /* 'function' entry for basic 'ci' */
  if (status != (-2))                /* real errors? */
    luaD_seterrorobj(L, status, L->stack + 1);
  else {
    status = 0;
    L->top = L->stack + 1;
  }
  ci->callstatus = (1 << 1) /* call is running a C function */;
  ci->func = L->stack;
  ci->top = L->top + 20;
  L->ci = ci;
  L->status = status;
  ((void)0);
  return status;
}

extern lua_State *lua_newstate(lua_Alloc f, void *ud) {
  int i;
  lua_State *L;
  global_State *g;
  LG *l = ((LG *)((*f)(ud, ((void *)0), 8, sizeof(LG))));
  if (l == ((void *)0))
    return ((void *)0);
  L = &l->l.l;
  g = &l->g;
  L->tt = 8;
  g->currentwhite = (1 << (3 /* object is white (type 0) */));
  L->marked = ((lu_byte)(
      ((g)->currentwhite & ((1 << (3 /* object is white (type 0) */)) |
                            (1 << (4 /* object is white (type 1) */))))));
  preinit_thread(L, g);
  g->allgc = (&(((union GCUnion *)((L)))
                    ->gc)); /* by now, only object is the main thread */
  L->next = ((void *)0);
  g->frealloc = f;
  g->ud = ud;
  g->warnf = ((void *)0);
  g->ud_warn = ((void *)0);
  g->mainthread = L;
  g->seed = luai_makeseed(L);
  g->gcrunning = 0; /* no GC while building state */
  g->strt.size = g->strt.nuse = 0;
  g->strt.hash = ((void *)0);
  ((&g->l_registry)->tt_ = (0));
  g->panic = ((void *)0);
  g->gcstate = 8;
  g->gckind = 0 /* incremental gc */;
  g->gcemergency = 0;
  g->finobj = g->tobefnz = g->fixedgc = ((void *)0);
  g->survival = g->old = g->reallyold = ((void *)0);
  g->finobjsur = g->finobjold = g->finobjrold = ((void *)0);
  g->sweepgc = ((void *)0);
  g->gray = g->grayagain = ((void *)0);
  g->weak = g->ephemeron = g->allweak = ((void *)0);
  g->twups = ((void *)0);
  g->totalbytes = sizeof(LG);
  g->GCdebt = 0;
  g->lastatomic = 0;
  {
    TValue *io = (&g->nilvalue);
    ((io)->value_).i = (0);
    ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
  }; /* to signal that state is not yet built */
  ((g->gcpause) = (200) / 4);
  ((g->gcstepmul) = (100) / 4);
  g->gcstepsize = 13 /* 8 KB */;
  ((g->genmajormul) = (100) / 4);
  g->genminormul = 20;
  for (i = 0; i < 9; i++)
    g->mt[i] = ((void *)0);
  if (luaD_rawrunprotected(L, f_luaopen, ((void *)0)) != 0) {
    /* memory allocation error: free partial state */
    close_state(L);
    L = ((void *)0);
  }
  return L;
}

extern void lua_close(lua_State *L) {
  L = (L->l_G)->mainthread; /* only the main thread can be closed */
  ((void)0);
  close_state(L);
}

void luaE_warning(lua_State *L, const char *msg, int tocont) {
  lua_WarnFunction wf = (L->l_G)->warnf;
  if (wf != ((void *)0))
    wf((L->l_G)->ud_warn, msg, tocont);
}
/*
** $Id: lgc.c $
** Garbage Collector
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lfunc.h $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/
/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltable.h $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltm.h $
** Tag methods
** See Copyright Notice in lua.h
*/

/*
** Maximum number of elements to sweep in each single step.
** (Large enough to dissipate fixed overheads but small enough
** to allow small steps for the collector.)
*/

/*
** Maximum number of finalizers to call in each single step.
*/

/*
** Cost of calling one finalizer.
*/

/*
** The equivalent, in bytes, of one unit of "work" (visiting a slot,
** sweeping an object, etc.)
*/

/*
** macro to adjust 'pause': 'pause' is actually used like
** 'pause / PAUSEADJ' (value chosen by tests)
*/

/* mask to erase all color bits (plus gen. related stuff) */

/* macro to erase all color bits then sets only the current white bit */
/*
** Protected access to objects in values
*/
/*
** mark an object that can be NULL (either because it is really optional,
** or it was stripped as debug info, or inside an uncompleted structure)
*/

static void reallymarkobject(global_State *g, GCObject *o);
static lu_mem atomic(lua_State *L);
static void entersweep(lua_State *L);

/*
** {======================================================
** Generic functions
** =======================================================
*/

/*
** one after last element in a hash array
*/

static GCObject **getgclist(GCObject *o) {
  switch (o->tt) {
  case 5:
    return &(&((((union GCUnion *)((o))))->h))->gclist;
  case (6 | (1 << 4)) /* Lua closure */:
    return &(&((((union GCUnion *)((o))))->cl.l))->gclist;
  case (6 | (3 << 4)) /* C closure */:
    return &(&((((union GCUnion *)((o))))->cl.c))->gclist;
  case 8:
    return &(&((((union GCUnion *)((o))))->th))->gclist;
  case (9 + 1) /* function prototypes */:
    return &(&((((union GCUnion *)((o))))->p))->gclist;
  case 7: {
    Udata *u = (&((((union GCUnion *)((o))))->u));
    ((void)0);
    return &u->gclist;
  }
  default:
    ((void)0);
    return 0;
  }
}

/*
** Link a collectable object 'o' with a known type into list pointed by 'p'.
*/

/*
** Link a generic collectable object 'o' into list pointed by 'p'.
*/

/*
** Clear keys for empty entries in tables. If entry is empty
** and its key is not marked, mark its entry as dead. This allows the
** collection of the key, but keeps its entry in the table (its removal
** could break a chain). The main feature of a dead key is that it must
** be different from any other value, to do not disturb searches.
** Other places never manipulate dead keys, because its associated empty
** value is enough to signal that the entry is logically empty.
*/
static void clearkey(Node *n) {
  ((void)0);
  if (((((n)->u.key_tt) & (1 << 6)) &&
       ((((((n)->u.key_val).gc))->marked) &
        (((1 << (3 /* object is white (type 0) */)) |
          (1 << (4 /* object is white (type 1) */)))))))
    (((n)->u.key_tt) = 5,
     (((n)->u.key_val).gc) =
         ((void *)0)); /* unused and unmarked key; remove it */
}

/*
** tells whether a key or value can be cleared from a weak
** table. Non-collectable objects are never removed from weak
** tables. Strings behave as 'values', so are never removed too. for
** other objects: if really collected, cannot keep them; for objects
** being finalized, keep them in keys, but not in values
*/
static int iscleared(global_State *g, const GCObject *o) {
  if (o == ((void *)0))
    return 0; /* non-collectable value */
  else if (((o->tt) & 0x0F) == 4) {
    {
      if ((((o)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                             (1 << (4 /* object is white (type 1) */))))))
        reallymarkobject(g, (&(((union GCUnion *)((o)))->gc)));
    }; /* strings are 'values', so are never weak */
    return 0;
  } else
    return (((o)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                              (1 << (4 /* object is white (type 1) */)))));
}

/*
** barrier that moves collector forward, that is, mark the white object
** 'v' being pointed by the black object 'o'. (If in sweep phase, clear
** the black object to white [sweep it] to avoid other barrier calls for
** this same object.) In the generational mode, 'v' must also become
** old, if 'o' is old; however, it cannot be changed directly to OLD,
** because it may still point to non-old objects. So, it is marked as
** OLD0. In the next cycle it will become OLD1, and in the next it
** will finally become OLD (regular old).
*/
void luaC_barrier_(lua_State *L, GCObject *o, GCObject *v) {
  global_State *g = (L->l_G);
  ((void)0);
  if (((g)->gcstate <= 2)) { /* must keep invariant? */
    reallymarkobject(g, v);  /* restore invariant */
    if ((((o)->marked & 7 /* all age bits (111) */) >
         1 /* created in previous cycle */)) {
      ((void)0); /* white object could not be old */
      ((v)->marked = ((lu_byte)((
           ((v)->marked & (~7 /* all age bits (111) */)) |
           2 /* marked old by frw. barrier in this cycle */)))); /* restore
                                                                    generational
                                                                    invariant */
    }
  } else { /* sweep phase */
    ((void)0);
    (o->marked = ((lu_byte)(
         ((o->marked & (~((1 << (5 /* object is black */)) |
                          ((1 << (3 /* object is white (type 0) */)) |
                           (1 << (4 /* object is white (type 1) */))) |
                          7 /* all age bits (111) */))) |
          ((lu_byte)((
              (g)->currentwhite &
              ((1 << (3 /* object is white (type 0) */)) |
               (1 << (4 /* object is white (type 1) */)))))))))); /* mark main
                                                                     obj. as
                                                                     white to
                                                                     avoid other
                                                                     barriers */
  }
}

/*
** barrier that moves collector backward, that is, mark the black object
** pointing to a white object as gray again.
*/
void luaC_barrierback_(lua_State *L, GCObject *o) {
  global_State *g = (L->l_G);
  ((void)0);
  ((void)0);
  if (((o)->marked & 7 /* all age bits (111) */) !=
      6 /* old object touched in previous cycle */) /* not already in gray list?
                                                     */
    (*getgclist(o) = (g->grayagain),
     (g->grayagain) =
         (&(((union GCUnion *)((o)))->gc))); /* link it in 'grayagain' */
  ((o->marked) &= ((lu_byte)(
       (~((1 << (5 /* object is black */))))))); /* make object gray (again) */
  ((o)->marked = ((lu_byte)((
       ((o)->marked & (~7 /* all age bits (111) */)) |
       5 /* old object touched this cycle */)))); /* touched in current cycle */
}

void luaC_fix(lua_State *L, GCObject *o) {
  global_State *g = (L->l_G);
  ((void)0); /* object must be 1st in 'allgc' list! */
  ((o->marked) &= ((lu_byte)(
       (~(((1 << (3 /* object is white (type 0) */)) |
           (1 << (4 /* object is white (type 1) */)))))))); /* they will be gray
                                                               forever */
  ((o)->marked = ((lu_byte)(
       (((o)->marked & (~7 /* all age bits (111) */)) |
        4 /* really old object (not to be visited) */)))); /* and old forever */
  g->allgc = o->next;   /* remove object from 'allgc' list */
  o->next = g->fixedgc; /* link it to 'fixedgc' list */
  g->fixedgc = o;
}

/*
** create a new collectable object (with given type and size) and link
** it to 'allgc' list.
*/
GCObject *luaC_newobj(lua_State *L, int tt, size_t sz) {
  global_State *g = (L->l_G);
  GCObject *o = ((GCObject *)(luaM_malloc_(L, (sz), ((tt)&0x0F))));
  o->marked = ((lu_byte)(
      ((g)->currentwhite & ((1 << (3 /* object is white (type 0) */)) |
                            (1 << (4 /* object is white (type 1) */))))));
  o->tt = tt;
  o->next = g->allgc;
  g->allgc = o;
  return o;
}

/* }====================================================== */

/*
** {======================================================
** Mark functions
** =======================================================
*/

/*
** Mark an object. Userdata, strings, and closed upvalues are visited
** and turned black here. Other objects are marked gray and added
** to appropriate list to be visited (and turned black) later. (Open
** upvalues are already linked in 'headuv' list. They are kept gray
** to avoid barriers, as their values will be revisited by the thread.)
*/
static void reallymarkobject(global_State *g, GCObject *o) {
  ((o->marked) &=
   ((lu_byte)((~(((1 << (3 /* object is white (type 0) */)) |
                  (1 << (4 /* object is white (type 1) */))))))));
  switch (o->tt) {
  case (4 | (1 << 4)) /* short strings */:
  case (4 | (2 << 4)) /* long strings */: {
    (((o)->marked) |= ((1 << (5 /* object is black */))));
    break;
  }
  case 9 /* upvalues */:
  case (9 /* upvalues */ | (1 << 4)): {
    UpVal *uv = (&((((union GCUnion *)((o))))->upv));
    if (!((uv)->v != &(uv)->u.value)) /* open upvalues are kept gray */
      (((o)->marked) |= ((1 << (5 /* object is black */))));
    {
      ((void)0);
      if (((((uv->v)->tt_) & (1 << 6)) &&
           ((((((uv->v)->value_).gc))->marked) &
            (((1 << (3 /* object is white (type 0) */)) |
              (1 << (4 /* object is white (type 1) */)))))))
        reallymarkobject(g, (((uv->v)->value_).gc));
    }; /* mark its content */
    break;
  }
  case 7: {
    Udata *u = (&((((union GCUnion *)((o))))->u));
    if (u->nuvalue == 0) { /* no user values? */
      {
        if (u->metatable) {
          if ((((u->metatable)->marked) &
               (((1 << (3 /* object is white (type 0) */)) |
                 (1 << (4 /* object is white (type 1) */))))))
            reallymarkobject(g, (&(((union GCUnion *)((u->metatable)))->gc)));
        };
      }; /* mark its metatable */
      (((o)->marked) |=
       ((1 << (5 /* object is black */)))); /* nothing else to mark */
      break;
    }
    /* else... */
  } /* FALLTHROUGH */
  case (6 | (1 << 4)) /* Lua closure */:
  case (6 | (3 << 4)) /* C closure */:
  case 5:
  case 8:
  case (9 + 1) /* function prototypes */: {
    (*getgclist(o) = (g->gray), (g->gray) = (&(((union GCUnion *)((o)))->gc)));
    break;
  }
  default:
    ((void)0);
    break;
  }
}

/*
** mark metamethods for basic types
*/
static void markmt(global_State *g) {
  int i;
  for (i = 0; i < 9; i++) {
    if (g->mt[i]) {
      if ((((g->mt[i])->marked) &
           (((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */))))))
        reallymarkobject(g, (&(((union GCUnion *)((g->mt[i])))->gc)));
    };
  };
}

/*
** mark all objects in list of being-finalized
*/
static lu_mem markbeingfnz(global_State *g) {
  GCObject *o;
  lu_mem count = 0;
  for (o = g->tobefnz; o != ((void *)0); o = o->next) {
    count++;
    {
      if ((((o)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                             (1 << (4 /* object is white (type 1) */))))))
        reallymarkobject(g, (&(((union GCUnion *)((o)))->gc)));
    };
  }
  return count;
}

/*
** Mark all values stored in marked open upvalues from non-marked threads.
** (Values from marked threads were already marked when traversing the
** thread.) Remove from the list threads that no longer have upvalues and
** not-marked threads.
*/
static int remarkupvals(global_State *g) {
  lua_State *thread;
  lua_State **p = &g->twups;
  int work = 0;
  while ((thread = *p) != ((void *)0)) {
    work++;
    ((void)0); /* threads are never black */
    if (/* neither white nor black */ (!(
            ((thread)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                                   (1 << (4 /* object is white (type 1) */))) |
                                  (1 << (5 /* object is black */))))) &&
        thread->openupval != ((void *)0))
      p = &thread->twups; /* keep marked thread with upvalues in the list */
    else {                /* thread is not marked or without upvalues */
      UpVal *uv;
      *p = thread->twups;     /* remove thread from the list */
      thread->twups = thread; /* mark that it is out of list */
      for (uv = thread->openupval; uv != ((void *)0); uv = uv->u.open.next) {
        work++;
        if (!(((uv)->marked) &
              (((1 << (3 /* object is white (type 0) */)) |
                (1 << (4 /* object is white (type 1) */)))))) /* upvalue already
                                                                 visited? */
        {
          ((void)0);
          if (((((uv->v)->tt_) & (1 << 6)) &&
               ((((((uv->v)->value_).gc))->marked) &
                (((1 << (3 /* object is white (type 0) */)) |
                  (1 << (4 /* object is white (type 1) */)))))))
            reallymarkobject(g, (((uv->v)->value_).gc));
        }; /* mark its value */
      }
    }
  }
  return work;
}

/*
** mark root set and reset all gray lists, to start a new collection
*/
static void restartcollection(global_State *g) {
  g->gray = g->grayagain = ((void *)0);
  g->weak = g->allweak = g->ephemeron = ((void *)0);
  {
    if ((((g->mainthread)->marked) &
         (((1 << (3 /* object is white (type 0) */)) |
           (1 << (4 /* object is white (type 1) */))))))
      reallymarkobject(g, (&(((union GCUnion *)((g->mainthread)))->gc)));
  };
  {
    ((void)0);
    if (((((&g->l_registry)->tt_) & (1 << 6)) &&
         ((((((&g->l_registry)->value_).gc))->marked) &
          (((1 << (3 /* object is white (type 0) */)) |
            (1 << (4 /* object is white (type 1) */)))))))
      reallymarkobject(g, (((&g->l_registry)->value_).gc));
  };
  markmt(g);
  markbeingfnz(g); /* mark any finalizing object left from previous cycle */
}

/* }====================================================== */

/*
** {======================================================
** Traverse functions
** =======================================================
*/

/*
** Traverse a table with weak values and link it to proper list. During
** propagate phase, keep it in 'grayagain' list, to be revisited in the
** atomic phase. In the atomic phase, if table has any white value,
** put it in 'weak' list, to be cleared.
*/
static void traverseweakvalue(global_State *g, Table *h) {
  Node *n, *limit = (&(h)->node[((size_t)((((1 << ((h)->lsizenode))))))]);
  /* if there is array part, assume it may have white values (it is not
     worth traversing it now just to check) */
  int hasclears = (h->alimit > 0);
  for (n = (&(h)->node[0]); n < limit; n++) {           /* traverse hash part */
    if (((((((((&(n)->i_val)))->tt_)) & 0x0F)) == (0))) /* entry is empty? */
      clearkey(n);                                      /* clear its key */
    else {
      ((void)0);
      {
        if ((((n)->u.key_tt) & (1 << 6)) &&
            ((((((n)->u.key_val).gc))->marked) &
             (((1 << (3 /* object is white (type 0) */)) |
               (1 << (4 /* object is white (type 1) */))))))
          reallymarkobject(g, (((n)->u.key_val).gc));
      };
      if (!hasclears && iscleared(g, (((((&(n)->i_val))->tt_) & (1 << 6))
                                          ? ((((&(n)->i_val))->value_).gc)
                                          : ((void *)0)))) /* a white value? */
        hasclears = 1; /* table will have to be cleared */
    }
  }
  if (g->gcstate == 2 && hasclears)
    ((h)->gclist = (g->weak),
     (g->weak) =
         (&(((union GCUnion *)((h)))->gc))); /* has to be cleared later */
  else
    ((h)->gclist = (g->grayagain),
     (g->grayagain) = (&(((union GCUnion *)((h)))
                             ->gc))); /* must retraverse it in atomic phase */
}

/*
** Traverse an ephemeron table and link it to proper list. Returns true
** iff any object was marked during this traversal (which implies that
** convergence has to continue). During propagation phase, keep table
** in 'grayagain' list, to be visited again in the atomic phase. In
** the atomic phase, if table has any white->white entry, it has to
** be revisited during ephemeron convergence (as that key may turn
** black). Otherwise, if it has any white key, table has to be cleared
** (in the atomic phase). In generational mode, it (like all visited
** tables) must be kept in some gray list for post-processing.
*/
static int traverseephemeron(global_State *g, Table *h) {
  int marked = 0;    /* true if an object is marked in this traversal */
  int hasclears = 0; /* true if table has white keys */
  int hasww = 0;     /* true if table has entry "white-key -> white-value" */
  Node *n, *limit = (&(h)->node[((size_t)((((1 << ((h)->lsizenode))))))]);
  unsigned int i;
  unsigned int asize = luaH_realasize(h);
  /* traverse array part */
  for (i = 0; i < asize; i++) {
    if (((((&h->array[i])->tt_) & (1 << 6)) &&
         ((((((&h->array[i])->value_).gc))->marked) &
          (((1 << (3 /* object is white (type 0) */)) |
            (1 << (4 /* object is white (type 1) */))))))) {
      marked = 1;
      reallymarkobject(g, (((&h->array[i])->value_).gc));
    }
  }
  /* traverse hash part */
  for (n = (&(h)->node[0]); n < limit; n++) {
    if (((((((((&(n)->i_val)))->tt_)) & 0x0F)) == (0))) /* entry is empty? */
      clearkey(n);                                      /* clear its key */
    else if (iscleared(g, ((((n)->u.key_tt) & (1 << 6))
                               ? (((n)->u.key_val).gc)
                               : ((void *)0)))) { /* key is not marked (yet)? */
      hasclears = 1;                              /* table must be cleared */
      if ((((((&(n)->i_val))->tt_) & (1 << 6)) &&
           (((((((&(n)->i_val))->value_).gc))->marked) &
            (((1 << (3 /* object is white (type 0) */)) |
              (1 << (4 /* object is white (type 1) */))))))) /* value not marked
                                                                yet? */
        hasww = 1; /* white-white entry */
    } else if ((((((&(n)->i_val))->tt_) & (1 << 6)) &&
                (((((((&(n)->i_val))->value_).gc))->marked) &
                 (((1 << (3 /* object is white (type 0) */)) |
                   (1 << (4 /* object is white (type 1) */))))))) { /* value not
                                                                       marked
                                                                       yet? */
      marked = 1;
      reallymarkobject(g, ((((&(n)->i_val))->value_).gc)); /* mark it now */
    }
  }
  /* link table into proper list */
  if (g->gcstate == 0)
    ((h)->gclist = (g->grayagain),
     (g->grayagain) = (&(((union GCUnion *)((h)))
                             ->gc))); /* must retraverse it in atomic phase */
  else if (hasww)                     /* table has white->white entries? */
    ((h)->gclist = (g->ephemeron),
     (g->ephemeron) =
         (&(((union GCUnion *)((h)))->gc))); /* have to propagate again */
  else if (hasclears)                        /* table has white keys? */
    ((h)->gclist = (g->allweak),
     (g->allweak) =
         (&(((union GCUnion *)((h)))->gc))); /* may have to clean white keys */
  else if (g->gckind == 1 /* generational gc */)
    ((h)->gclist = (g->grayagain),
     (g->grayagain) =
         (&(((union GCUnion *)((h)))->gc))); /* keep it in some list */
  else
    (((h)->marked) |= ((1 << (5 /* object is black */))));
  return marked;
}

static void traversestrongtable(global_State *g, Table *h) {
  Node *n, *limit = (&(h)->node[((size_t)((((1 << ((h)->lsizenode))))))]);
  unsigned int i;
  unsigned int asize = luaH_realasize(h);
  for (i = 0; i < asize; i++) /* traverse array part */
  {
    ((void)0);
    if (((((&h->array[i])->tt_) & (1 << 6)) &&
         ((((((&h->array[i])->value_).gc))->marked) &
          (((1 << (3 /* object is white (type 0) */)) |
            (1 << (4 /* object is white (type 1) */)))))))
      reallymarkobject(g, (((&h->array[i])->value_).gc));
  };
  for (n = (&(h)->node[0]); n < limit; n++) {           /* traverse hash part */
    if (((((((((&(n)->i_val)))->tt_)) & 0x0F)) == (0))) /* entry is empty? */
      clearkey(n);                                      /* clear its key */
    else {
      ((void)0);
      {
        if ((((n)->u.key_tt) & (1 << 6)) &&
            ((((((n)->u.key_val).gc))->marked) &
             (((1 << (3 /* object is white (type 0) */)) |
               (1 << (4 /* object is white (type 1) */))))))
          reallymarkobject(g, (((n)->u.key_val).gc));
      };
      {
        ((void)0);
        if ((((((&(n)->i_val))->tt_) & (1 << 6)) &&
             (((((((&(n)->i_val))->value_).gc))->marked) &
              (((1 << (3 /* object is white (type 0) */)) |
                (1 << (4 /* object is white (type 1) */)))))))
          reallymarkobject(g, ((((&(n)->i_val))->value_).gc));
      };
    }
  }
  if (g->gckind == 1 /* generational gc */) {
    ((h)->gclist = (g->grayagain),
     (g->grayagain) =
         (&(((union GCUnion *)((h)))->gc))); /* keep it in some gray list */
    ((h->marked) &= ((lu_byte)((~((1 << (5 /* object is black */)))))));
  }
}

static lu_mem traversetable(global_State *g, Table *h) {
  const char *weakkey, *weakvalue;
  const TValue *mode =
      ((h->metatable) == ((void *)0)
           ? ((void *)0)
           : ((h->metatable)->flags & (1u << (TM_MODE)))
                 ? ((void *)0)
                 : luaT_gettm(h->metatable, TM_MODE, (g)->tmname[TM_MODE]));
  {
    if (h->metatable) {
      if ((((h->metatable)->marked) &
           (((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */))))))
        reallymarkobject(g, (&(((union GCUnion *)((h->metatable)))->gc)));
    };
  };
  if (mode &&
      (((((((mode))->tt_)) & 0x0F)) == (4)) && /* is there a weak mode? */
      ((weakkey = strchr(
            (((char *)((
                 (((&((((union GCUnion *)((((mode)->value_).gc))))->ts))))))) +
             sizeof(TString)),
            'k')),
       (weakvalue = strchr(
            (((char *)((
                 (((&((((union GCUnion *)((((mode)->value_).gc))))->ts))))))) +
             sizeof(TString)),
            'v')),
       (weakkey || weakvalue))) { /* is really weak? */
    ((h->marked) &=
     ((lu_byte)((~((1 << (5 /* object is black */))))))); /* keep table gray */
    if (!weakkey)                                         /* strong keys? */
      traverseweakvalue(g, h);
    else if (!weakvalue) /* strong values? */
      traverseephemeron(g, h);
    else /* all weak */
      ((h)->gclist = (g->allweak),
       (g->allweak) =
           (&(((union GCUnion *)((h)))->gc))); /* nothing to traverse now */
  } else                                       /* not weak */
    traversestrongtable(g, h);
  return 1 + h->alimit +
         2 * (((h)->lastfree == ((void *)0)) ? 0 : ((1 << ((h)->lsizenode))));
}

static int traverseudata(global_State *g, Udata *u) {
  int i;
  {
    if (u->metatable) {
      if ((((u->metatable)->marked) &
           (((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */))))))
        reallymarkobject(g, (&(((union GCUnion *)((u->metatable)))->gc)));
    };
  }; /* mark its metatable */
  for (i = 0; i < u->nuvalue; i++) {
    ((void)0);
    if (((((&u->uv[i].uv)->tt_) & (1 << 6)) &&
         ((((((&u->uv[i].uv)->value_).gc))->marked) &
          (((1 << (3 /* object is white (type 0) */)) |
            (1 << (4 /* object is white (type 1) */)))))))
      reallymarkobject(g, (((&u->uv[i].uv)->value_).gc));
  };
  if (g->gckind == 1 /* generational gc */) {
    ((u)->gclist = (g->grayagain),
     (g->grayagain) =
         (&(((union GCUnion *)((u)))->gc))); /* keep it in some gray list */
    ((u->marked) &= ((lu_byte)((~((1 << (5 /* object is black */)))))));
  }
  return 1 + u->nuvalue;
}

/*
** Traverse a prototype. (While a prototype is being build, its
** arrays can be larger than needed; the extra slots are filled with
** NULL, so the use of 'markobjectN')
*/
static int traverseproto(global_State *g, Proto *f) {
  int i;
  {
    if (f->source) {
      if ((((f->source)->marked) &
           (((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */))))))
        reallymarkobject(g, (&(((union GCUnion *)((f->source)))->gc)));
    };
  };
  for (i = 0; i < f->sizek; i++) /* mark literals */
  {
    ((void)0);
    if (((((&f->k[i])->tt_) & (1 << 6)) &&
         ((((((&f->k[i])->value_).gc))->marked) &
          (((1 << (3 /* object is white (type 0) */)) |
            (1 << (4 /* object is white (type 1) */)))))))
      reallymarkobject(g, (((&f->k[i])->value_).gc));
  };
  for (i = 0; i < f->sizeupvalues; i++) /* mark upvalue names */
  {
    if (f->upvalues[i].name) {
      if ((((f->upvalues[i].name)->marked) &
           (((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */))))))
        reallymarkobject(g,
                         (&(((union GCUnion *)((f->upvalues[i].name)))->gc)));
    };
  };
  for (i = 0; i < f->sizep; i++) /* mark nested protos */
  {
    if (f->p[i]) {
      if ((((f->p[i])->marked) & (((1 << (3 /* object is white (type 0) */)) |
                                   (1 << (4 /* object is white (type 1) */))))))
        reallymarkobject(g, (&(((union GCUnion *)((f->p[i])))->gc)));
    };
  };
  for (i = 0; i < f->sizelocvars; i++) /* mark local-variable names */
  {
    if (f->locvars[i].varname) {
      if ((((f->locvars[i].varname)->marked) &
           (((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */))))))
        reallymarkobject(g,
                         (&(((union GCUnion *)((f->locvars[i].varname)))->gc)));
    };
  };
  return 1 + f->sizek + f->sizeupvalues + f->sizep + f->sizelocvars;
}

static int traverseCclosure(global_State *g, CClosure *cl) {
  int i;
  for (i = 0; i < cl->nupvalues; i++) /* mark its upvalues */
  {
    ((void)0);
    if (((((&cl->upvalue[i])->tt_) & (1 << 6)) &&
         ((((((&cl->upvalue[i])->value_).gc))->marked) &
          (((1 << (3 /* object is white (type 0) */)) |
            (1 << (4 /* object is white (type 1) */)))))))
      reallymarkobject(g, (((&cl->upvalue[i])->value_).gc));
  };
  return 1 + cl->nupvalues;
}

/*
** Traverse a Lua closure, marking its prototype and its upvalues.
** (Both can be NULL while closure is being created.)
*/
static int traverseLclosure(global_State *g, LClosure *cl) {
  int i;
  {
    if (cl->p) {
      if ((((cl->p)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                                 (1 << (4 /* object is white (type 1) */))))))
        reallymarkobject(g, (&(((union GCUnion *)((cl->p)))->gc)));
    };
  };                                    /* mark its prototype */
  for (i = 0; i < cl->nupvalues; i++) { /* visit its upvalues */
    UpVal *uv = cl->upvals[i];
    {
      if (uv) {
        if ((((uv)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                                (1 << (4 /* object is white (type 1) */))))))
          reallymarkobject(g, (&(((union GCUnion *)((uv)))->gc)));
      };
    }; /* mark upvalue */
  }
  return 1 + cl->nupvalues;
}

/*
** Traverse a thread, marking the elements in the stack up to its top
** and cleaning the rest of the stack in the final traversal.
** That ensures that the entire stack have valid (non-dead) objects.
*/
static int traversethread(global_State *g, lua_State *th) {
  UpVal *uv;
  StkId o = th->stack;
  if (o == ((void *)0))
    return 1; /* stack not completely built yet */
  ((void)0);
  for (; o < th->top; o++) /* mark live elements in the stack */
  {
    ((void)0);
    if ((((((&(o)->val))->tt_) & (1 << 6)) &&
         (((((((&(o)->val))->value_).gc))->marked) &
          (((1 << (3 /* object is white (type 0) */)) |
            (1 << (4 /* object is white (type 1) */)))))))
      reallymarkobject(g, ((((&(o)->val))->value_).gc));
  };
  for (uv = th->openupval; uv != ((void *)0); uv = uv->u.open.next) {
    if (uv->tt == (9 /* upvalues */ | (1 << 4))) /* to be closed? */
    {
      if ((((uv)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                              (1 << (4 /* object is white (type 1) */))))))
        reallymarkobject(g, (&(((union GCUnion *)((uv)))->gc)));
    }; /* cannot be collected */
  }
  if (g->gcstate == 2) {                   /* final traversal? */
    StkId lim = th->stack + th->stacksize; /* real end of stack */
    for (; o < lim; o++)                   /* clear not-marked stack slice */
      (((&(o)->val))->tt_ = (0));
    /* 'remarkupvals' may have removed thread from 'twups' list */
    if (!(th->twups != th) && th->openupval != ((void *)0)) {
      th->twups = g->twups; /* link it back to the list */
      g->twups = th;
    }
  } else if (!g->gcemergency)
    luaD_shrinkstack(th); /* do not change stack in emergency cycle */
  return 1 + th->stacksize;
}

/*
** traverse one gray object, turning it to black (except for threads,
** which are always gray).
*/
static lu_mem propagatemark(global_State *g) {
  GCObject *o = g->gray;
  (((o)->marked) |= ((1 << (5 /* object is black */))));
  g->gray = *getgclist(o); /* remove from 'gray' list */
  switch (o->tt) {
  case 5:
    return traversetable(g, (&((((union GCUnion *)((o))))->h)));
  case 7:
    return traverseudata(g, (&((((union GCUnion *)((o))))->u)));
  case (6 | (1 << 4)) /* Lua closure */:
    return traverseLclosure(g, (&((((union GCUnion *)((o))))->cl.l)));
  case (6 | (3 << 4)) /* C closure */:
    return traverseCclosure(g, (&((((union GCUnion *)((o))))->cl.c)));
  case (9 + 1) /* function prototypes */:
    return traverseproto(g, (&((((union GCUnion *)((o))))->p)));
  case 8: {
    lua_State *th = (&((((union GCUnion *)((o))))->th));
    ((th)->gclist = (g->grayagain),
     (g->grayagain) =
         (&(((union GCUnion *)((th)))->gc))); /* insert into 'grayagain' list */
    ((o->marked) &= ((lu_byte)((~((1 << (5 /* object is black */)))))));
    return traversethread(g, th);
  }
  default:
    ((void)0);
    return 0;
  }
}

static lu_mem propagateall(global_State *g) {
  lu_mem tot = 0;
  while (g->gray)
    tot += propagatemark(g);
  return tot;
}

static void convergeephemerons(global_State *g) {
  int changed;
  do {
    GCObject *w;
    GCObject *next = g->ephemeron; /* get ephemeron list */
    g->ephemeron =
        ((void *)0); /* tables may return to this list when traversed */
    changed = 0;
    while ((w = next) != ((void *)0)) {
      next = (&((((union GCUnion *)((w))))->h))->gclist;
      if (traverseephemeron(g,
                            (&((((union GCUnion *)((w))))
                                   ->h)))) { /* traverse marked some value? */
        propagateall(g);                     /* propagate changes */
        changed = 1; /* will have to revisit all ephemeron tables */
      }
    }
  } while (changed);
}

/* }====================================================== */

/*
** {======================================================
** Sweep Functions
** =======================================================
*/

/*
** clear entries with unmarked keys from all weaktables in list 'l'
*/
static void clearbykeys(global_State *g, GCObject *l) {
  for (; l; l = (&((((union GCUnion *)((l))))->h))->gclist) {
    Table *h = (&((((union GCUnion *)((l))))->h));
    Node *limit = (&(h)->node[((size_t)((((1 << ((h)->lsizenode))))))]);
    Node *n;
    for (n = (&(h)->node[0]); n < limit; n++) {
      if (iscleared(g, ((((n)->u.key_tt) & (1 << 6))
                            ? (((n)->u.key_val).gc)
                            : ((void *)0))))              /* unmarked key? */
        (((&(n)->i_val))->tt_ = ((0 | (1 << 4))));        /* remove entry */
      if (((((((((&(n)->i_val)))->tt_)) & 0x0F)) == (0))) /* is entry empty? */
        clearkey(n);                                      /* clear its key */
    }
  }
}

/*
** clear entries with unmarked values from all weaktables in list 'l' up
** to element 'f'
*/
static void clearbyvalues(global_State *g, GCObject *l, GCObject *f) {
  for (; l != f; l = (&((((union GCUnion *)((l))))->h))->gclist) {
    Table *h = (&((((union GCUnion *)((l))))->h));
    Node *n, *limit = (&(h)->node[((size_t)((((1 << ((h)->lsizenode))))))]);
    unsigned int i;
    unsigned int asize = luaH_realasize(h);
    for (i = 0; i < asize; i++) {
      TValue *o = &h->array[i];
      if (iscleared(g, ((((o)->tt_) & (1 << 6))
                            ? (((o)->value_).gc)
                            : ((void *)0)))) /* value was collected? */
        ((o)->tt_ = ((0 | (1 << 4))));       /* remove entry */
    }
    for (n = (&(h)->node[0]); n < limit; n++) {
      if (iscleared(g, (((((&(n)->i_val))->tt_) & (1 << 6))
                            ? ((((&(n)->i_val))->value_).gc)
                            : ((void *)0))))              /* unmarked value? */
        (((&(n)->i_val))->tt_ = ((0 | (1 << 4))));        /* remove entry */
      if (((((((((&(n)->i_val)))->tt_)) & 0x0F)) == (0))) /* is entry empty? */
        clearkey(n);                                      /* clear its key */
    }
  }
}

static void freeupval(lua_State *L, UpVal *uv) {
  if (((uv)->v != &(uv)->u.value))
    luaF_unlinkupval(uv);
  luaM_free_(L, (uv), sizeof(*(uv)));
}

static void freeobj(lua_State *L, GCObject *o) {
  switch (o->tt) {
  case (9 + 1) /* function prototypes */:
    luaF_freeproto(L, (&((((union GCUnion *)((o))))->p)));
    break;
  case 9 /* upvalues */:
  case (9 /* upvalues */ | (1 << 4)):
    freeupval(L, (&((((union GCUnion *)((o))))->upv)));
    break;
  case (6 | (1 << 4)) /* Lua closure */:
    luaM_free_(L, (o),
               ((((int)((__builtin_offsetof(LClosure, upvals)))) +
                 ((int)((sizeof(TValue *)))) *
                     ((&((((union GCUnion *)((o))))->cl.l))->nupvalues))));
    break;
  case (6 | (3 << 4)) /* C closure */:
    luaM_free_(L, (o),
               ((((int)((__builtin_offsetof(CClosure, upvalue)))) +
                 ((int)((sizeof(TValue)))) *
                     ((&((((union GCUnion *)((o))))->cl.c))->nupvalues))));
    break;
  case 5:
    luaH_free(L, (&((((union GCUnion *)((o))))->h)));
    break;
  case 8:
    luaE_freethread(L, (&((((union GCUnion *)((o))))->th)));
    break;
  case 7: {
    Udata *u = (&((((union GCUnion *)((o))))->u));
    luaM_free_(L, (o),
               ((((u->nuvalue) == 0 ? __builtin_offsetof(Udata0, bindata)
                                    : __builtin_offsetof(Udata, uv) +
                                          (sizeof(UValue) * (u->nuvalue))) +
                 (u->len))));
    break;
  }
  case (4 | (1 << 4)) /* short strings */:
    luaS_remove(
        L, (&((((union GCUnion *)((o))))->ts))); /* remove it from hash table */
    luaM_free_(
        L, (o),
        ((sizeof(TString) +
          (((&((((union GCUnion *)((o))))->ts))->shrlen) + 1) * sizeof(char))));
    break;
  case (4 | (2 << 4)) /* long strings */:
    luaM_free_(L, (o),
               ((sizeof(TString) +
                 (((&((((union GCUnion *)((o))))->ts))->u.lnglen) + 1) *
                     sizeof(char))));
    break;
  default:
    ((void)0);
  }
}

/*
** sweep at most 'countin' elements from a list of GCObjects erasing dead
** objects, where a dead object is one marked with the old (non current)
** white; change all non-dead objects back to white, preparing for next
** collection cycle. Return where to continue the traversal or NULL if
** list is finished. ('*countout' gets the number of elements traversed.)
*/
static GCObject **sweeplist(lua_State *L, GCObject **p, int countin,
                            int *countout) {
  global_State *g = (L->l_G);
  int ow = ((g)->currentwhite ^ ((1 << (3 /* object is white (type 0) */)) |
                                 (1 << (4 /* object is white (type 1) */))));
  int i;
  int white = ((lu_byte)(
      ((g)->currentwhite &
       ((1 << (3 /* object is white (type 0) */)) |
        (1 << (4 /* object is white (type 1) */)))))); /* current white */
  for (i = 0; *p != ((void *)0) && i < countin; i++) {
    GCObject *curr = *p;
    int marked = curr->marked;
    if (((marked) & (ow))) { /* is 'curr' dead? */
      *p = curr->next;       /* remove 'curr' from list */
      freeobj(L, curr);      /* erase 'curr' */
    } else {                 /* change mark to 'white' */
      curr->marked =
          ((lu_byte)(((marked & (~((1 << (5 /* object is black */)) |
                                   ((1 << (3 /* object is white (type 0) */)) |
                                    (1 << (4 /* object is white (type 1) */))) |
                                   7 /* all age bits (111) */))) |
                      white)));
      p = &curr->next; /* go to next element */
    }
  }
  if (countout)
    *countout = i; /* number of elements traversed */
  return (*p == ((void *)0)) ? ((void *)0) : p;
}

/*
** sweep a list until a live object (or end of list)
*/
static GCObject **sweeptolive(lua_State *L, GCObject **p) {
  GCObject **old = p;
  do {
    p = sweeplist(L, p, 1, ((void *)0));
  } while (p == old);
  return p;
}

/* }====================================================== */

/*
** {======================================================
** Finalization
** =======================================================
*/

/*
** If possible, shrink string table.
*/
static void checkSizes(lua_State *L, global_State *g) {
  if (!g->gcemergency) {
    l_mem olddebt = g->GCdebt;
    if (g->strt.nuse < g->strt.size / 4) /* string table too big? */
      luaS_resize(L, g->strt.size / 2);
    g->GCestimate += g->GCdebt - olddebt; /* correct estimate */
  }
}

/*
** Get the next udata to be finalized from the 'tobefnz' list, and
** link it back into the 'allgc' list.
*/
static GCObject *udata2finalize(global_State *g) {
  GCObject *o = g->tobefnz; /* get first element */
  ((void)0);
  g->tobefnz = o->next; /* remove it from 'tobefnz' list */
  o->next = g->allgc;   /* return it to 'allgc' list */
  g->allgc = o;
  ((o->marked) &= ((lu_byte)((~(
       (1
        << (6 /* object has been marked for finalization */))))))); /* object is
                                                                       "normal"
                                                                       again */
  if ((3 <= (g)->gcstate && (g)->gcstate <= 6))
    (o->marked = ((lu_byte)(
         ((o->marked & (~((1 << (5 /* object is black */)) |
                          ((1 << (3 /* object is white (type 0) */)) |
                           (1 << (4 /* object is white (type 1) */))) |
                          7 /* all age bits (111) */))) |
          ((lu_byte)(
              ((g)->currentwhite &
               ((1 << (3 /* object is white (type 0) */)) |
                (1 << (4 /* object is white (type 1) */)))))))))); /* "sweep"
                                                                      object */
  return o;
}

static void dothecall(lua_State *L, void *ud) {
  ((void)(ud));
  luaD_callnoyield(L, L->top - 2, 0);
}

static void GCTM(lua_State *L) {
  global_State *g = (L->l_G);
  const TValue *tm;
  TValue v;
  ((void)0);
  {
    TValue *io = (&v);
    GCObject *i_g = (udata2finalize(g));
    ((io)->value_).gc = i_g;
    ((io)->tt_ = (((i_g->tt) | (1 << 6))));
  };
  tm = luaT_gettmbyobj(L, &v, TM_GC);
  if (!(((((((tm))->tt_)) & 0x0F)) == (0))) { /* is there a finalizer? */
    int status;
    lu_byte oldah = L->allowhook;
    int running = g->gcrunning;
    L->allowhook = 0; /* stop debug hooks during GC metamethod */
    g->gcrunning = 0; /* avoid GC steps */
    {
      TValue *io1 = ((&(L->top)->val));
      const TValue *io2 = (tm);
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    }; /* push finalizer... */
    {
      TValue *io1 = ((&(L->top + 1)->val));
      const TValue *io2 = (&v);
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };           /* ... and its argument */
    L->top += 2; /* and (next line) call the finalizer */
    L->ci->callstatus |=
        (1 << 6) /* call is running a finalizer */; /* will run a finalizer */
    status = luaD_pcall(L, dothecall, ((void *)0),
                        ((char *)(L->top - 2) - (char *)L->stack), 0);
    L->ci->callstatus &=
        ~(1 << 6) /* call is running a finalizer */; /* not running a finalizer
                                                        anymore */
    L->allowhook = oldah;                            /* restore hooks */
    g->gcrunning = running;                          /* restore state */
    if (status != 0) { /* error while running __gc? */
      const char *msg =
          (((((((((&(L->top - 1)->val)))->tt_)) & 0x0F)) == (4)))
              ? (((char *)(((((&((((union GCUnion *)((
                                      (((&(L->top - 1)->val))->value_).gc))))
                                     ->ts))))))) +
                 sizeof(TString))
              : "error object is not a string";
      luaE_warning(L, "error in __gc metamethod (", 1);
      luaE_warning(L, msg, 1);
      luaE_warning(L, ")", 0);
    }
  }
}

/*
** Call a few finalizers
*/
static int runafewfinalizers(lua_State *L, int n) {
  global_State *g = (L->l_G);
  int i;
  for (i = 0; i < n && g->tobefnz; i++)
    GCTM(L); /* call one finalizer */
  return i;
}

/*
** call all pending finalizers
*/
static void callallpendingfinalizers(lua_State *L) {
  global_State *g = (L->l_G);
  while (g->tobefnz)
    GCTM(L);
}

/*
** find last 'next' field in list 'p' list (to add elements in its end)
*/
static GCObject **findlast(GCObject **p) {
  while (*p != ((void *)0))
    p = &(*p)->next;
  return p;
}

/*
** Move all unreachable objects (or 'all' objects) that need
** finalization from list 'finobj' to list 'tobefnz' (to be finalized).
** (Note that objects after 'finobjold' cannot be white, so they
** don't need to be traversed. In incremental mode, 'finobjold' is NULL,
** so the whole list is traversed.)
*/
static void separatetobefnz(global_State *g, int all) {
  GCObject *curr;
  GCObject **p = &g->finobj;
  GCObject **lastnext = findlast(&g->tobefnz);
  while ((curr = *p) != g->finobjold) { /* traverse all finalizable objects */
    ((void)0);
    if (!((((curr)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                                (1 << (4 /* object is white (type 1) */))))) ||
          all))        /* not being collected? */
      p = &curr->next; /* don't bother with it */
    else {
      if (curr == g->finobjsur)    /* removing 'finobjsur'? */
        g->finobjsur = curr->next; /* correct it */
      *p = curr->next;             /* remove 'curr' from 'finobj' list */
      curr->next = *lastnext;      /* link at the end of 'tobefnz' list */
      *lastnext = curr;
      lastnext = &curr->next;
    }
  }
}

/*
** if object 'o' has a finalizer, remove it from 'allgc' list (must
** search the list to find it) and link it in 'finobj' list.
*/
void luaC_checkfinalizer(lua_State *L, GCObject *o, Table *mt) {
  global_State *g = (L->l_G);
  if ((((o)->marked) &
       ((1 << (6 /* object has been marked for finalization */)))) || /* obj. is
                                                                         already
                                                                         marked...
                                                                       */
      ((mt) == ((void *)0) ? ((void *)0)
                           : ((mt)->flags & (1u << (TM_GC)))
                                 ? ((void *)0)
                                 : luaT_gettm(mt, TM_GC, (g)->tmname[TM_GC])) ==
          ((void *)0)) /* or has no finalizer? */
    return;            /* nothing to be done */
  else {               /* move 'o' to 'finobj' list */
    GCObject **p;
    if ((3 <= (g)->gcstate && (g)->gcstate <= 6)) {
      (o->marked = ((lu_byte)(
           ((o->marked & (~((1 << (5 /* object is black */)) |
                            ((1 << (3 /* object is white (type 0) */)) |
                             (1 << (4 /* object is white (type 1) */))) |
                            7 /* all age bits (111) */))) |
            ((lu_byte)(
                ((g)->currentwhite &
                 ((1 << (3 /* object is white (type 0) */)) |
                  (1 << (4 /* object is white (type 1) */)))))))))); /* "sweep"
                                                                        object
                                                                        'o' */
      if (g->sweepgc == &o->next) /* should not remove 'sweepgc' object */
        g->sweepgc = sweeptolive(L, g->sweepgc); /* change 'sweepgc' */
    } else { /* correct pointers into 'allgc' list, if needed */
      if (o == g->survival)
        g->survival = o->next;
      if (o == g->old)
        g->old = o->next;
      if (o == g->reallyold)
        g->reallyold = o->next;
    }
    /* search for pointer pointing to 'o' */
    for (p = &g->allgc; *p != o; p = &(*p)->next) { /* empty */
    }
    *p = o->next;        /* remove 'o' from 'allgc' list */
    o->next = g->finobj; /* link it in 'finobj' list */
    g->finobj = o;
    ((o->marked) |=
     ((1 << (6 /* object has been marked for finalization */)))); /* mark it as
                                                                     such */
  }
}

/* }====================================================== */

/*
** {======================================================
** Generational Collector
** =======================================================
*/

static void setpause(global_State *g);

/* mask to erase all color bits, not changing gen-related stuff */

/*
** Sweep a list of objects, deleting dead ones and turning
** the non dead to old (without changing their colors).
*/
static void sweep2old(lua_State *L, GCObject **p) {
  GCObject *curr;
  while ((curr = *p) != ((void *)0)) {
    if ((((curr)->marked) &
         (((1 << (3 /* object is white (type 0) */)) |
           (1 << (4 /* object is white (type 1) */)))))) { /* is 'curr' dead? */
      ((void)0);
      *p = curr->next;  /* remove 'curr' from list */
      freeobj(L, curr); /* erase 'curr' */
    } else {            /* all surviving objects become old */
      ((curr)->marked =
           ((lu_byte)((((curr)->marked & (~7 /* all age bits (111) */)) |
                       4 /* really old object (not to be visited) */))));
      p = &curr->next; /* go to next element */
    }
  }
}

/*
** Sweep for generational mode. Delete dead objects. (Because the
** collection is not incremental, there are no "new white" objects
** during the sweep. So, any white object must be dead.) For
** non-dead objects, advance their ages and clear the color of
** new objects. (Old objects keep their colors.)
*/
static GCObject **sweepgen(lua_State *L, global_State *g, GCObject **p,
                           GCObject *limit) {
  static lu_byte nextage[] = {
      1 /* created in previous cycle */,             /* from G_NEW */
      3 /* first full cycle as old */,               /* from G_SURVIVAL */
      3 /* first full cycle as old */,               /* from G_OLD0 */
      4 /* really old object (not to be visited) */, /* from G_OLD1 */
      4 /* really old object (not to be visited) */, /* from G_OLD (do not
                                                        change) */
      5 /* old object touched this cycle */, /* from G_TOUCHED1 (do not change)
                                              */
      6 /* old object touched in previous cycle */ /* from G_TOUCHED2 (do not
                                                      change) */
  };
  int white = ((lu_byte)(
      ((g)->currentwhite & ((1 << (3 /* object is white (type 0) */)) |
                            (1 << (4 /* object is white (type 1) */))))));
  GCObject *curr;
  while ((curr = *p) != limit) {
    if ((((curr)->marked) &
         (((1 << (3 /* object is white (type 0) */)) |
           (1 << (4 /* object is white (type 1) */)))))) { /* is 'curr' dead? */
      ((void)0);
      *p = curr->next;  /* remove 'curr' from list */
      freeobj(L, curr); /* erase 'curr' */
    } else {            /* correct mark and age */
      if (((curr)->marked & 7 /* all age bits (111) */) ==
          0 /* created in current cycle */)
        curr->marked = ((lu_byte)(
            ((curr->marked & (~((1 << (5 /* object is black */)) |
                                ((1 << (3 /* object is white (type 0) */)) |
                                 (1 << (4 /* object is white (type 1) */)))))) |
             white)));
      ((curr)->marked = ((lu_byte)(
           (((curr)->marked & (~7 /* all age bits (111) */)) |
            nextage[((curr)->marked & 7 /* all age bits (111) */)]))));
      p = &curr->next; /* go to next element */
    }
  }
  return p;
}

/*
** Traverse a list making all its elements white and clearing their
** age.
*/
static void whitelist(global_State *g, GCObject *p) {
  int white = ((lu_byte)(
      ((g)->currentwhite & ((1 << (3 /* object is white (type 0) */)) |
                            (1 << (4 /* object is white (type 1) */))))));
  for (; p != ((void *)0); p = p->next)
    p->marked = ((lu_byte)(
        ((p->marked & (~((1 << (5 /* object is black */)) |
                         ((1 << (3 /* object is white (type 0) */)) |
                          (1 << (4 /* object is white (type 1) */))) |
                         7 /* all age bits (111) */))) |
         white)));
}

/*
** Correct a list of gray objects.
** Because this correction is done after sweeping, young objects might
** be turned white and still be in the list. They are only removed.
** For tables and userdata, advance 'touched1' to 'touched2'; 'touched2'
** objects become regular old and are removed from the list.
** For threads, just remove white ones from the list.
*/
static GCObject **correctgraylist(GCObject **p) {
  GCObject *curr;
  while ((curr = *p) != ((void *)0)) {
    switch (curr->tt) {
    case 5:
    case 7: {
      GCObject **next = getgclist(curr);
      if (((curr)->marked & 7 /* all age bits (111) */) ==
          5 /* old object touched this cycle */) { /* touched in this cycle? */
        ((void)0);
        (((curr)->marked) |=
         ((1 << (5 /* object is black */)))); /* make it black, for next barrier
                                               */
        ((curr)->marked ^= ((5 /* old object touched this cycle */) ^
                            (6 /* old object touched in previous cycle */)));
        p = next; /* go to next element */
      } else {    /* not touched in this cycle */
        if (!(((curr)->marked) &
              (((1 << (3 /* object is white (type 0) */)) |
                (1 << (4 /* object is white (type 1) */)))))) { /* not white? */
          ((void)0);
          if (((curr)->marked & 7 /* all age bits (111) */) ==
              6 /* old object touched in previous cycle */) /* advance from
                                                               G_TOUCHED2... */
            ((curr)->marked ^=
             ((6 /* old object touched in previous cycle */) ^
              (4 /* really old object (not to be visited) */))); /* ... to G_OLD
                                                                  */
          (((curr)->marked) |=
           ((1 << (5 /* object is black */)))); /* make it black */
        }
        /* else, object is white: just remove it from this list */
        *p = *next; /* remove 'curr' from gray list */
      }
      break;
    }
    case 8: {
      lua_State *th = (&((((union GCUnion *)((curr))))->th));
      ((void)0);
      if ((((th)->marked) &
           (((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */)))))) /* new object? */
        *p = th->gclist; /* remove from gray list */
      else               /* old threads remain gray */
        p = &th->gclist; /* go to next element */
      break;
    }
    default:
      ((void)0); /* nothing more could be gray here */
    }
  }
  return p;
}

/*
** Correct all gray lists, coalescing them into 'grayagain'.
*/
static void correctgraylists(global_State *g) {
  GCObject **list = correctgraylist(&g->grayagain);
  *list = g->weak;
  g->weak = ((void *)0);
  list = correctgraylist(list);
  *list = g->allweak;
  g->allweak = ((void *)0);
  list = correctgraylist(list);
  *list = g->ephemeron;
  g->ephemeron = ((void *)0);
  correctgraylist(list);
}

/*
** Mark 'OLD1' objects when starting a new young collection.
** Gray objects are already in some gray list, and so will be visited
** in the atomic step.
*/
static void markold(global_State *g, GCObject *from, GCObject *to) {
  GCObject *p;
  for (p = from; p != to; p = p->next) {
    if (((p)->marked & 7 /* all age bits (111) */) ==
        3 /* first full cycle as old */) {
      ((void)0);
      if ((((p)->marked) & ((1 << (5 /* object is black */))))) {
        ((p->marked) &= ((lu_byte)(
             (~((1 << (5 /* object is black */))))))); /* should be '2white',
                                                          but gray works too */
        reallymarkobject(g, p);
      }
    }
  }
}

/*
** Finish a young-generation collection.
*/
static void finishgencycle(lua_State *L, global_State *g) {
  correctgraylists(g);
  checkSizes(L, g);
  g->gcstate = 0; /* skip restart */
  if (!g->gcemergency)
    callallpendingfinalizers(L);
}

/*
** Does a young collection. First, mark 'OLD1' objects.  (Only survival
** and "recent old" lists can contain 'OLD1' objects. New lists cannot
** contain 'OLD1' objects, at most 'OLD0' objects that were already
** visited when marked old.) Then does the atomic step. Then,
** sweep all lists and advance pointers. Finally, finish the collection.
*/
static void youngcollection(lua_State *L, global_State *g) {
  GCObject **psurvival; /* to point to first non-dead survival object */
  ((void)0);
  markold(g, g->survival, g->reallyold);
  markold(g, g->finobj, g->finobjrold);
  atomic(L);

  /* sweep nursery and get a pointer to its last live element */
  psurvival = sweepgen(L, g, &g->allgc, g->survival);
  /* sweep 'survival' and 'old' */
  sweepgen(L, g, psurvival, g->reallyold);
  g->reallyold = g->old;
  g->old = *psurvival;    /* 'survival' survivals are old now */
  g->survival = g->allgc; /* all news are survivals */

  /* repeat for 'finobj' lists */
  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);
  /* sweep 'survival' and 'old' */
  sweepgen(L, g, psurvival, g->finobjrold);
  g->finobjrold = g->finobjold;
  g->finobjold = *psurvival; /* 'survival' survivals are old now */
  g->finobjsur = g->finobj;  /* all news are survivals */

  sweepgen(L, g, &g->tobefnz, ((void *)0));

  finishgencycle(L, g);
}

static void atomic2gen(lua_State *L, global_State *g) {
  /* sweep all elements making them old */
  sweep2old(L, &g->allgc);
  /* everything alive now is old */
  g->reallyold = g->old = g->survival = g->allgc;

  /* repeat for 'finobj' lists */
  sweep2old(L, &g->finobj);
  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;

  sweep2old(L, &g->tobefnz);

  g->gckind = 1 /* generational gc */;
  g->lastatomic = 0;
  g->GCestimate =
      ((lu_mem)((g)->totalbytes + (g)->GCdebt)); /* base for memory control */
  finishgencycle(L, g);
}

/*
** Enter generational mode. Must go until the end of an atomic cycle
** to ensure that all threads and weak tables are in the gray lists.
** Then, turn all objects into old and finishes the collection.
*/
static lu_mem entergen(lua_State *L, global_State *g) {
  lu_mem numobjs;
  luaC_runtilstate(L, (1 << (8))); /* prepare to start a new cycle */
  luaC_runtilstate(L, (1 << (0))); /* start new cycle */
  numobjs = atomic(L); /* propagates all and then do the atomic stuff */
  atomic2gen(L, g);
  return numobjs;
}

/*
** Enter incremental mode. Turn all objects white, make all
** intermediate lists point to NULL (to avoid invalid pointers),
** and go to the pause state.
*/
static void enterinc(global_State *g) {
  whitelist(g, g->allgc);
  g->reallyold = g->old = g->survival = ((void *)0);
  whitelist(g, g->finobj);
  whitelist(g, g->tobefnz);
  g->finobjrold = g->finobjold = g->finobjsur = ((void *)0);
  g->gcstate = 8;
  g->gckind = 0 /* incremental gc */;
  g->lastatomic = 0;
}

/*
** Change collector mode to 'newmode'.
*/
void luaC_changemode(lua_State *L, int newmode) {
  global_State *g = (L->l_G);
  if (newmode != g->gckind) {
    if (newmode == 1 /* generational gc */) /* entering generational mode? */
      entergen(L, g);
    else
      enterinc(g); /* entering incremental mode */
  }
  g->lastatomic = 0;
}

/*
** Does a full collection in generational mode.
*/
static lu_mem fullgen(lua_State *L, global_State *g) {
  enterinc(g);
  return entergen(L, g);
}

/*
** Set debt for the next minor collection, which will happen when
** memory grows 'genminormul'%.
*/
static void setminordebt(global_State *g) {
  luaE_setdebt(g,
               -(((l_mem)((((lu_mem)((g)->totalbytes + (g)->GCdebt)) / 100))) *
                 g->genminormul));
}

/*
** Does a major collection after last collection was a "bad collection".
**
** When the program is building a big struture, it allocates lots of
** memory but generates very little garbage. In those scenarios,
** the generational mode just wastes time doing small collections, and
** major collections are frequently what we call a "bad collection", a
** collection that frees too few objects. To avoid the cost of switching
** between generational mode and the incremental mode needed for full
** (major) collections, the collector tries to stay in incremental mode
** after a bad collection, and to switch back to generational mode only
** after a "good" collection (one that traverses less than 9/8 objects
** of the previous one).
** The collector must choose whether to stay in incremental mode or to
** switch back to generational mode before sweeping. At this point, it
** does not know the real memory in use, so it cannot use memory to
** decide whether to return to generational mode. Instead, it uses the
** number of objects traversed (returned by 'atomic') as a proxy. The
** field 'g->lastatomic' keeps this count from the last collection.
** ('g->lastatomic != 0' also means that the last collection was bad.)
*/
static void stepgenfull(lua_State *L, global_State *g) {
  lu_mem newatomic;                         /* count of traversed objects */
  lu_mem lastatomic = g->lastatomic;        /* count from last collection */
  if (g->gckind == 1 /* generational gc */) /* still in generational mode? */
    enterinc(g);                            /* enter incremental mode */
  luaC_runtilstate(L, (1 << (0)));          /* start new cycle */
  newatomic = atomic(L);                    /* mark everybody */
  if (newatomic < lastatomic + (lastatomic >> 3)) { /* good collection? */
    atomic2gen(L, g); /* return to generational mode */
    setminordebt(g);
  } else { /* another bad collection; stay in incremental mode */
    g->GCestimate =
        ((lu_mem)((g)->totalbytes + (g)->GCdebt)); /* first estimate */
    ;
    entersweep(L);
    luaC_runtilstate(L, (1 << (8))); /* finish collection */
    setpause(g);
    g->lastatomic = newatomic;
  }
}

/*
** Does a generational "step".
** Usually, this means doing a minor collection and setting the debt to
** make another collection when memory grows 'genminormul'% larger.
**
** However, there are exceptions.  If memory grows 'genmajormul'%
** larger than it was at the end of the last major collection (kept
** in 'g->GCestimate'), the function does a major collection. At the
** end, it checks whether the major collection was able to free a
** decent amount of memory (at least half the growth in memory since
** previous major collection). If so, the collector keeps its state,
** and the next collection will probably be minor again. Otherwise,
** we have what we call a "bad collection". In that case, set the field
** 'g->lastatomic' to signal that fact, so that the next collection will
** go to 'stepgenfull'.
**
** 'GCdebt <= 0' means an explicit call to GC step with "size" zero;
** in that case, do a minor collection.
*/
static void genstep(lua_State *L, global_State *g) {
  if (g->lastatomic != 0) /* last collection was a bad one? */
    stepgenfull(L, g);    /* do a full step */
  else {
    lu_mem majorbase = g->GCestimate; /* memory after last major collection */
    lu_mem majorinc = (majorbase / 100) * ((g->genmajormul) * 4);
    if (g->GCdebt > 0 &&
        ((lu_mem)((g)->totalbytes + (g)->GCdebt)) > majorbase + majorinc) {
      lu_mem numobjs = fullgen(L, g); /* do a major collection */
      if (((lu_mem)((g)->totalbytes + (g)->GCdebt)) <
          majorbase + (majorinc / 2)) {
        /* collected at least half of memory growth since last major
           collection; keep doing minor collections */
        setminordebt(g);
      } else {                   /* bad collection */
        g->lastatomic = numobjs; /* signal that last collection was bad */
        setpause(g); /* do a long wait for next (major) collection */
      }
    } else { /* regular case; do a minor collection */
      youngcollection(L, g);
      setminordebt(g);
      g->GCestimate = majorbase; /* preserve base value */
    }
  }
  ((void)0);
}

/* }====================================================== */

/*
** {======================================================
** GC control
** =======================================================
*/

/*
** Set the "time" to wait before starting a new GC cycle; cycle will
** start when memory use hits the threshold of ('estimate' * pause /
** PAUSEADJ). (Division by 'estimate' should be OK: it cannot be zero,
** because Lua cannot even start with less than PAUSEADJ bytes).
*/
static void setpause(global_State *g) {
  l_mem threshold, debt;
  int pause = ((g->gcpause) * 4);
  l_mem estimate = g->GCestimate / 100; /* adjust 'estimate' */
  ((void)0);
  threshold = (pause < ((l_mem)(((lu_mem)(~(lu_mem)0)) >> 1)) /
                           estimate) /* overflow? */
                  ? estimate * pause /* no overflow */
                  : ((l_mem)(((lu_mem)(~(lu_mem)0)) >>
                             1)); /* overflow; truncate to maximum */
  debt = ((lu_mem)((g)->totalbytes + (g)->GCdebt)) - threshold;
  if (debt > 0)
    debt = 0;
  luaE_setdebt(g, debt);
}

/*
** Enter first sweep phase.
** The call to 'sweeptolive' makes the pointer point to an object
** inside the list (instead of to the header), so that the real sweep do
** not need to skip objects created between "now" and the start of the
** real sweep.
*/
static void entersweep(lua_State *L) {
  global_State *g = (L->l_G);
  g->gcstate = 3;
  ((void)0);
  g->sweepgc = sweeptolive(L, &g->allgc);
}

/*
** Delete all objects in list 'p' until (but not including) object
** 'limit'.
*/
static void deletelist(lua_State *L, GCObject *p, GCObject *limit) {
  while (p != limit) {
    GCObject *next = p->next;
    freeobj(L, p);
    p = next;
  }
}

/*
** Call all finalizers of the objects in the given Lua state, and
** then free all objects, except for the main thread.
*/
void luaC_freeallobjects(lua_State *L) {
  global_State *g = (L->l_G);
  luaC_changemode(L, 0 /* incremental gc */);
  separatetobefnz(g, 1); /* separate all objects with finalizers */
  ((void)0);
  callallpendingfinalizers(L);
  deletelist(L, g->allgc, (&(((union GCUnion *)((g->mainthread)))->gc)));
  deletelist(L, g->finobj, ((void *)0));
  deletelist(L, g->fixedgc, ((void *)0)); /* collect fixed objects */
  ((void)0);
}

static lu_mem atomic(lua_State *L) {
  global_State *g = (L->l_G);
  lu_mem work = 0;
  GCObject *origweak, *origall;
  GCObject *grayagain = g->grayagain; /* save original list */
  g->grayagain = ((void *)0);
  ((void)0);
  ((void)0);
  g->gcstate = 2;
  {
    if ((((L)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                           (1 << (4 /* object is white (type 1) */))))))
      reallymarkobject(g, (&(((union GCUnion *)((L)))->gc)));
  }; /* mark running thread */
  /* registry and global metatables may be changed by API */
  {
    ((void)0);
    if (((((&g->l_registry)->tt_) & (1 << 6)) &&
         ((((((&g->l_registry)->value_).gc))->marked) &
          (((1 << (3 /* object is white (type 0) */)) |
            (1 << (4 /* object is white (type 1) */)))))))
      reallymarkobject(g, (((&g->l_registry)->value_).gc));
  };
  markmt(g);               /* mark global metatables */
  work += propagateall(g); /* empties 'gray' list */
  /* remark occasional upvalues of (maybe) dead threads */
  work += remarkupvals(g);
  work += propagateall(g); /* propagate changes */
  g->gray = grayagain;
  work += propagateall(g); /* traverse 'grayagain' list */
  convergeephemerons(g);
  /* at this point, all strongly accessible objects are marked. */
  /* Clear values from weak tables, before checking finalizers */
  clearbyvalues(g, g->weak, ((void *)0));
  clearbyvalues(g, g->allweak, ((void *)0));
  origweak = g->weak;
  origall = g->allweak;
  separatetobefnz(g, 0);   /* separate objects to be finalized */
  work += markbeingfnz(g); /* mark objects that will be finalized */
  work += propagateall(g); /* remark, to propagate 'resurrection' */
  convergeephemerons(g);
  /* at this point, all resurrected objects are marked. */
  /* remove dead objects from weak tables */
  clearbykeys(g, g->ephemeron); /* clear keys from all ephemeron tables */
  clearbykeys(g, g->allweak);   /* clear keys from all 'allweak' tables */
  /* clear values from resurrected weak tables */
  clearbyvalues(g, g->weak, origweak);
  clearbyvalues(g, g->allweak, origall);
  luaS_clearcache(g);
  g->currentwhite = ((lu_byte)((
      ((g)->currentwhite ^
       ((1 << (3 /* object is white (type 0) */)) |
        (1 << (4 /* object is white (type 1) */))))))); /* flip current white */
  ((void)0);
  return work; /* estimate of slots marked by 'atomic' */
}

static int sweepstep(lua_State *L, global_State *g, int nextstate,
                     GCObject **nextlist) {
  if (g->sweepgc) {
    l_mem olddebt = g->GCdebt;
    int count;
    g->sweepgc = sweeplist(L, g->sweepgc, 100, &count);
    g->GCestimate += g->GCdebt - olddebt; /* update estimate */
    return count;
  } else { /* enter next state */
    g->gcstate = nextstate;
    g->sweepgc = nextlist;
    return 0; /* no work done */
  }
}

static lu_mem singlestep(lua_State *L) {
  global_State *g = (L->l_G);
  switch (g->gcstate) {
  case 8: {
    restartcollection(g);
    g->gcstate = 0;
    return 1;
  }
  case 0: {
    if (g->gray == ((void *)0)) { /* no more gray objects? */
      g->gcstate = 1;             /* finish propagate phase */
      return 0;
    } else
      return propagatemark(g); /* traverse one gray object */
  }
  case 1: {
    lu_mem work = atomic(L); /* work is what was traversed by 'atomic' */
    entersweep(L);
    g->GCestimate =
        ((lu_mem)((g)->totalbytes + (g)->GCdebt)); /* first estimate */
    ;
    return work;
  }
  case 3: { /* sweep "regular" objects */
    return sweepstep(L, g, 4, &g->finobj);
  }
  case 4: { /* sweep objects with finalizers */
    return sweepstep(L, g, 5, &g->tobefnz);
  }
  case 5: { /* sweep objects to be finalized */
    return sweepstep(L, g, 6, ((void *)0));
  }
  case 6: { /* finish sweeps */
    checkSizes(L, g);
    g->gcstate = 7;
    return 0;
  }
  case 7: { /* call remaining finalizers */
    if (g->tobefnz && !g->gcemergency) {
      int n = runafewfinalizers(L, 10);
      return n * 50;
    } else {          /* emergency mode or no more finalizers */
      g->gcstate = 8; /* finish collection */
      return 0;
    }
  }
  default:
    ((void)0);
    return 0;
  }
}

/*
** advances the garbage collector until it reaches a state allowed
** by 'statemask'
*/
void luaC_runtilstate(lua_State *L, int statesmask) {
  global_State *g = (L->l_G);
  while (!((statesmask) & ((1 << (g->gcstate)))))
    singlestep(L);
}

/*
** Performs a basic incremental step. The debt and step size are
** converted from bytes to "units of work"; then the function loops
** running single steps until adding that many units of work or
** finishing a cycle (pause state). Finally, it sets the debt that
** controls when next step will be performed.
*/
static void incstep(lua_State *L, global_State *g) {
  int stepmul = (((g->gcstepmul) * 4) | 1); /* avoid division by 0 */
  l_mem debt = (g->GCdebt / sizeof(TValue)) * stepmul;
  l_mem stepsize =
      (g->gcstepsize <= (sizeof(l_mem) * 8 - 2))
          ? ((((l_mem)(1)) << g->gcstepsize) / sizeof(TValue)) * stepmul
          : ((l_mem)(((lu_mem)(~(lu_mem)0)) >>
                     1)); /* overflow; keep maximum value */
  do { /* repeat until pause or enough "credit" (negative debt) */
    lu_mem work = singlestep(L); /* perform one single step */
    debt -= work;
  } while (debt > -stepsize && g->gcstate != 8);
  if (g->gcstate == 8)
    setpause(g); /* pause until next cycle */
  else {
    debt =
        (debt / stepmul) * sizeof(TValue); /* convert 'work units' to bytes */
    luaE_setdebt(g, debt);
  }
}

/*
** performs a basic GC step if collector is running
*/
void luaC_step(lua_State *L) {
  global_State *g = (L->l_G);
  if (g->gcrunning) { /* running? */
    if ((g->gckind == 1 /* generational gc */ || g->lastatomic != 0))
      genstep(L, g);
    else
      incstep(L, g);
  }
}

/*
** Perform a full collection in incremental mode.
** Before running the collection, check 'keepinvariant'; if it is true,
** there may be some objects marked as black, so the collector has
** to sweep all objects to turn them back to white (as white has not
** changed, nothing will be collected).
*/
static void fullinc(lua_State *L, global_State *g) {
  if (((g)->gcstate <= 2)) /* black objects? */
    entersweep(L);         /* sweep everything to turn them back to white */
  /* finish any pending sweep phase to start a new cycle */
  luaC_runtilstate(L, (1 << (8)));
  luaC_runtilstate(L, (1 << (7))); /* run up to finalizers */
  /* estimate must be correct after a full GC cycle */
  ((void)0);
  luaC_runtilstate(L, (1 << (8))); /* finish collection */
  setpause(g);
}

/*
** Performs a full GC cycle; if 'isemergency', set a flag to avoid
** some operations which could change the interpreter state in some
** unexpected ways (running finalizers and shrinking some structures).
*/
void luaC_fullgc(lua_State *L, int isemergency) {
  global_State *g = (L->l_G);
  ((void)0);
  g->gcemergency = isemergency; /* set flag */
  if (g->gckind == 0 /* incremental gc */)
    fullinc(L, g);
  else
    fullgen(L, g);
  g->gcemergency = 0;
}

/* }====================================================== */
/*
** $Id: llex.c $
** Lexical Analyzer
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
        locale.h
        Values appropriate for the formatting of monetary and other
        numberic quantities.
*/
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lctype.h $
** 'ctype' functions for Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/
/*
** $Id: llex.h $
** Lexical Analyzer
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lparser.h $
** Lua Parser
** See Copyright Notice in lua.h
*/

/*
** $Id: llimits.h $
** Limits, basic types, and some other 'installation-dependent' definitions
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lzio.h $
** Buffered streams
** See Copyright Notice in lua.h
*/

/*
** Expression and variable descriptor.
** Code generation for variables and expressions can be delayed to allow
** optimizations; An 'expdesc' structure describes a potentially-delayed
** variable/expression. It has a description of its "main" value plus a
** list of conditional jumps that can also produce its value (generated
** by short-circuit operators 'and'/'or').
*/

/* kinds of variables/expressions */
typedef enum {
  VVOID,     /* when 'expdesc' describes the last expression a list,
                 this kind means an empty list (so, no expression) */
  VNIL,      /* constant nil */
  VTRUE,     /* constant true */
  VFALSE,    /* constant false */
  VK,        /* constant in 'k'; info = index of constant in 'k' */
  VKFLT,     /* floating constant; nval = numerical float value */
  VKINT,     /* integer constant; nval = numerical integer value */
  VNONRELOC, /* expression has its value in a fixed register;
                 info = result register */
  VLOCAL,    /* local variable; info = local register */
  VUPVAL,    /* upvalue variable; info = index of upvalue in 'upvalues' */
  VINDEXED,  /* indexed variable;
                 ind.t = table register;
                 ind.idx = key's R index */
  VINDEXUP,  /* indexed upvalue;
                 ind.t = table upvalue;
                 ind.idx = key's K index */
  VINDEXI,   /* indexed variable with constant integer;
                  ind.t = table register;
                  ind.idx = key's value */
  VINDEXSTR, /* indexed variable with literal string;
                ind.t = table register;
                ind.idx = key's K index */
  VJMP,      /* expression is a test/comparison;
                 info = pc of corresponding jump instruction */
  VRELOC,    /* expression can put result in any register;
                 info = instruction pc */
  VCALL,     /* expression is a function call; info = instruction pc */
  VVARARG    /* vararg expression; info = instruction pc */
} expkind;

typedef struct expdesc {
  expkind k;
  union {
    lua_Integer ival; /* for VKINT */
    lua_Number nval;  /* for VKFLT */
    int info;         /* for generic use */
    struct {          /* for indexed variables */
      short idx;      /* index (R or "long" K) */
      lu_byte t;      /* table (register or upvalue) */
    } ind;
  } u;
  int t; /* patch list of 'exit when true' */
  int f; /* patch list of 'exit when false' */
} expdesc;

/* description of active local variable */
typedef struct Vardesc {
  short idx; /* index of the variable in the Proto's 'locvars' array */
} Vardesc;

/* description of pending goto statements and label statements */
typedef struct Labeldesc {
  TString *name;   /* label identifier */
  int pc;          /* position in code */
  int line;        /* line where it appeared */
  lu_byte nactvar; /* local level where it appears in current block */
  lu_byte close;   /* goto that escapes upvalues */
} Labeldesc;

/* list of labels or gotos */
typedef struct Labellist {
  Labeldesc *arr; /* array */
  int n;          /* number of entries in use */
  int size;       /* array size */
} Labellist;

/* dynamic structures used by the parser */
typedef struct Dyndata {
  struct { /* list of active local variables */
    Vardesc *arr;
    int n;
    int size;
  } actvar;
  Labellist gt;    /* list of pending gotos */
  Labellist label; /* list of active labels */
} Dyndata;

/* control of blocks */
struct BlockCnt; /* defined in lparser.c */

/* state needed to generate code for a given function */
typedef struct FuncState {
  Proto *f;               /* current function header */
  struct FuncState *prev; /* enclosing function */
  struct LexState *ls;    /* lexical state */
  struct BlockCnt *bl;    /* chain of current blocks */
  int pc;                 /* next position to code (equivalent to 'ncode') */
  int lasttarget;         /* 'label' of last 'jump label' */
  int previousline;       /* last line that was saved in 'lineinfo' */
  int nk;                 /* number of elements in 'k' */
  int np;                 /* number of elements in 'p' */
  int nabslineinfo;       /* number of elements in 'abslineinfo' */
  int firstlocal;         /* index of first local var (in Dyndata array) */
  int firstlabel;         /* index of first label (in 'dyd->label->arr') */
  short nlocvars;         /* number of elements in 'f->locvars' */
  lu_byte nactvar;        /* number of active local variables */
  lu_byte nups;           /* number of upvalues */
  lu_byte freereg;        /* first free register */
  lu_byte iwthabs;   /* instructions issued since last absolute line info */
  lu_byte needclose; /* function needs to close upvalues when returning */
} FuncState;

static LClosure *luaY_parser(lua_State *L, ZIO *z, Mbuffer *buff, Dyndata *dyd,
                             const char *name, int firstchar);
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltable.h $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/
/*
** $Id: lzio.h $
** Buffered streams
** See Copyright Notice in lua.h
*/
/* ORDER RESERVED */
static const char *const luaX_tokens[] = {
    "and",    "break",    "do",     "else",   "elseif", "end",      "false",
    "for",    "function", "goto",   "if",     "in",     "local",    "nil",
    "not",    "or",       "repeat", "return", "then",   "true",     "until",
    "while",  "//",       "..",     "...",    "==",     ">=",       "<=",
    "~=",     "<<",       ">>",     "::",     "<eof>",  "<number>", "<integer>",
    "<name>", "<string>"};

static void __attribute__((noreturn))
lexerror(LexState *ls, const char *msg, int token);

static void save(LexState *ls, int c) {
  Mbuffer *b = ls->buff;
  if (((b)->n) + 1 > ((b)->buffsize)) {
    size_t newsize;
    if (((b)->buffsize) >= (sizeof(size_t) < sizeof(lua_Integer)
                                ? ((size_t)(~(size_t)0))
                                : (size_t)(0x7fffffffffffffffLL)) /
                               2)
      lexerror(ls, "lexical element too long", 0);
    newsize = ((b)->buffsize) * 2;
    ((b)->buffer = ((char *)((luaM_saferealloc_(ls->L, ((b)->buffer),
                                                ((b)->buffsize) * sizeof(char),
                                                (newsize) * sizeof(char))))),
     (b)->buffsize = newsize);
  }
  b->buffer[((b)->n)++] = ((char)((c)));
}

void luaX_init(lua_State *L) {
  int i;
  TString *e =
      (luaS_newlstr(L,
                    ""
                    "_ENV",
                    (sizeof("_ENV") / sizeof(char)) - 1)); /* create env name */
  luaC_fix(L, (&(((union GCUnion *)((e)))->gc))); /* never collect this name */
  for (i = 0; i < (((int)((TK_WHILE - 257 + 1)))); i++) {
    TString *ts = luaS_new(L, luaX_tokens[i]);
    luaC_fix(L, (&(((union GCUnion *)((ts)))
                       ->gc)));       /* reserved words are never collected */
    ts->extra = ((lu_byte)((i + 1))); /* reserved word */
  }
}

const char *luaX_token2str(LexState *ls, int token) {
  if (token < 257) { /* single-byte symbols? */
    ((void)0);
    return luaO_pushfstring(ls->L, "'%c'", token);
  } else {
    const char *s = luaX_tokens[token - 257];
    if (token < TK_EOS) /* fixed format (symbols and reserved words)? */
      return luaO_pushfstring(ls->L, "'%s'", s);
    else /* names, strings, and numerals */
      return s;
  }
}

static const char *txtToken(LexState *ls, int token) {
  switch (token) {
  case TK_NAME:
  case TK_STRING:
  case TK_FLT:
  case TK_INT:
    save(ls, '\0');
    return luaO_pushfstring(ls->L, "'%s'", ((ls->buff)->buffer));
  default:
    return luaX_token2str(ls, token);
  }
}

static void __attribute__((noreturn))
lexerror(LexState *ls, const char *msg, int token) {
  msg = luaG_addinfo(ls->L, msg, ls->source, ls->linenumber);
  if (token)
    luaO_pushfstring(ls->L, "%s near %s", msg, txtToken(ls, token));
  luaD_throw(ls->L, 3);
}

void __attribute__((noreturn)) luaX_syntaxerror(LexState *ls, const char *msg) {
  lexerror(ls, msg, ls->t.token);
}

/*
** creates a new string and anchors it in scanner's table so that
** it will not be collected until the end of the compilation
** (by that time it should be anchored somewhere)
*/
TString *luaX_newstring(LexState *ls, const char *str, size_t l) {
  lua_State *L = ls->L;
  TValue *o;                             /* entry for 'str' */
  TString *ts = luaS_newlstr(L, str, l); /* create new string */
  {
    TValue *io = ((&(L->top++)->val));
    TString *x_ = (ts);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((x_->tt) | (1 << 6))));
    ((void)0);
  }; /* temporarily anchor it in stack */
  o = luaH_set(L, ls->h, (&(L->top - 1)->val));
  if ((((((((o))->tt_)) & 0x0F)) == (0))) { /* not in use yet? */
    /* boolean value does not need GC barrier;
       table is not a metatable, so it does not need to invalidate cache */
    {
      TValue *io = (o);
      ((io)->value_).b = (1);
      ((io)->tt_ = (1));
    }; /* t[string] = true */
    {
      if ((L->l_G)->GCdebt > 0) {
        (void)0;
        luaC_step(L);
        (void)0;
      };
      ((void)0);
    };
  } else { /* string already present */
    ts = ((&((((union GCUnion *)((((((Node *)((o))))->u.key_val).gc))))
                 ->ts))); /* re-use value previously stored */
  }
  L->top--; /* remove string from stack */
  return ts;
}

/*
** increment line number and skips newline sequence (any of
** \n, \r, \n\r, or \r\n)
*/
static void inclinenumber(LexState *ls) {
  int old = ls->current;
  ((void)0);
  (ls->current =
       (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                           : luaZ_fill(ls->z))); /* skip '\n' or '\r' */
  if ((ls->current == '\n' || ls->current == '\r') && ls->current != old)
    (ls->current =
         (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                             : luaZ_fill(ls->z))); /* skip '\n\r' or '\r\n' */
  if (++ls->linenumber >= 0x7fffffff /* maximum value of an int */)
    lexerror(ls, "chunk has too many lines", 0);
}

void luaX_setinput(lua_State *L, LexState *ls, ZIO *z, TString *source,
                   int firstchar) {
  ls->t.token = 0;
  ls->L = L;
  ls->current = firstchar;
  ls->lookahead.token = TK_EOS; /* no look-ahead token */
  ls->z = z;
  ls->fs = ((void *)0);
  ls->linenumber = 1;
  ls->lastline = 1;
  ls->source = source;
  ls->envn =
      (luaS_newlstr(L,
                    ""
                    "_ENV",
                    (sizeof("_ENV") / sizeof(char)) - 1)); /* get env name */
  ((ls->buff)->buffer = ((char *)((luaM_saferealloc_(
       ls->L, ((ls->buff)->buffer), ((ls->buff)->buffsize) * sizeof(char),
       (32) * sizeof(char))))),
   (ls->buff)->buffsize = 32); /* initialize buffer */
}

/*
** =======================================================
** LEXICAL ANALYZER
** =======================================================
*/

static int check_next1(LexState *ls, int c) {
  if (ls->current == c) {
    (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                       : luaZ_fill(ls->z)));
    return 1;
  } else
    return 0;
}

/*
** Check whether current char is in set 'set' (with two chars) and
** saves it
*/
static int check_next2(LexState *ls, const char *set) {
  ((void)0);
  if (ls->current == set[0] || ls->current == set[1]) {
    (save(ls, ls->current),
     (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                        : luaZ_fill(ls->z))));
    return 1;
  } else
    return 0;
}

/* LUA_NUMBER */
/*
** this function is quite liberal in what it accepts, as 'luaO_str2num'
** will reject ill-formed numerals.
*/
static int read_numeral(LexState *ls, SemInfo *seminfo) {
  TValue obj;
  const char *expo = "Ee";
  int first = ls->current;
  ((void)0);
  (save(ls, ls->current),
   (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                      : luaZ_fill(ls->z))));
  if (first == '0' && check_next2(ls, "xX")) /* hexadecimal? */
    expo = "Pp";
  for (;;) {
    if (check_next2(ls, expo)) /* exponent part? */
      check_next2(ls, "-+");   /* optional exponent sign */
    if ((luai_ctype_[(ls->current) + 1] & ((1 << (4)))))
      (save(ls, ls->current),
       (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                          : luaZ_fill(ls->z))));
    else if (ls->current == '.')
      (save(ls, ls->current),
       (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                          : luaZ_fill(ls->z))));
    else
      break;
  }
  save(ls, '\0');
  if (luaO_str2num(((ls->buff)->buffer), &obj) == 0) /* format error? */
    lexerror(ls, "malformed number", TK_FLT);
  if (((((&obj))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
    seminfo->i = (((&obj)->value_).i);
    return TK_INT;
  } else {
    ((void)0);
    seminfo->r = (((&obj)->value_).n);
    return TK_FLT;
  }
}

/*
** reads a sequence '[=*[' or ']=*]', leaving the last bracket.
** If sequence is well formed, return its number of '='s + 2; otherwise,
** return 1 if there is no '='s or 0 otherwise (an unfinished '[==...').
*/
static size_t skip_sep(LexState *ls) {
  size_t count = 0;
  int s = ls->current;
  ((void)0);
  (save(ls, ls->current),
   (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                      : luaZ_fill(ls->z))));
  while (ls->current == '=') {
    (save(ls, ls->current),
     (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                        : luaZ_fill(ls->z))));
    count++;
  }
  return (ls->current == s) ? count + 2 : (count == 0) ? 1 : 0;
}

static void read_long_string(LexState *ls, SemInfo *seminfo, size_t sep) {
  int line = ls->linenumber; /* initial line (for error message) */
  (save(ls, ls->current),
   (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                      : luaZ_fill(ls->z)))); /* skip 2nd '[' */
  if ((ls->current == '\n' ||
       ls->current == '\r')) /* string starts with a newline? */
    inclinenumber(ls);       /* skip it */
  for (;;) {
    switch (ls->current) {
    case (-1) /* end of stream */: { /* error */
      const char *what = (seminfo ? "string" : "comment");
      const char *msg = luaO_pushfstring(
          ls->L, "unfinished long %s (starting at line %d)", what, line);
      lexerror(ls, msg, TK_EOS);
      break; /* to avoid warnings */
    }
    case ']': {
      if (skip_sep(ls) == sep) {
        (save(ls, ls->current),
         (ls->current =
              (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                  : luaZ_fill(ls->z)))); /* skip 2nd ']' */
        goto endloop;
      }
      break;
    }
    case '\n':
    case '\r': {
      save(ls, '\n');
      inclinenumber(ls);
      if (!seminfo)
        ((ls->buff)->n = 0); /* avoid wasting space */
      break;
    }
    default: {
      if (seminfo)
        (save(ls, ls->current),
         (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                            : luaZ_fill(ls->z))));
      else
        (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                           : luaZ_fill(ls->z)));
    }
    }
  }
endloop:
  if (seminfo)
    seminfo->ts = luaX_newstring(ls, ((ls->buff)->buffer) + sep,
                                 ((ls->buff)->n) - 2 * sep);
}

static void esccheck(LexState *ls, int c, const char *msg) {
  if (!c) {
    if (ls->current != (-1) /* end of stream */)
      (save(ls, ls->current),
       (ls->current =
            (((ls->z)->n--) > 0
                 ? ((unsigned char)((*(ls->z)->p++)))
                 : luaZ_fill(
                       ls->z)))); /* add current to buffer for error message */
    lexerror(ls, msg, TK_STRING);
  }
}

static int gethexa(LexState *ls) {
  (save(ls, ls->current),
   (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                      : luaZ_fill(ls->z))));
  esccheck(ls, (luai_ctype_[(ls->current) + 1] & ((1 << (4)))),
           "hexadecimal digit expected");
  return luaO_hexavalue(ls->current);
}

static int readhexaesc(LexState *ls) {
  int r = gethexa(ls);
  r = (r << 4) + gethexa(ls);
  ((ls->buff)->n -= (2)); /* remove saved chars from buffer */
  return r;
}

static unsigned long readutf8esc(LexState *ls) {
  unsigned long r;
  int i = 4; /* chars to be removed: '\', 'u', '{', and first digit */
  (save(ls, ls->current),
   (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                      : luaZ_fill(ls->z)))); /* skip 'u' */
  esccheck(ls, ls->current == '{', "missing '{'");
  r = gethexa(ls); /* must have at least one digit */
  while (
      ((save(ls, ls->current),
        (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                           : luaZ_fill(ls->z)))),
       (luai_ctype_[(ls->current) + 1] & ((1 << (4)))))) {
    i++;
    esccheck(ls, r <= (0x7FFFFFFFu >> 4), "UTF-8 value too large");
    r = (r << 4) + luaO_hexavalue(ls->current);
  }
  esccheck(ls, ls->current == '}', "missing '}'");
  (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                     : luaZ_fill(ls->z))); /* skip '}' */
  ((ls->buff)->n -= (i)); /* remove saved chars from buffer */
  return r;
}

static void utf8esc(LexState *ls) {
  char buff[8];
  int n = luaO_utf8esc(buff, readutf8esc(ls));
  for (; n > 0; n--) /* add 'buff' to string */
    save(ls, buff[8 - n]);
}

static int readdecesc(LexState *ls) {
  int i;
  int r = 0; /* result accumulator */
  for (i = 0; i < 3 && (luai_ctype_[(ls->current) + 1] & ((1 << (1))));
       i++) { /* read up to 3 digits */
    r = 10 * r + ls->current - '0';
    (save(ls, ls->current),
     (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                        : luaZ_fill(ls->z))));
  }
  esccheck(ls, r <= 255, "decimal escape too large");
  ((ls->buff)->n -= (i)); /* remove read digits from buffer */
  return r;
}

static void read_string(LexState *ls, int del, SemInfo *seminfo) {
  (save(ls, ls->current),
   (ls->current =
        (((ls->z)->n--) > 0
             ? ((unsigned char)((*(ls->z)->p++)))
             : luaZ_fill(ls->z)))); /* keep delimiter (for error messages) */
  while (ls->current != del) {
    switch (ls->current) {
    case (-1) /* end of stream */:
      lexerror(ls, "unfinished string", TK_EOS);
      break; /* to avoid warnings */
    case '\n':
    case '\r':
      lexerror(ls, "unfinished string", TK_STRING);
      break;     /* to avoid warnings */
    case '\\': { /* escape sequences */
      int c;     /* final character to be saved */
      (save(ls, ls->current),
       (ls->current =
            (((ls->z)->n--) > 0
                 ? ((unsigned char)((*(ls->z)->p++)))
                 : luaZ_fill(ls->z)))); /* keep '\\' for error messages */
      switch (ls->current) {
      case 'a':
        c = '\a';
        goto read_save;
      case 'b':
        c = '\b';
        goto read_save;
      case 'f':
        c = '\f';
        goto read_save;
      case 'n':
        c = '\n';
        goto read_save;
      case 'r':
        c = '\r';
        goto read_save;
      case 't':
        c = '\t';
        goto read_save;
      case 'v':
        c = '\v';
        goto read_save;
      case 'x':
        c = readhexaesc(ls);
        goto read_save;
      case 'u':
        utf8esc(ls);
        goto no_save;
      case '\n':
      case '\r':
        inclinenumber(ls);
        c = '\n';
        goto only_save;
      case '\\':
      case '\"':
      case '\'':
        c = ls->current;
        goto read_save;
      case (-1) /* end of stream */:
        goto no_save;           /* will raise an error next loop */
      case 'z': {               /* zap following span of spaces */
        ((ls->buff)->n -= (1)); /* remove '\\' */
        (ls->current =
             (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                 : luaZ_fill(ls->z))); /* skip the 'z' */
        while ((luai_ctype_[(ls->current) + 1] & ((1 << (3))))) {
          if ((ls->current == '\n' || ls->current == '\r'))
            inclinenumber(ls);
          else
            (ls->current =
                 (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                     : luaZ_fill(ls->z)));
        }
        goto no_save;
      }
      default: {
        esccheck(ls, (luai_ctype_[(ls->current) + 1] & ((1 << (1)))),
                 "invalid escape sequence");
        c = readdecesc(ls); /* digital escape '\ddd' */
        goto only_save;
      }
      }
    read_save:
      (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                         : luaZ_fill(ls->z)));
      /* go through */
    only_save:
      ((ls->buff)->n -= (1)); /* remove '\\' */
      save(ls, c);
      /* go through */
    no_save:
      break;
    }
    default:
      (save(ls, ls->current),
       (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                          : luaZ_fill(ls->z))));
    }
  }
  (save(ls, ls->current),
   (ls->current =
        (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                            : luaZ_fill(ls->z)))); /* skip delimiter */
  seminfo->ts =
      luaX_newstring(ls, ((ls->buff)->buffer) + 1, ((ls->buff)->n) - 2);
}

static int llex(LexState *ls, SemInfo *seminfo) {
  ((ls->buff)->n = 0);
  for (;;) {
    switch (ls->current) {
    case '\n':
    case '\r': { /* line breaks */
      inclinenumber(ls);
      break;
    }
    case ' ':
    case '\f':
    case '\t':
    case '\v': { /* spaces */
      (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                         : luaZ_fill(ls->z)));
      break;
    }
    case '-': { /* '-' or '--' (comment) */
      (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                         : luaZ_fill(ls->z)));
      if (ls->current != '-')
        return '-';
      /* else is a comment */
      (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                         : luaZ_fill(ls->z)));
      if (ls->current == '[') { /* long comment? */
        size_t sep = skip_sep(ls);
        ((ls->buff)->n = 0); /* 'skip_sep' may dirty the buffer */
        if (sep >= 2) {
          read_long_string(ls, ((void *)0), sep); /* skip long comment */
          ((ls->buff)->n = 0); /* previous call may dirty the buff. */
          break;
        }
      }
      /* else short comment */
      while (!(ls->current == '\n' || ls->current == '\r') &&
             ls->current != (-1) /* end of stream */)
        (ls->current =
             (((ls->z)->n--) > 0
                  ? ((unsigned char)((*(ls->z)->p++)))
                  : luaZ_fill(
                        ls->z))); /* skip until end of line (or end of file) */
      break;
    }
    case '[': { /* long string or simply '[' */
      size_t sep = skip_sep(ls);
      if (sep >= 2) {
        read_long_string(ls, seminfo, sep);
        return TK_STRING;
      } else if (sep == 0) /* '[=...' missing second bracket? */
        lexerror(ls, "invalid long string delimiter", TK_STRING);
      return '[';
    }
    case '=': {
      (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                         : luaZ_fill(ls->z)));
      if (check_next1(ls, '='))
        return TK_EQ;
      else
        return '=';
    }
    case '<': {
      (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                         : luaZ_fill(ls->z)));
      if (check_next1(ls, '='))
        return TK_LE;
      else if (check_next1(ls, '<'))
        return TK_SHL;
      else
        return '<';
    }
    case '>': {
      (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                         : luaZ_fill(ls->z)));
      if (check_next1(ls, '='))
        return TK_GE;
      else if (check_next1(ls, '>'))
        return TK_SHR;
      else
        return '>';
    }
    case '/': {
      (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                         : luaZ_fill(ls->z)));
      if (check_next1(ls, '/'))
        return TK_IDIV;
      else
        return '/';
    }
    case '~': {
      (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                         : luaZ_fill(ls->z)));
      if (check_next1(ls, '='))
        return TK_NE;
      else
        return '~';
    }
    case ':': {
      (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                         : luaZ_fill(ls->z)));
      if (check_next1(ls, ':'))
        return TK_DBCOLON;
      else
        return ':';
    }
    case '"':
    case '\'': { /* short literal strings */
      read_string(ls, ls->current, seminfo);
      return TK_STRING;
    }
    case '.': { /* '.', '..', '...', or number */
      (save(ls, ls->current),
       (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                          : luaZ_fill(ls->z))));
      if (check_next1(ls, '.')) {
        if (check_next1(ls, '.'))
          return TK_DOTS; /* '...' */
        else
          return TK_CONCAT; /* '..' */
      } else if (!(luai_ctype_[(ls->current) + 1] & ((1 << (1)))))
        return '.';
      else
        return read_numeral(ls, seminfo);
    }
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': {
      return read_numeral(ls, seminfo);
    }
    case (-1) /* end of stream */: {
      return TK_EOS;
    }
    default: {
      if ((luai_ctype_[(ls->current) + 1] &
           ((1 << (0))))) { /* identifier or reserved word? */
        TString *ts;
        do {
          (save(ls, ls->current),
           (ls->current =
                (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                    : luaZ_fill(ls->z))));
        } while (
            (luai_ctype_[(ls->current) + 1] & (((1 << (0)) | (1 << (1))))));
        ts = luaX_newstring(ls, ((ls->buff)->buffer), ((ls->buff)->n));
        seminfo->ts = ts;
        if (((ts)->tt == (4 | (1 << 4)) /* short strings */ &&
             (ts)->extra > 0)) /* reserved word? */
          return ts->extra - 1 + 257;
        else {
          return TK_NAME;
        }
      } else { /* single-char tokens (+ - / ...) */
        int c = ls->current;
        (ls->current = (((ls->z)->n--) > 0 ? ((unsigned char)((*(ls->z)->p++)))
                                           : luaZ_fill(ls->z)));
        return c;
      }
    }
    }
  }
}

void luaX_next(LexState *ls) {
  ls->lastline = ls->linenumber;
  if (ls->lookahead.token != TK_EOS) { /* is there a look-ahead token? */
    ls->t = ls->lookahead;             /* use this one */
    ls->lookahead.token = TK_EOS;      /* and discharge it */
  } else
    ls->t.token = llex(ls, &ls->t.seminfo); /* read next token */
}

int luaX_lookahead(LexState *ls) {
  ((void)0);
  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);
  return ls->lookahead.token;
}
/*
** $Id: lcode.c $
** Code generator for Lua
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */

/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lcode.h $
** Code generator for Lua
** See Copyright Notice in lua.h
*/

/*
** $Id: llex.h $
** Lexical Analyzer
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lopcodes.h $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/
/*
** $Id: lparser.h $
** Lua Parser
** See Copyright Notice in lua.h
*/

/*
** Marks the end of a patch list. It is an invalid value both as an absolute
** address, and as a list link (would link an element to itself).
*/

/*
** grep "ORDER OPR" if you change these enums  (ORDER OP)
*/
typedef enum BinOpr {
  OPR_ADD,
  OPR_SUB,
  OPR_MUL,
  OPR_MOD,
  OPR_POW,
  OPR_DIV,
  OPR_IDIV,
  OPR_BAND,
  OPR_BOR,
  OPR_BXOR,
  OPR_SHL,
  OPR_SHR,
  OPR_CONCAT,
  OPR_EQ,
  OPR_LT,
  OPR_LE,
  OPR_NE,
  OPR_GT,
  OPR_GE,
  OPR_AND,
  OPR_OR,
  OPR_NOBINOPR
} BinOpr;

typedef enum UnOpr { OPR_MINUS, OPR_BNOT, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;

/* get (pointer to) instruction of given 'expdesc' */

static int luaK_codeABx(FuncState *fs, OpCode o, int A, unsigned int Bx);
static int luaK_codeAsBx(FuncState *fs, OpCode o, int A, int Bx);
static int luaK_codeABCk(FuncState *fs, OpCode o, int A, int B, int C, int k);
static int luaK_isKint(expdesc *e);
static void luaK_fixline(FuncState *fs, int line);
static void luaK_nil(FuncState *fs, int from, int n);
static void luaK_reserveregs(FuncState *fs, int n);
static void luaK_checkstack(FuncState *fs, int n);
static int luaK_stringK(FuncState *fs, TString *s);
static void luaK_int(FuncState *fs, int reg, lua_Integer n);
static void luaK_dischargevars(FuncState *fs, expdesc *e);
static int luaK_exp2anyreg(FuncState *fs, expdesc *e);
static void luaK_exp2anyregup(FuncState *fs, expdesc *e);
static void luaK_exp2nextreg(FuncState *fs, expdesc *e);
static void luaK_exp2val(FuncState *fs, expdesc *e);
static int luaK_exp2RK(FuncState *fs, expdesc *e);
static void luaK_self(FuncState *fs, expdesc *e, expdesc *key);
static void luaK_indexed(FuncState *fs, expdesc *t, expdesc *k);
static void luaK_goiftrue(FuncState *fs, expdesc *e);
static void luaK_goiffalse(FuncState *fs, expdesc *e);
static void luaK_storevar(FuncState *fs, expdesc *var, expdesc *e);
static void luaK_setreturns(FuncState *fs, expdesc *e, int nresults);
static void luaK_setoneret(FuncState *fs, expdesc *e);
static int luaK_jump(FuncState *fs);
static void luaK_ret(FuncState *fs, int first, int nret);
static void luaK_patchlist(FuncState *fs, int list, int target);
static void luaK_patchtohere(FuncState *fs, int list);
static void luaK_concat(FuncState *fs, int *l1, int l2);
static int luaK_getlabel(FuncState *fs);
static void luaK_prefix(FuncState *fs, UnOpr op, expdesc *v, int line);
static void luaK_infix(FuncState *fs, BinOpr op, expdesc *v);
static void luaK_posfix(FuncState *fs, BinOpr op, expdesc *v1, expdesc *v2,
                        int line);
static void luaK_setlist(FuncState *fs, int base, int nelems, int tostore);
static void luaK_finish(FuncState *fs);
static void __attribute__((noreturn))
luaK_semerror(LexState *ls, const char *msg);
/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/
/*
** $Id: llex.h $
** Lexical Analyzer
** See Copyright Notice in lua.h
*/
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lopcodes.h $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/
/*
** $Id: lparser.h $
** Lua Parser
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltable.h $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/
/*
** $Id: lvm.h $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: ltm.h $
** Tag methods
** See Copyright Notice in lua.h
*/
/*
** You can define LUA_FLOORN2I if you want to convert floats to integers
** by flooring them (instead of raising an error if they are not
** integral values)
*/

/* convert an object to a float (including string coercion) */

/* convert an object to a float (without string coercion) */

/* convert an object to an integer (including string coercion) */

/* convert an object to an integer (without string coercion) */
/*
** fast track for 'gettable': if 't' is a table and 't[k]' is present,
** return 1 with 'slot' pointing to 't[k]' (position of final result).
** Otherwise, return 0 (meaning it will have to check metamethod)
** with 'slot' pointing to an empty 't[k]' (if 't' is a table) or NULL
** (otherwise). 'f' is the raw get function to use.
*/

/*
** Special case of 'luaV_fastget' for integers, inlining the fast case
** of 'luaH_getint'.
*/
/*
** Finish a fast set operation (when fast get succeeds). In that case,
** 'slot' points to the place to put the value.
*/

static int luaV_equalobj(lua_State *L, const TValue *t1, const TValue *t2);
static int luaV_lessthan(lua_State *L, const TValue *l, const TValue *r);
static int luaV_lessequal(lua_State *L, const TValue *l, const TValue *r);
static int luaV_tonumber_(const TValue *obj, lua_Number *n);
static int luaV_tointeger(const TValue *obj, lua_Integer *p, int mode);
static int luaV_tointegerns(const TValue *obj, lua_Integer *p, int mode);
static int luaV_flttointeger(lua_Number n, lua_Integer *p, int mode);
static void luaV_finishget(lua_State *L, const TValue *t, TValue *key,
                           StkId val, const TValue *slot);
static void luaV_finishset(lua_State *L, const TValue *t, TValue *key,
                           TValue *val, const TValue *slot);
static void luaV_finishOp(lua_State *L);
static void luaV_execute(lua_State *L, CallInfo *ci);
static void luaV_concat(lua_State *L, int total);
static lua_Integer luaV_idiv(lua_State *L, lua_Integer x, lua_Integer y);
static lua_Integer luaV_mod(lua_State *L, lua_Integer x, lua_Integer y);
static lua_Number luaV_modf(lua_State *L, lua_Number x, lua_Number y);
static lua_Integer luaV_shiftl(lua_Integer x, lua_Integer y);
static void luaV_objlen(lua_State *L, StkId ra, const TValue *rb);

/* Maximum number of registers in a Lua function (must fit in 8 bits) */

static int codesJ(FuncState *fs, OpCode o, int sj, int k);

/* semantic error */
void __attribute__((noreturn)) luaK_semerror(LexState *ls, const char *msg) {
  ls->t.token = 0; /* remove "near <token>" from final message */
  luaX_syntaxerror(ls, msg);
}

/*
** If expression is a numeric constant, fills 'v' with its value
** and returns 1. Otherwise, returns 0.
*/
static int tonumeral(const expdesc *e, TValue *v) {
  if (((e)->t != (e)->f))
    return 0; /* not a numeral */
  switch (e->k) {
  case VKINT:
    if (v) {
      TValue *io = (v);
      ((io)->value_).i = (e->u.ival);
      ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
    };
    return 1;
  case VKFLT:
    if (v) {
      TValue *io = (v);
      ((io)->value_).n = (e->u.nval);
      ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
    };
    return 1;
  default:
    return 0;
  }
}

/*
** Return the previous instruction of the current code. If there
** may be a jump target between the current instruction and the
** previous one, return an invalid instruction (to avoid wrong
** optimizations).
*/
static Instruction *previousinstruction(FuncState *fs) {
  static const Instruction invalidinstruction = -1;
  if (fs->pc > fs->lasttarget)
    return &fs->f->code[fs->pc - 1]; /* previous instruction */
  else
    return ((Instruction *)(&invalidinstruction));
}

/*
** Create a OP_LOADNIL instruction, but try to optimize: if the previous
** instruction is also OP_LOADNIL and ranges are compatible, adjust
** range of previous instruction instead of emitting a new one. (For
** instance, 'local a; local b' will generate a single opcode.)
*/
void luaK_nil(FuncState *fs, int from, int n) {
  int l = from + n - 1; /* last register to set nil */
  Instruction *previous = previousinstruction(fs);
  if ((((OpCode)(((*previous) >> 0) &
                 ((~((~(Instruction)0) << (7))) << (0))))) ==
      OP_LOADNIL) { /* previous is LOADNIL? */
    int pfrom = (((int)((
        ((*previous) >> ((0 + 7))) &
        ((~((~(Instruction)0) << (8))) << (0)))))); /* get previous range */
    int pl = pfrom + ((((int)((((*previous) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))));
    if ((pfrom <= from && from <= pl + 1) ||
        (from <= pfrom && pfrom <= l + 1)) { /* can connect both? */
      if (pfrom < from)
        from = pfrom; /* from = min(from, pfrom) */
      if (pl > l)
        l = pl; /* l = max(l, pl) */
      ((*previous) =
           (((*previous) & (~((~((~(Instruction)0) << (8))) << ((0 + 7))))) |
            ((((Instruction)(from)) << (0 + 7)) &
             ((~((~(Instruction)0) << (8))) << ((0 + 7))))));
      ((*previous) =
           (((*previous) &
             (~((~((~(Instruction)0) << (8))) << ((((0 + 7) + 8) + 1))))) |
            ((((Instruction)(l - from)) << (((0 + 7) + 8) + 1)) &
             ((~((~(Instruction)0) << (8))) << ((((0 + 7) + 8) + 1))))));
      return;
    } /* else go through */
  }
  luaK_codeABCk(fs, OP_LOADNIL, from, n - 1, 0, 0); /* else no optimization */
}

/*
** Gets the destination address of a jump instruction. Used to traverse
** a list of jumps.
*/
static int getjump(FuncState *fs, int pc) {
  int offset =
      ((((int)((((fs->f->code[pc]) >> ((0 + 7))) &
                ((~((~(Instruction)0) << (((8 + 8 + 1) + 8)))) << (0)))))) -
       (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1));
  if (offset == (-1)) /* point to itself represents end of list */
    return (-1);      /* end of list */
  else
    return (pc + 1) + offset; /* turn offset into absolute position */
}

/*
** Fix jump instruction at position 'pc' to jump to 'dest'.
** (Jump addresses are relative in Lua)
*/
static void fixjump(FuncState *fs, int pc, int dest) {
  Instruction *jmp = &fs->f->code[pc];
  int offset = dest - (pc + 1);
  ((void)0);
  if (!(-(((1 << ((8 + 8 + 1) + 8)) - 1) >> 1) <= offset &&
        offset <= ((1 << ((8 + 8 + 1) + 8)) - 1) -
                      (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)))
    luaX_syntaxerror(fs->ls, "control structure too long");
  ((void)0);
  ((*jmp) = (((*jmp) &
              (~((~((~(Instruction)0) << (((8 + 8 + 1) + 8)))) << ((0 + 7))))) |
             ((((Instruction)(((unsigned int)((
                   (offset) + (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1))))))
               << (0 + 7)) &
              ((~((~(Instruction)0) << (((8 + 8 + 1) + 8)))) << ((0 + 7))))));
}

/*
** Concatenate jump-list 'l2' into jump-list 'l1'
*/
void luaK_concat(FuncState *fs, int *l1, int l2) {
  if (l2 == (-1))
    return;             /* nothing to concatenate? */
  else if (*l1 == (-1)) /* no original list? */
    *l1 = l2;           /* 'l1' points to 'l2' */
  else {
    int list = *l1;
    int next;
    while ((next = getjump(fs, list)) != (-1)) /* find last element */
      list = next;
    fixjump(fs, list, l2); /* last element links to 'l2' */
  }
}

/*
** Create a jump instruction and return its position, so its destination
** can be fixed later (with 'fixjump').
*/
int luaK_jump(FuncState *fs) { return codesJ(fs, OP_JMP, (-1), 0); }

/*
** Code a 'return' instruction
*/
void luaK_ret(FuncState *fs, int first, int nret) {
  OpCode op;
  switch (nret) {
  case 0:
    op = OP_RETURN0;
    break;
  case 1:
    op = OP_RETURN1;
    break;
  default:
    op = OP_RETURN;
    break;
  }
  luaK_codeABCk(fs, op, first, nret + 1, 0, 0);
}

/*
** Code a "conditional jump", that is, a test or comparison opcode
** followed by a jump. Return jump position.
*/
static int condjump(FuncState *fs, OpCode op, int A, int B, int C, int k) {
  luaK_codeABCk(fs, op, A, B, C, k);
  return luaK_jump(fs);
}

/*
** returns current 'pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
*/
int luaK_getlabel(FuncState *fs) {
  fs->lasttarget = fs->pc;
  return fs->pc;
}

/*
** Returns the position of the instruction "controlling" a given
** jump (that is, its condition), or the jump itself if it is
** unconditional.
*/
static Instruction *getjumpcontrol(FuncState *fs, int pc) {
  Instruction *pi = &fs->f->code[pc];
  if (pc >= 1 &&
      (luaP_opmodes[(((OpCode)(((*(pi - 1)) >> 0) &
                               ((~((~(Instruction)0) << (7))) << (0)))))] &
       (1 << 4)))
    return pi - 1;
  else
    return pi;
}

/*
** Patch destination register for a TESTSET instruction.
** If instruction in position 'node' is not a TESTSET, return 0 ("fails").
** Otherwise, if 'reg' is not 'NO_REG', set it as the destination
** register. Otherwise, change instruction to a simple 'TEST' (produces
** no register value)
*/
static int patchtestreg(FuncState *fs, int node, int reg) {
  Instruction *i = getjumpcontrol(fs, node);
  if ((((OpCode)(((*i) >> 0) & ((~((~(Instruction)0) << (7))) << (0))))) !=
      OP_TESTSET)
    return 0; /* cannot patch other instructions */
  if (reg != ((1 << 8) - 1) &&
      reg != ((((int)((((*i) >> ((((0 + 7) + 8) + 1))) &
                       ((~((~(Instruction)0) << (8))) << (0))))))))
    ((*i) = (((*i) & (~((~((~(Instruction)0) << (8))) << ((0 + 7))))) |
             ((((Instruction)(reg)) << (0 + 7)) &
              ((~((~(Instruction)0) << (8))) << ((0 + 7))))));
  else {
    /* no register to put value or register already has the value;
       change instruction to simple test */
    *i =
        ((((Instruction)(OP_TEST)) << 0) |
         (((Instruction)(((((int)((((*i) >> ((((0 + 7) + 8) + 1))) &
                                   ((~((~(Instruction)0) << (8))) << (0)))))))))
          << (0 + 7)) |
         (((Instruction)(0)) << (((0 + 7) + 8) + 1)) |
         (((Instruction)(0)) << ((((0 + 7) + 8) + 1) + 8)) |
         (((Instruction)(((((int)((((*i) >> (((0 + 7) + 8))) &
                                   ((~((~(Instruction)0) << (1))) << (0)))))))))
          << ((0 + 7) + 8)));
  }
  return 1;
}

/*
** Traverse a list of tests ensuring no one produces a value
*/
static void removevalues(FuncState *fs, int list) {
  for (; list != (-1); list = getjump(fs, list))
    patchtestreg(fs, list, ((1 << 8) - 1));
}

/*
** Traverse a list of tests, patching their destination address and
** registers: tests producing values jump to 'vtarget' (and put their
** values in 'reg'), other tests jump to 'dtarget'.
*/
static void patchlistaux(FuncState *fs, int list, int vtarget, int reg,
                         int dtarget) {
  while (list != (-1)) {
    int next = getjump(fs, list);
    if (patchtestreg(fs, list, reg))
      fixjump(fs, list, vtarget);
    else
      fixjump(fs, list, dtarget); /* jump to default target */
    list = next;
  }
}

/*
** Path all jumps in 'list' to jump to 'target'.
** (The assert means that we cannot fix a jump to a forward address
** because we only know addresses once code is generated.)
*/
void luaK_patchlist(FuncState *fs, int list, int target) {
  ((void)0);
  patchlistaux(fs, list, target, ((1 << 8) - 1), target);
}

void luaK_patchtohere(FuncState *fs, int list) {
  int hr = luaK_getlabel(fs); /* mark "here" as a jump target */
  luaK_patchlist(fs, list, hr);
}

/*
** MAXimum number of successive Instructions WiTHout ABSolute line
** information.
*/

/* limit for difference between lines in relative line info. */

/*
** Save line info for a new instruction. If difference from last line
** does not fit in a byte, of after that many instructions, save a new
** absolute line info; (in that case, the special value 'ABSLINEINFO'
** in 'lineinfo' signals the existence of this absolute information.)
** Otherwise, store the difference from last line in 'lineinfo'.
*/
static void savelineinfo(FuncState *fs, Proto *f, int line) {
  int linedif = line - fs->previousline;
  int pc = fs->pc - 1; /* last instruction coded */
  if (abs(linedif) >= 0x80 || fs->iwthabs++ > 120) {
    ((f->abslineinfo) = ((AbsLineInfo *)(luaM_growaux_(
         fs->ls->L, f->abslineinfo, fs->nabslineinfo, &(f->sizeabslineinfo),
         sizeof(AbsLineInfo),
         ((((size_t)((0x7fffffff /* maximum value of an int */))) <=
           ((size_t)(~(size_t)0)) / sizeof(AbsLineInfo))
              ? (0x7fffffff /* maximum value of an int */)
              : ((unsigned int)((
                    (((size_t)(~(size_t)0)) / sizeof(AbsLineInfo)))))),
         "lines"))));
    f->abslineinfo[fs->nabslineinfo].pc = pc;
    f->abslineinfo[fs->nabslineinfo++].line = line;
    linedif = (-0x80); /* signal that there is absolute information */
    fs->iwthabs = 0;   /* restart counter */
  }
  ((f->lineinfo) = ((ls_byte *)(luaM_growaux_(
       fs->ls->L, f->lineinfo, pc, &(f->sizelineinfo), sizeof(ls_byte),
       ((((size_t)((0x7fffffff /* maximum value of an int */))) <=
         ((size_t)(~(size_t)0)) / sizeof(ls_byte))
            ? (0x7fffffff /* maximum value of an int */)
            : ((unsigned int)(((((size_t)(~(size_t)0)) / sizeof(ls_byte)))))),
       "opcodes"))));
  f->lineinfo[pc] = linedif;
  fs->previousline = line; /* last line saved */
}

/*
** Remove line information from the last instruction.
** If line information for that instruction is absolute, set 'iwthabs'
** above its max to force the new (replacing) instruction to have
** absolute line info, too.
*/
static void removelastlineinfo(FuncState *fs) {
  Proto *f = fs->f;
  int pc = fs->pc - 1;                   /* last instruction coded */
  if (f->lineinfo[pc] != (-0x80)) {      /* relative line info? */
    fs->previousline -= f->lineinfo[pc]; /* last line saved */
    fs->iwthabs--;
  } else {              /* absolute line information */
    fs->nabslineinfo--; /* remove it */
    ((void)0);
    fs->iwthabs = 120 + 1; /* force next line info to be absolute */
  }
}

/*
** Remove the last instruction created, correcting line information
** accordingly.
*/
static void removelastinstruction(FuncState *fs) {
  removelastlineinfo(fs);
  fs->pc--;
}

/*
** Emit instruction 'i', checking for array sizes and saving also its
** line information. Return 'i' position.
*/
static int luaK_code(FuncState *fs, Instruction i) {
  Proto *f = fs->f;
  /* put new instruction in code array */
  ((f->code) = ((Instruction *)(luaM_growaux_(
       fs->ls->L, f->code, fs->pc, &(f->sizecode), sizeof(Instruction),
       ((((size_t)((0x7fffffff /* maximum value of an int */))) <=
         ((size_t)(~(size_t)0)) / sizeof(Instruction))
            ? (0x7fffffff /* maximum value of an int */)
            : ((unsigned int)((
                  (((size_t)(~(size_t)0)) / sizeof(Instruction)))))),
       "opcodes"))));
  f->code[fs->pc++] = i;
  savelineinfo(fs, f, fs->ls->lastline);
  return fs->pc - 1; /* index of new instruction */
}

/*
** Format and emit an 'iABC' instruction. (Assertions check consistency
** of parameters versus opcode.)
*/
int luaK_codeABCk(FuncState *fs, OpCode o, int a, int b, int c, int k) {
  ((void)0);
  ((void)0);
  return luaK_code(fs, ((((Instruction)(o)) << 0) |
                        (((Instruction)(a)) << (0 + 7)) |
                        (((Instruction)(b)) << (((0 + 7) + 8) + 1)) |
                        (((Instruction)(c)) << ((((0 + 7) + 8) + 1) + 8)) |
                        (((Instruction)(k)) << ((0 + 7) + 8))));
}

/*
** Format and emit an 'iABx' instruction.
*/
int luaK_codeABx(FuncState *fs, OpCode o, int a, unsigned int bc) {
  ((void)0);
  ((void)0);
  return luaK_code(fs, ((((Instruction)(o)) << 0) |
                        (((Instruction)(a)) << (0 + 7)) |
                        (((Instruction)(bc)) << ((0 + 7) + 8))));
}

/*
** Format and emit an 'iAsBx' instruction.
*/
int luaK_codeAsBx(FuncState *fs, OpCode o, int a, int bc) {
  unsigned int b = bc + (((1 << (8 + 8 + 1)) - 1) >> 1) /* 'sBx' is signed */;
  ((void)0);
  ((void)0);
  return luaK_code(fs, ((((Instruction)(o)) << 0) |
                        (((Instruction)(a)) << (0 + 7)) |
                        (((Instruction)(b)) << ((0 + 7) + 8))));
}

/*
** Format and emit an 'isJ' instruction.
*/
static int codesJ(FuncState *fs, OpCode o, int sj, int k) {
  unsigned int j = sj + (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1);
  ((void)0);
  ((void)0);
  return luaK_code(fs, ((((Instruction)(o)) << 0) |
                        (((Instruction)(j)) << (0 + 7)) |
                        (((Instruction)(k)) << ((0 + 7) + 8))));
}

/*
** Emit an "extra argument" instruction (format 'iAx')
*/
static int codeextraarg(FuncState *fs, int a) {
  ((void)0);
  return luaK_code(fs, ((((Instruction)(OP_EXTRAARG)) << 0) |
                        (((Instruction)(a)) << (0 + 7))));
}

/*
** Emit a "load constant" instruction, using either 'OP_LOADK'
** (if constant index 'k' fits in 18 bits) or an 'OP_LOADKX'
** instruction with "extra argument".
*/
static int luaK_codek(FuncState *fs, int reg, int k) {
  if (k <= ((1 << (8 + 8 + 1)) - 1))
    return luaK_codeABx(fs, OP_LOADK, reg, k);
  else {
    int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);
    codeextraarg(fs, k);
    return p;
  }
}

/*
** Check register-stack level, keeping track of its maximum size
** in field 'maxstacksize'
*/
void luaK_checkstack(FuncState *fs, int n) {
  int newstack = fs->freereg + n;
  if (newstack > fs->f->maxstacksize) {
    if (newstack >= 255)
      luaX_syntaxerror(fs->ls,
                       "function or expression needs too many registers");
    fs->f->maxstacksize = ((lu_byte)((newstack)));
  }
}

/*
** Reserve 'n' registers in register stack
*/
void luaK_reserveregs(FuncState *fs, int n) {
  luaK_checkstack(fs, n);
  fs->freereg += n;
}

/*
** Free register 'reg', if it is neither a constant index nor
** a local variable.
)
*/
static void freereg(FuncState *fs, int reg) {
  if (reg >= fs->nactvar) {
    fs->freereg--;
    ((void)0);
  }
}

/*
** Free two registers in proper order
*/
static void freeregs(FuncState *fs, int r1, int r2) {
  if (r1 > r2) {
    freereg(fs, r1);
    freereg(fs, r2);
  } else {
    freereg(fs, r2);
    freereg(fs, r1);
  }
}

/*
** Free register used by expression 'e' (if any)
*/
static void freeexp(FuncState *fs, expdesc *e) {
  if (e->k == VNONRELOC)
    freereg(fs, e->u.info);
}

/*
** Free registers used by expressions 'e1' and 'e2' (if any) in proper
** order.
*/
static void freeexps(FuncState *fs, expdesc *e1, expdesc *e2) {
  int r1 = (e1->k == VNONRELOC) ? e1->u.info : -1;
  int r2 = (e2->k == VNONRELOC) ? e2->u.info : -1;
  freeregs(fs, r1, r2);
}

/*
** Add constant 'v' to prototype's list of constants (field 'k').
** Use scanner's table to cache position of constants in constant list
** and try to reuse constants. Because some values should not be used
** as keys (nil cannot be a key, integer keys can collapse with float
** keys), the caller must provide a useful 'key' for indexing the cache.
*/
static int addk(FuncState *fs, TValue *key, TValue *v) {
  lua_State *L = fs->ls->L;
  Proto *f = fs->f;
  TValue *idx = luaH_set(L, fs->ls->h, key); /* index scanner table */
  int k, oldsize;
  if (((((idx))->tt_) ==
       ((3 | (2 << 4)) /* integer numbers */))) { /* is there an index there? */
    k = ((int)(((((idx)->value_).i))));
    /* correct value? (warning: must distinguish floats from integers!) */
    if (k < fs->nk && ((((&f->k[k])->tt_)) & 0x3F) == ((((v)->tt_)) & 0x3F) &&
        luaV_equalobj(((void *)0), &f->k[k], v))
      return k; /* reuse index */
  }
  /* constant not found; create a new entry */
  oldsize = f->sizek;
  k = fs->nk;
  /* numerical value does not need GC barrier;
     table has no metatable, so it does not need to invalidate cache */
  {
    TValue *io = (idx);
    ((io)->value_).i = (k);
    ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
  };
  ((f->k) = ((TValue *)(luaM_growaux_(
       L, f->k, k, &(f->sizek), sizeof(TValue),
       ((((size_t)((((1 << ((8 + 8 + 1) + 8)) - 1)))) <=
         ((size_t)(~(size_t)0)) / sizeof(TValue))
            ? (((1 << ((8 + 8 + 1) + 8)) - 1))
            : ((unsigned int)(((((size_t)(~(size_t)0)) / sizeof(TValue)))))),
       "constants"))));
  while (oldsize < f->sizek)
    ((&f->k[oldsize++])->tt_ = (0));
  {
    TValue *io1 = (&f->k[k]);
    const TValue *io2 = (v);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
  fs->nk++;
  (((((v)->tt_) & (1 << 6)) &&
    (((f)->marked) & ((1 << (5 /* object is black */)))) &&
    ((((((v)->value_).gc))->marked) &
     (((1 << (3 /* object is white (type 0) */)) |
       (1 << (4 /* object is white (type 1) */))))))
       ? luaC_barrier_(L, (&(((union GCUnion *)((f)))->gc)), (((v)->value_).gc))
       : ((void)((0))));
  return k;
}

/*
** Add a string to list of constants and return its index.
*/
int luaK_stringK(FuncState *fs, TString *s) {
  TValue o;
  {
    TValue *io = (&o);
    TString *x_ = (s);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((x_->tt) | (1 << 6))));
    ((void)0);
  };
  return addk(fs, &o, &o); /* use string itself as key */
}

/*
** Add an integer to list of constants and return its index.
** Integers use userdata as keys to avoid collision with floats with
** same value; conversion to 'void*' is used only for hashing, so there
** are no "precision" problems.
*/
static int luaK_intK(FuncState *fs, lua_Integer n) {
  TValue k, o;
  {
    TValue *io = (&k);
    ((io)->value_).p = (((void *)((((size_t)((n)))))));
    ((io)->tt_ = (2));
  };
  {
    TValue *io = (&o);
    ((io)->value_).i = (n);
    ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
  };
  return addk(fs, &k, &o);
}

/*
** Add a float to list of constants and return its index.
*/
static int luaK_numberK(FuncState *fs, lua_Number r) {
  TValue o;
  {
    TValue *io = (&o);
    ((io)->value_).n = (r);
    ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
  };
  return addk(fs, &o, &o); /* use number itself as key */
}

/*
** Add a boolean to list of constants and return its index.
*/
static int boolK(FuncState *fs, int b) {
  TValue o;
  {
    TValue *io = (&o);
    ((io)->value_).b = (b);
    ((io)->tt_ = (1));
  };
  return addk(fs, &o, &o); /* use boolean itself as key */
}

/*
** Add nil to list of constants and return its index.
*/
static int nilK(FuncState *fs) {
  TValue k, v;
  ((&v)->tt_ = (0));
  /* cannot use nil as key; instead use table itself to represent nil */
  {
    TValue *io = (&k);
    Table *x_ = (fs->ls->h);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((5) | (1 << 6))));
    ((void)0);
  };
  return addk(fs, &k, &v);
}

/*
** Check whether 'i' can be stored in an 'sC' operand.
** Equivalent to (0 <= i + OFFSET_sC && i + OFFSET_sC <= MAXARG_C)
** but without risk of overflows in the addition.
*/
static int fitsC(lua_Integer i) {
  return (-(((1 << 8) - 1) >> 1) <= i &&
          i <= ((1 << 8) - 1) - (((1 << 8) - 1) >> 1));
}

/*
** Check whether 'i' can be stored in an 'sBx' operand.
*/
static int fitsBx(lua_Integer i) {
  return (-(((1 << (8 + 8 + 1)) - 1) >> 1) /* 'sBx' is signed */ <= i &&
          i <= ((1 << (8 + 8 + 1)) - 1) -
                   (((1 << (8 + 8 + 1)) - 1) >> 1) /* 'sBx' is signed */);
}

void luaK_int(FuncState *fs, int reg, lua_Integer i) {
  if (fitsBx(i))
    luaK_codeAsBx(fs, OP_LOADI, reg, ((int)((i))));
  else
    luaK_codek(fs, reg, luaK_intK(fs, i));
}

static int floatI(lua_Number f, lua_Integer *fi) {
  return (luaV_flttointeger(f, fi, 0) && fitsBx(*fi));
}

static void luaK_float(FuncState *fs, int reg, lua_Number f) {
  lua_Integer fi;
  if (floatI(f, &fi))
    luaK_codeAsBx(fs, OP_LOADF, reg, ((int)((fi))));
  else
    luaK_codek(fs, reg, luaK_numberK(fs, f));
}

/*
** Fix an expression to return the number of results 'nresults'.
** Either 'e' is a multi-ret expression (function call or vararg)
** or 'nresults' is LUA_MULTRET (as any expression can satisfy that).
*/
void luaK_setreturns(FuncState *fs, expdesc *e, int nresults) {
  Instruction *pc = &((fs)->f->code[(e)->u.info]);
  if (e->k == VCALL) /* expression is an open function call? */
    ((*pc) =
         (((*pc) &
           (~((~((~(Instruction)0) << (8))) << (((((0 + 7) + 8) + 1) + 8))))) |
          ((((Instruction)(nresults + 1)) << ((((0 + 7) + 8) + 1) + 8)) &
           ((~((~(Instruction)0) << (8))) << (((((0 + 7) + 8) + 1) + 8))))));
  else if (e->k == VVARARG) {
    ((*pc) =
         (((*pc) &
           (~((~((~(Instruction)0) << (8))) << (((((0 + 7) + 8) + 1) + 8))))) |
          ((((Instruction)(nresults + 1)) << ((((0 + 7) + 8) + 1) + 8)) &
           ((~((~(Instruction)0) << (8))) << (((((0 + 7) + 8) + 1) + 8))))));
    ((*pc) = (((*pc) & (~((~((~(Instruction)0) << (8))) << ((0 + 7))))) |
              ((((Instruction)(fs->freereg)) << (0 + 7)) &
               ((~((~(Instruction)0) << (8))) << ((0 + 7))))));
    luaK_reserveregs(fs, 1);
  } else
    ((void)0);
}

/*
** Fix an expression to return one result.
** If expression is not a multi-ret expression (function call or
** vararg), it already returns one result, so nothing needs to be done.
** Function calls become VNONRELOC expressions (as its result comes
** fixed in the base register of the call), while vararg expressions
** become VRELOC (as OP_VARARG puts its results where it wants).
** (Calls are created returning one result, so that does not need
** to be fixed.)
*/
void luaK_setoneret(FuncState *fs, expdesc *e) {
  if (e->k == VCALL) { /* expression is an open function call? */
    /* already returns 1 value */
    ((void)0);
    e->k = VNONRELOC; /* result has fixed position */
    e->u.info = (((int)((((((fs)->f->code[(e)->u.info])) >> ((0 + 7))) &
                         ((~((~(Instruction)0) << (8))) << (0))))));
  } else if (e->k == VVARARG) {
    ((((fs)->f->code[(e)->u.info])) =
         (((((fs)->f->code[(e)->u.info])) &
           (~((~((~(Instruction)0) << (8))) << (((((0 + 7) + 8) + 1) + 8))))) |
          ((((Instruction)(2)) << ((((0 + 7) + 8) + 1) + 8)) &
           ((~((~(Instruction)0) << (8))) << (((((0 + 7) + 8) + 1) + 8))))));
    e->k = VRELOC; /* can relocate its simple result */
  }
}

/*
** Ensure that expression 'e' is not a variable.
** (Expression still may have jump lists.)
*/
void luaK_dischargevars(FuncState *fs, expdesc *e) {
  switch (e->k) {
  case VLOCAL: {      /* already in a register */
    e->k = VNONRELOC; /* becomes a non-relocatable value */
    break;
  }
  case VUPVAL: { /* move value to some (pending) register */
    e->u.info = luaK_codeABCk(fs, OP_GETUPVAL, 0, e->u.info, 0, 0);
    e->k = VRELOC;
    break;
  }
  case VINDEXUP: {
    e->u.info = luaK_codeABCk(fs, OP_GETTABUP, 0, e->u.ind.t, e->u.ind.idx, 0);
    e->k = VRELOC;
    break;
  }
  case VINDEXI: {
    freereg(fs, e->u.ind.t);
    e->u.info = luaK_codeABCk(fs, OP_GETI, 0, e->u.ind.t, e->u.ind.idx, 0);
    e->k = VRELOC;
    break;
  }
  case VINDEXSTR: {
    freereg(fs, e->u.ind.t);
    e->u.info = luaK_codeABCk(fs, OP_GETFIELD, 0, e->u.ind.t, e->u.ind.idx, 0);
    e->k = VRELOC;
    break;
  }
  case VINDEXED: {
    freeregs(fs, e->u.ind.t, e->u.ind.idx);
    e->u.info = luaK_codeABCk(fs, OP_GETTABLE, 0, e->u.ind.t, e->u.ind.idx, 0);
    e->k = VRELOC;
    break;
  }
  case VVARARG:
  case VCALL: {
    luaK_setoneret(fs, e);
    break;
  }
  default:
    break; /* there is one value available (somewhere) */
  }
}

/*
** Ensures expression value is in register 'reg' (and therefore
** 'e' will become a non-relocatable expression).
** (Expression still may have jump lists.)
*/
static void discharge2reg(FuncState *fs, expdesc *e, int reg) {
  luaK_dischargevars(fs, e);
  switch (e->k) {
  case VNIL: {
    luaK_nil(fs, reg, 1);
    break;
  }
  case VFALSE:
  case VTRUE: {
    luaK_codeABCk(fs, OP_LOADBOOL, reg, e->k == VTRUE, 0, 0);
    break;
  }
  case VK: {
    luaK_codek(fs, reg, e->u.info);
    break;
  }
  case VKFLT: {
    luaK_float(fs, reg, e->u.nval);
    break;
  }
  case VKINT: {
    luaK_int(fs, reg, e->u.ival);
    break;
  }
  case VRELOC: {
    Instruction *pc = &((fs)->f->code[(e)->u.info]);
    ((*pc) = (((*pc) & (~((~((~(Instruction)0) << (8))) << ((0 + 7))))) |
              ((((Instruction)(reg)) << (0 + 7)) &
               ((~((~(Instruction)0) << (8)))
                << ((0 + 7)))))); /* instruction will put result in 'reg' */
    break;
  }
  case VNONRELOC: {
    if (reg != e->u.info)
      luaK_codeABCk(fs, OP_MOVE, reg, e->u.info, 0, 0);
    break;
  }
  default: {
    ((void)0);
    return; /* nothing to do... */
  }
  }
  e->u.info = reg;
  e->k = VNONRELOC;
}

/*
** Ensures expression value is in any register.
** (Expression still may have jump lists.)
*/
static void discharge2anyreg(FuncState *fs, expdesc *e) {
  if (e->k != VNONRELOC) {                 /* no fixed register yet? */
    luaK_reserveregs(fs, 1);               /* get a register */
    discharge2reg(fs, e, fs->freereg - 1); /* put value there */
  }
}

static int code_loadbool(FuncState *fs, int A, int b, int jump) {
  luaK_getlabel(fs); /* those instructions may be jump targets */
  return luaK_codeABCk(fs, OP_LOADBOOL, A, b, jump, 0);
}

/*
** check whether list has any jump that do not produce a value
** or produce an inverted value
*/
static int need_value(FuncState *fs, int list) {
  for (; list != (-1); list = getjump(fs, list)) {
    Instruction i = *getjumpcontrol(fs, list);
    if ((((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0))))) !=
        OP_TESTSET)
      return 1;
  }
  return 0; /* not found */
}

/*
** Ensures final expression result (which includes results from its
** jump lists) is in register 'reg'.
** If expression has jumps, need to patch these jumps either to
** its final position or to "load" instructions (for those tests
** that do not produce values).
*/
static void exp2reg(FuncState *fs, expdesc *e, int reg) {
  discharge2reg(fs, e, reg);
  if (e->k == VJMP)                    /* expression itself is a test? */
    luaK_concat(fs, &e->t, e->u.info); /* put this jump in 't' list */
  if (((e)->t != (e)->f)) {
    int final;      /* position after whole expression */
    int p_f = (-1); /* position of an eventual LOAD false */
    int p_t = (-1); /* position of an eventual LOAD true */
    if (need_value(fs, e->t) || need_value(fs, e->f)) {
      int fj = (e->k == VJMP) ? (-1) : luaK_jump(fs);
      p_f = code_loadbool(fs, reg, 0, 1); /* load false and skip next i. */
      p_t = code_loadbool(fs, reg, 1, 0); /* load true */
      /* jump around these booleans if 'e' is not a test */
      luaK_patchtohere(fs, fj);
    }
    final = luaK_getlabel(fs);
    patchlistaux(fs, e->f, final, reg, p_f);
    patchlistaux(fs, e->t, final, reg, p_t);
  }
  e->f = e->t = (-1);
  e->u.info = reg;
  e->k = VNONRELOC;
}

/*
** Ensures final expression result is in next available register.
*/
void luaK_exp2nextreg(FuncState *fs, expdesc *e) {
  luaK_dischargevars(fs, e);
  freeexp(fs, e);
  luaK_reserveregs(fs, 1);
  exp2reg(fs, e, fs->freereg - 1);
}

/*
** Ensures final expression result is in some (any) register
** and return that register.
*/
int luaK_exp2anyreg(FuncState *fs, expdesc *e) {
  luaK_dischargevars(fs, e);
  if (e->k == VNONRELOC) {          /* expression already has a register? */
    if (!((e)->t != (e)->f))        /* no jumps? */
      return e->u.info;             /* result is already in a register */
    if (e->u.info >= fs->nactvar) { /* reg. is not a local? */
      exp2reg(fs, e, e->u.info);    /* put final result in it */
      return e->u.info;
    }
  }
  luaK_exp2nextreg(fs, e); /* otherwise, use next available register */
  return e->u.info;
}

/*
** Ensures final expression result is either in a register
** or in an upvalue.
*/
void luaK_exp2anyregup(FuncState *fs, expdesc *e) {
  if (e->k != VUPVAL || ((e)->t != (e)->f))
    luaK_exp2anyreg(fs, e);
}

/*
** Ensures final expression result is either in a register
** or it is a constant.
*/
void luaK_exp2val(FuncState *fs, expdesc *e) {
  if (((e)->t != (e)->f))
    luaK_exp2anyreg(fs, e);
  else
    luaK_dischargevars(fs, e);
}

/*
** Try to make 'e' a K expression with an index in the range of R/K
** indices. Return true iff succeeded.
*/
static int luaK_exp2K(FuncState *fs, expdesc *e) {
  if (!((e)->t != (e)->f)) {
    int info;
    switch (e->k) { /* move constants to 'k' */
    case VTRUE:
      info = boolK(fs, 1);
      break;
    case VFALSE:
      info = boolK(fs, 0);
      break;
    case VNIL:
      info = nilK(fs);
      break;
    case VKINT:
      info = luaK_intK(fs, e->u.ival);
      break;
    case VKFLT:
      info = luaK_numberK(fs, e->u.nval);
      break;
    case VK:
      info = e->u.info;
      break;
    default:
      return 0; /* not a constant */
    }
    if (info <= ((1 << 8) - 1)) { /* does constant fit in 'argC'? */
      e->k = VK;                  /* make expression a 'K' expression */
      e->u.info = info;
      return 1;
    }
  }
  /* else, expression doesn't fit; leave it unchanged */
  return 0;
}

/*
** Ensures final expression result is in a valid R/K index
** (that is, it is either in a register or in 'k' with an index
** in the range of R/K indices).
** Returns 1 iff expression is K.
*/
int luaK_exp2RK(FuncState *fs, expdesc *e) {
  if (luaK_exp2K(fs, e))
    return 1;
  else { /* not a constant in the right range: put it in a register */
    luaK_exp2anyreg(fs, e);
    return 0;
  }
}

static void codeABRK(FuncState *fs, OpCode o, int a, int b, expdesc *ec) {
  int k = luaK_exp2RK(fs, ec);
  luaK_codeABCk(fs, o, a, b, ec->u.info, k);
}

/*
** Generate code to store result of expression 'ex' into variable 'var'.
*/
void luaK_storevar(FuncState *fs, expdesc *var, expdesc *ex) {
  switch (var->k) {
  case VLOCAL: {
    freeexp(fs, ex);
    exp2reg(fs, ex, var->u.info); /* compute 'ex' into proper place */
    return;
  }
  case VUPVAL: {
    int e = luaK_exp2anyreg(fs, ex);
    luaK_codeABCk(fs, OP_SETUPVAL, e, var->u.info, 0, 0);
    break;
  }
  case VINDEXUP: {
    codeABRK(fs, OP_SETTABUP, var->u.ind.t, var->u.ind.idx, ex);
    break;
  }
  case VINDEXI: {
    codeABRK(fs, OP_SETI, var->u.ind.t, var->u.ind.idx, ex);
    break;
  }
  case VINDEXSTR: {
    codeABRK(fs, OP_SETFIELD, var->u.ind.t, var->u.ind.idx, ex);
    break;
  }
  case VINDEXED: {
    codeABRK(fs, OP_SETTABLE, var->u.ind.t, var->u.ind.idx, ex);
    break;
  }
  default:
    ((void)0); /* invalid var kind to store */
  }
  freeexp(fs, ex);
}

/*
** Emit SELF instruction (convert expression 'e' into 'e:key(e,').
*/
void luaK_self(FuncState *fs, expdesc *e, expdesc *key) {
  int ereg;
  luaK_exp2anyreg(fs, e);
  ereg = e->u.info; /* register where 'e' was placed */
  freeexp(fs, e);
  e->u.info = fs->freereg; /* base register for op_self */
  e->k = VNONRELOC;        /* self expression has a fixed register */
  luaK_reserveregs(fs, 2); /* function and 'self' produced by op_self */
  codeABRK(fs, OP_SELF, e->u.info, ereg, key);
  freeexp(fs, key);
}

/*
** Negate condition 'e' (where 'e' is a comparison).
*/
static void negatecondition(FuncState *fs, expdesc *e) {
  Instruction *pc = getjumpcontrol(fs, e->u.info);
  ((void)0);
  ((*pc) = (((*pc) & (~((~((~(Instruction)0) << (1))) << (((0 + 7) + 8))))) |
            ((((Instruction)(
                  (((((int)((((*pc) >> (((0 + 7) + 8))) &
                             ((~((~(Instruction)0) << (1))) << (0))))))) ^
                   1)))
              << ((0 + 7) + 8)) &
             ((~((~(Instruction)0) << (1))) << (((0 + 7) + 8))))));
}

/*
** Emit instruction to jump if 'e' is 'cond' (that is, if 'cond'
** is true, code will jump if 'e' is true.) Return jump position.
** Optimize when 'e' is 'not' something, inverting the condition
** and removing the 'not'.
*/
static int jumponcond(FuncState *fs, expdesc *e, int cond) {
  if (e->k == VRELOC) {
    Instruction ie = ((fs)->f->code[(e)->u.info]);
    if ((((OpCode)(((ie) >> 0) & ((~((~(Instruction)0) << (7))) << (0))))) ==
        OP_NOT) {
      removelastinstruction(fs); /* remove previous OP_NOT */
      return condjump(fs, OP_TEST,
                      ((((int)((((ie) >> ((((0 + 7) + 8) + 1))) &
                                ((~((~(Instruction)0) << (8))) << (0))))))),
                      0, 0, !cond);
    }
    /* else go through */
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  return condjump(fs, OP_TESTSET, ((1 << 8) - 1), e->u.info, 0, cond);
}

/*
** Emit code to go through if 'e' is true, jump otherwise.
*/
void luaK_goiftrue(FuncState *fs, expdesc *e) {
  int pc; /* pc of new jump */
  luaK_dischargevars(fs, e);
  switch (e->k) {
  case VJMP: {              /* condition? */
    negatecondition(fs, e); /* jump when it is false */
    pc = e->u.info;         /* save jump position */
    break;
  }
  case VK:
  case VKFLT:
  case VKINT:
  case VTRUE: {
    pc = (-1); /* always true; do nothing */
    break;
  }
  default: {
    pc = jumponcond(fs, e, 0); /* jump when false */
    break;
  }
  }
  luaK_concat(fs, &e->f, pc); /* insert new jump in false list */
  luaK_patchtohere(fs, e->t); /* true list jumps to here (to go through) */
  e->t = (-1);
}

/*
** Emit code to go through if 'e' is false, jump otherwise.
*/
void luaK_goiffalse(FuncState *fs, expdesc *e) {
  int pc; /* pc of new jump */
  luaK_dischargevars(fs, e);
  switch (e->k) {
  case VJMP: {
    pc = e->u.info; /* already jump if true */
    break;
  }
  case VNIL:
  case VFALSE: {
    pc = (-1); /* always false; do nothing */
    break;
  }
  default: {
    pc = jumponcond(fs, e, 1); /* jump if true */
    break;
  }
  }
  luaK_concat(fs, &e->t, pc); /* insert new jump in 't' list */
  luaK_patchtohere(fs, e->f); /* false list jumps to here (to go through) */
  e->f = (-1);
}

/*
** Code 'not e', doing constant folding.
*/
static void codenot(FuncState *fs, expdesc *e) {
  luaK_dischargevars(fs, e);
  switch (e->k) {
  case VNIL:
  case VFALSE: {
    e->k = VTRUE; /* true == not nil == not false */
    break;
  }
  case VK:
  case VKFLT:
  case VKINT:
  case VTRUE: {
    e->k = VFALSE; /* false == not "x" == not 0.5 == not 1 == not true */
    break;
  }
  case VJMP: {
    negatecondition(fs, e);
    break;
  }
  case VRELOC:
  case VNONRELOC: {
    discharge2anyreg(fs, e);
    freeexp(fs, e);
    e->u.info = luaK_codeABCk(fs, OP_NOT, 0, e->u.info, 0, 0);
    e->k = VRELOC;
    break;
  }
  default:
    ((void)0); /* cannot happen */
  }
  /* interchange true and false lists */
  {
    int temp = e->f;
    e->f = e->t;
    e->t = temp;
  }
  removevalues(fs, e->f); /* values are useless when negated */
  removevalues(fs, e->t);
}

/*
** Check whether expression 'e' is a small literal string
*/
static int isKstr(FuncState *fs, expdesc *e) {
  return (e->k == VK && !((e)->t != (e)->f) && e->u.info <= ((1 << 8) - 1) &&
          ((((&fs->f->k[e->u.info]))->tt_) ==
           ((((4 | (1 << 4)) /* short strings */) | (1 << 6)))));
}

/*
** Check whether expression 'e' is a literal integer.
*/
int luaK_isKint(expdesc *e) { return (e->k == VKINT && !((e)->t != (e)->f)); }

/*
** Check whether expression 'e' is a literal integer in
** proper range to fit in register C
*/
static int isCint(expdesc *e) {
  return luaK_isKint(e) &&
         (((lua_Unsigned)(e->u.ival)) <= ((lua_Unsigned)(((1 << 8) - 1))));
}

/*
** Check whether expression 'e' is a literal integer in
** proper range to fit in register sC
*/
static int isSCint(expdesc *e) { return luaK_isKint(e) && fitsC(e->u.ival); }

/*
** Check whether expression 'e' is a literal integer or float in
** proper range to fit in a register (sB or sC).
*/
static int isSCnumber(expdesc *e, lua_Integer *i, int *isfloat) {
  if (e->k == VKINT)
    *i = e->u.ival;
  else if (!(e->k == VKFLT && floatI(e->u.nval, i)))
    return 0; /* not a number */
  else
    *isfloat = 1;
  if (!((e)->t != (e)->f) && fitsC(*i)) {
    *i += (((1 << 8) - 1) >> 1);
    return 1;
  } else
    return 0;
}

/*
** Create expression 't[k]'. 't' must have its final result already in a
** register or upvalue. Upvalues can only be indexed by literal strings.
** Keys can be literal strings in the constant table or arbitrary
** values in registers.
*/
void luaK_indexed(FuncState *fs, expdesc *t, expdesc *k) {
  ((void)0);
  if (t->k == VUPVAL && !isKstr(fs, k)) /* upvalue indexed by non string? */
    luaK_exp2anyreg(fs, t);             /* put it in a register */
  t->u.ind.t = t->u.info;               /* register or upvalue index */
  if (t->k == VUPVAL) {
    t->u.ind.idx = k->u.info; /* literal string */
    t->k = VINDEXUP;
  } else if (isKstr(fs, k)) {
    t->u.ind.idx = k->u.info; /* literal string */
    t->k = VINDEXSTR;
  } else if (isCint(k)) {
    t->u.ind.idx = ((int)((k->u.ival))); /* integer constant in proper range */
    t->k = VINDEXI;
  } else {
    t->u.ind.idx = luaK_exp2anyreg(fs, k); /* register */
    t->k = VINDEXED;
  }
}

/*
** Return false if folding can raise an error.
** Bitwise operations need operands convertible to integers; division
** operations cannot have 0 as divisor.
*/
static int validop(int op, TValue *v1, TValue *v2) {
  switch (op) {
  case 7:
  case 8:
  case 9:
  case 10:
  case 11:
  case 13: { /* conversion errors */
    lua_Integer i;
    return ((((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                 ? (*(&i) = (((v1)->value_).i), 1)
                 : luaV_tointegerns(v1, &i, 0)) &&
            (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                 ? (*(&i) = (((v2)->value_).i), 1)
                 : luaV_tointegerns(v2, &i, 0)));
  }
  case 5:
  case 6:
  case 3: /* division by 0 */
    return (((((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                  ? ((lua_Number)(((((v2)->value_).i))))
                  : (((v2)->value_).n))) != 0);
  default:
    return 1; /* everything else is valid */
  }
}

/*
** Try to "constant-fold" an operation; return 1 iff successful.
** (In this case, 'e1' has the final result.)
*/
static int constfolding(FuncState *fs, int op, expdesc *e1, const expdesc *e2) {
  TValue v1, v2, res;
  if (!tonumeral(e1, &v1) || !tonumeral(e2, &v2) || !validop(op, &v1, &v2))
    return 0; /* non-numeric operands or not safe to fold */
  luaO_rawarith(fs->ls->L, op, &v1, &v2, &res); /* does operation */
  if (((((&res))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
    e1->k = VKINT;
    e1->u.ival = (((&res)->value_).i);
  } else { /* folds neither NaN nor 0.0 (to avoid problems with -0.0) */
    lua_Number n = (((&res)->value_).n);
    if ((!(((n)) == ((n)))) || n == 0)
      return 0;
    e1->k = VKFLT;
    e1->u.nval = n;
  }
  return 1;
}

/*
** Emit code for unary expressions that "produce values"
** (everything but 'not').
** Expression to produce final result will be encoded in 'e'.
*/
static void codeunexpval(FuncState *fs, OpCode op, expdesc *e, int line) {
  int r = luaK_exp2anyreg(fs, e); /* opcodes operate only on registers */
  freeexp(fs, e);
  e->u.info = luaK_codeABCk(fs, op, 0, r, 0, 0); /* generate opcode */
  e->k = VRELOC; /* all those operations are relocatable */
  luaK_fixline(fs, line);
}

/*
** Emit code for binary expressions that "produce values"
** (everything but logical operators 'and'/'or' and comparison
** operators).
** Expression to produce final result will be encoded in 'e1'.
** Because 'luaK_exp2anyreg' can free registers, its calls must be
** in "stack order" (that is, first on 'e2', which may have more
** recent registers to be released).
*/
static void finishbinexpval(FuncState *fs, expdesc *e1, expdesc *e2, OpCode op,
                            int v2, int k, int line) {
  int v1 = luaK_exp2anyreg(fs, e1);
  int pc = luaK_codeABCk(fs, op, 0, v1, v2, k);
  freeexps(fs, e1, e2);
  e1->u.info = pc;
  e1->k = VRELOC; /* all those operations are relocatable */
  luaK_fixline(fs, line);
}

/*
** Emit code for binary expressions that "produce values" over
** two registers.
*/
static void codebinexpval(FuncState *fs, OpCode op, expdesc *e1, expdesc *e2,
                          int line) {
  int v2 = luaK_exp2anyreg(fs, e2); /* both operands are in registers */
  finishbinexpval(fs, e1, e2, op, v2, 0, line);
}

/*
** Code binary operators ('+', '-', ...) with immediate operands.
*/
static void codebini(FuncState *fs, OpCode op, expdesc *e1, expdesc *e2, int k,
                     int line) {
  int v2 =
      ((int)((e2->u.ival))) + (((1 << 8) - 1) >> 1); /* immediate operand */
  finishbinexpval(fs, e1, e2, op, v2, k, line);
}

static void swapexps(expdesc *e1, expdesc *e2) {
  expdesc temp = *e1;
  *e1 = *e2;
  *e2 = temp; /* swap 'e1' and 'e2' */
}

/*
** Code arithmetic operators ('+', '-', ...). If second operand is a
** constant in the proper range, use variant opcodes with immediate
** operands or K operands.
*/
static void codearith(FuncState *fs, OpCode op, expdesc *e1, expdesc *e2,
                      int flip, int line) {
  if (isSCint(e2)) /* immediate operand? */
    codebini(fs, ((OpCode)(op - OP_ADD + OP_ADDI)), e1, e2, flip, line);
  else if (tonumeral(e2, ((void *)0)) && luaK_exp2K(fs, e2)) { /* K operand? */
    int v2 = e2->u.info;                                       /* K index */
    op = ((OpCode)(op - OP_ADD + OP_ADDK));
    finishbinexpval(fs, e1, e2, op, v2, flip, line);
  } else { /* 'e2' is neither an immediate nor a K operand */
    if (flip)
      swapexps(e1, e2);                  /* back to original order */
    codebinexpval(fs, op, e1, e2, line); /* use standard operators */
  }
}

/*
** Code commutative operators ('+', '*'). If first operand is a
** numeric constant, change order of operands to try to use an
** immediate or K operator.
*/
static void codecommutative(FuncState *fs, OpCode op, expdesc *e1, expdesc *e2,
                            int line) {
  int flip = 0;
  if (tonumeral(e1, ((void *)0))) { /* is first operand a numeric constant? */
    swapexps(e1, e2);               /* change order */
    flip = 1;
  }
  codearith(fs, op, e1, e2, flip, line);
}

/*
** Code bitwise operations; they are all associative, so the function
** tries to put an integer constant as the 2nd operand (a K operand).
*/
static void codebitwise(FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2,
                        int line) {
  int inv = 0;
  int v2;
  OpCode op;
  if (e1->k == VKINT && luaK_exp2RK(fs, e1)) {
    swapexps(e1, e2); /* 'e2' will be the constant operand */
    inv = 1;
  } else if (!(e2->k == VKINT && luaK_exp2RK(fs, e2))) { /* no constants? */
    op = ((OpCode)(opr - OPR_BAND + OP_BAND));
    codebinexpval(fs, op, e1, e2, line); /* all-register opcodes */
    return;
  }
  v2 = e2->u.info; /* index in K array */
  op = ((OpCode)(opr - OPR_BAND + OP_BANDK));
  ((void)0);
  finishbinexpval(fs, e1, e2, op, v2, inv, line);
}

/*
** Code shift operators. If second operand is constant, use immediate
** operand (negating it if shift is in the other direction).
*/
static void codeshift(FuncState *fs, OpCode op, expdesc *e1, expdesc *e2,
                      int line) {
  if (isSCint(e2)) {
    int changedir = 0;
    if (op == OP_SHL) {
      changedir = 1;
      e2->u.ival = -(e2->u.ival);
    }
    codebini(fs, OP_SHRI, e1, e2, changedir, line);
  } else
    codebinexpval(fs, op, e1, e2, line);
}

/*
** Emit code for order comparisons. When using an immediate operand,
** 'isfloat' tells whether the original value was a float.
*/
static void codeorder(FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {
  int r1, r2;
  lua_Integer im;
  int isfloat = 0;
  if (isSCnumber(e2, &im, &isfloat)) {
    /* use immediate operand */
    r1 = luaK_exp2anyreg(fs, e1);
    r2 = ((int)((im)));
    op = ((OpCode)((op - OP_LT) + OP_LTI));
  } else if (isSCnumber(e1, &im, &isfloat)) {
    /* transform (A < B) to (B > A) and (A <= B) to (B >= A) */
    r1 = luaK_exp2anyreg(fs, e2);
    r2 = ((int)((im)));
    op = (op == OP_LT) ? OP_GTI : OP_GEI;
  } else { /* regular case, compare two registers */
    r1 = luaK_exp2anyreg(fs, e1);
    r2 = luaK_exp2anyreg(fs, e2);
  }
  freeexps(fs, e1, e2);
  e1->u.info = condjump(fs, op, r1, r2, isfloat, 1);
  e1->k = VJMP;
}

/*
** Emit code for equality comparisons ('==', '~=').
** 'e1' was already put as RK by 'luaK_infix'.
*/
static void codeeq(FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {
  int r1, r2;
  lua_Integer im;
  int isfloat = 0; /* not needed here, but kept for symmetry */
  OpCode op;
  if (e1->k != VNONRELOC) {
    ((void)0);
    swapexps(e1, e2);
  }
  r1 = luaK_exp2anyreg(fs, e1); /* 1nd expression must be in register */
  if (isSCnumber(e2, &im, &isfloat)) {
    op = OP_EQI;
    r2 = ((int)((im)));             /* immediate operand */
  } else if (luaK_exp2RK(fs, e2)) { /* 1st expression is constant? */
    op = OP_EQK;
    r2 = e2->u.info; /* constant index */
  } else {
    op = OP_EQ; /* will compare two registers */
    r2 = luaK_exp2anyreg(fs, e2);
  }
  freeexps(fs, e1, e2);
  e1->u.info = condjump(fs, op, r1, r2, isfloat, (opr == OPR_EQ));
  e1->k = VJMP;
}

/*
** Apply prefix operation 'op' to expression 'e'.
*/
void luaK_prefix(FuncState *fs, UnOpr op, expdesc *e, int line) {
  static const expdesc ef = {VKINT, {0}, (-1), (-1)};
  switch (op) {
  case OPR_MINUS:
  case OPR_BNOT: /* use 'ef' as fake 2nd operand */
    if (constfolding(fs, op + 12, e, &ef))
      break;
    /* FALLTHROUGH */
  case OPR_LEN:
    codeunexpval(fs, ((OpCode)(op + OP_UNM)), e, line);
    break;
  case OPR_NOT:
    codenot(fs, e);
    break;
  default:
    ((void)0);
  }
}

/*
** Process 1st operand 'v' of binary operation 'op' before reading
** 2nd operand.
*/
void luaK_infix(FuncState *fs, BinOpr op, expdesc *v) {
  switch (op) {
  case OPR_AND: {
    luaK_goiftrue(fs, v); /* go ahead only if 'v' is true */
    break;
  }
  case OPR_OR: {
    luaK_goiffalse(fs, v); /* go ahead only if 'v' is false */
    break;
  }
  case OPR_CONCAT: {
    luaK_exp2nextreg(fs, v); /* operand must be on the stack */
    break;
  }
  case OPR_ADD:
  case OPR_SUB:
  case OPR_MUL:
  case OPR_DIV:
  case OPR_IDIV:
  case OPR_MOD:
  case OPR_POW:
  case OPR_BAND:
  case OPR_BOR:
  case OPR_BXOR:
  case OPR_SHL:
  case OPR_SHR: {
    if (!tonumeral(v, ((void *)0)))
      luaK_exp2anyreg(fs, v);
    /* else keep numeral, which may be folded with 2nd operand */
    break;
  }
  case OPR_EQ:
  case OPR_NE: {
    if (!tonumeral(v, ((void *)0)))
      luaK_exp2RK(fs, v);
    /* else keep numeral, which may be an immediate operand */
    break;
  }
  case OPR_LT:
  case OPR_LE:
  case OPR_GT:
  case OPR_GE: {
    lua_Integer dummy;
    int dummy2;
    if (!isSCnumber(v, &dummy, &dummy2))
      luaK_exp2anyreg(fs, v);
    /* else keep numeral, which may be an immediate operand */
    break;
  }
  default:
    ((void)0);
  }
}

/*
** Create code for '(e1 .. e2)'.
** For '(e1 .. e2.1 .. e2.2)' (which is '(e1 .. (e2.1 .. e2.2))',
** because concatenation is right associative), merge both CONCATs.
*/
static void codeconcat(FuncState *fs, expdesc *e1, expdesc *e2, int line) {
  Instruction *ie2 = previousinstruction(fs);
  if ((((OpCode)(((*ie2) >> 0) & ((~((~(Instruction)0) << (7))) << (0))))) ==
      OP_CONCAT) { /* is 'e2' a concatenation? */
    int n = ((((int)((((*ie2) >> ((((0 + 7) + 8) + 1))) &
                      ((~((~(Instruction)0) << (8)))
                       << (0))))))); /* # of elements concatenated in 'e2' */
    ((void)0);
    freeexp(fs, e2);
    ((*ie2) = (((*ie2) & (~((~((~(Instruction)0) << (8))) << ((0 + 7))))) |
               ((((Instruction)(e1->u.info)) << (0 + 7)) &
                ((~((~(Instruction)0) << (8)))
                 << ((0 + 7)))))); /* correct first element ('e1') */
    ((*ie2) =
         (((*ie2) &
           (~((~((~(Instruction)0) << (8))) << ((((0 + 7) + 8) + 1))))) |
          ((((Instruction)(n + 1)) << (((0 + 7) + 8) + 1)) &
           ((~((~(Instruction)0) << (8))) << ((
                ((0 + 7) + 8) + 1)))))); /* will concatenate one more element */
  } else {                               /* 'e2' is not a concatenation */
    luaK_codeABCk(fs, OP_CONCAT, e1->u.info, 2, 0, 0); /* new concat opcode */
    freeexp(fs, e2);
    luaK_fixline(fs, line);
  }
}

/*
** Finalize code for binary operation, after reading 2nd operand.
*/
void luaK_posfix(FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2,
                 int line) {
  switch (opr) {
  case OPR_AND: {
    ((void)0); /* list closed by 'luK_infix' */
    luaK_dischargevars(fs, e2);
    luaK_concat(fs, &e2->f, e1->f);
    *e1 = *e2;
    break;
  }
  case OPR_OR: {
    ((void)0); /* list closed by 'luK_infix' */
    luaK_dischargevars(fs, e2);
    luaK_concat(fs, &e2->t, e1->t);
    *e1 = *e2;
    break;
  }
  case OPR_CONCAT: { /* e1 .. e2 */
    luaK_exp2nextreg(fs, e2);
    codeconcat(fs, e1, e2, line);
    break;
  }
  case OPR_ADD:
  case OPR_MUL: {
    if (!constfolding(fs, opr + 0 /* ORDER TM, ORDER OP */, e1, e2))
      codecommutative(fs, ((OpCode)(opr + OP_ADD)), e1, e2, line);
    break;
  }
  case OPR_SUB:
  case OPR_DIV:
  case OPR_IDIV:
  case OPR_MOD:
  case OPR_POW: {
    if (!constfolding(fs, opr + 0 /* ORDER TM, ORDER OP */, e1, e2))
      codearith(fs, ((OpCode)(opr + OP_ADD)), e1, e2, 0, line);
    break;
  }
  case OPR_BAND:
  case OPR_BOR:
  case OPR_BXOR: {
    if (!constfolding(fs, opr + 0 /* ORDER TM, ORDER OP */, e1, e2))
      codebitwise(fs, opr, e1, e2, line);
    break;
  }
  case OPR_SHL: {
    if (!constfolding(fs, 10, e1, e2)) {
      if (isSCint(e1)) {
        swapexps(e1, e2);
        codebini(fs, OP_SHLI, e1, e2, 1, line);
      } else
        codeshift(fs, OP_SHL, e1, e2, line);
    }
    break;
  }
  case OPR_SHR: {
    if (!constfolding(fs, 11, e1, e2))
      codeshift(fs, OP_SHR, e1, e2, line);
    break;
  }
  case OPR_EQ:
  case OPR_NE: {
    codeeq(fs, opr, e1, e2);
    break;
  }
  case OPR_LT:
  case OPR_LE: {
    OpCode op = ((OpCode)((opr - OPR_EQ) + OP_EQ));
    codeorder(fs, op, e1, e2);
    break;
  }
  case OPR_GT:
  case OPR_GE: {
    /* '(a > b)' <=> '(b < a)';  '(a >= b)' <=> '(b <= a)' */
    OpCode op = ((OpCode)((opr - OPR_NE) + OP_EQ));
    swapexps(e1, e2);
    codeorder(fs, op, e1, e2);
    break;
  }
  default:
    ((void)0);
  }
}

/*
** Change line information associated with current position, by removing
** previous info and adding it again with new line.
*/
void luaK_fixline(FuncState *fs, int line) {
  removelastlineinfo(fs);
  savelineinfo(fs, fs->f, line);
}

/*
** Emit a SETLIST instruction.
** 'base' is register that keeps table;
** 'nelems' is #table plus those to be stored now;
** 'tostore' is number of values (in registers 'base + 1',...) to add to
** table (or LUA_MULTRET to add up to stack top).
*/
void luaK_setlist(FuncState *fs, int base, int nelems, int tostore) {
  int c = (nelems - 1) / 50 + 1;
  int b = (tostore == (-1)) ? 0 : tostore;
  ((void)0);
  if (c <= ((1 << 8) - 1))
    luaK_codeABCk(fs, OP_SETLIST, base, b, c, 0);
  else if (c <= ((1 << ((8 + 8 + 1) + 8)) - 1)) {
    luaK_codeABCk(fs, OP_SETLIST, base, b, 0, 0);
    codeextraarg(fs, c);
  } else
    luaX_syntaxerror(fs->ls, "constructor too long");
  fs->freereg = base + 1; /* free registers with list values */
}

/*
** return the final target of a jump (skipping jumps to jumps)
*/
static int finaltarget(Instruction *code, int i) {
  int count;
  for (count = 0; count < 100; count++) { /* avoid infinite loops */
    Instruction pc = code[i];
    if ((((OpCode)(((pc) >> 0) & ((~((~(Instruction)0) << (7))) << (0))))) !=
        OP_JMP)
      break;
    else
      i +=
          ((((int)((((pc) >> ((0 + 7))) &
                    ((~((~(Instruction)0) << (((8 + 8 + 1) + 8)))) << (0)))))) -
           (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
          1;
  }
  return i;
}

/*
** Do a final pass over the code of a function, doing small peephole
** optimizations and adjustments.
*/
void luaK_finish(FuncState *fs) {
  int i;
  Proto *p = fs->f;
  for (i = 0; i < fs->pc; i++) {
    Instruction *pc = &p->code[i];
    ((void)0);
    switch (
        (((OpCode)(((*pc) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))) {
    case OP_RETURN0:
    case OP_RETURN1: {
      if (!(fs->needclose || p->is_vararg))
        break; /* no extra work */
      /* else use OP_RETURN to do the extra work */
      ((*pc) = (((*pc) & (~((~((~(Instruction)0) << (7))) << (0)))) |
                ((((Instruction)(OP_RETURN)) << 0) &
                 ((~((~(Instruction)0) << (7))) << (0)))));
    } /* FALLTHROUGH */
    case OP_RETURN:
    case OP_TAILCALL: {
      if (fs->needclose || p->is_vararg) {
        ((*pc) = (((*pc) & (~((~((~(Instruction)0) << (8)))
                              << (((((0 + 7) + 8) + 1) + 8))))) |
                  ((((Instruction)(p->is_vararg ? p->numparams + 1 : 0))
                    << ((((0 + 7) + 8) + 1) + 8)) &
                   ((~((~(Instruction)0) << (8)))
                    << (((((0 + 7) + 8) + 1) + 8))))));
        ((*pc) =
             (((*pc) & (~((~((~(Instruction)0) << (1))) << (((0 + 7) + 8))))) |
              ((((Instruction)(1)) << ((0 + 7) + 8)) &
               ((~((~(Instruction)0) << (1)))
                << (((0 + 7) + 8)))))); /* signal that there is extra work */
      }
      break;
    }
    case OP_JMP: {
      int target = finaltarget(p->code, i);
      fixjump(fs, i, target);
      break;
    }
    default:
      break;
    }
  }
}
/*
** $Id: lparser.c $
** Lua Parser
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lcode.h $
** Code generator for Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lfunc.h $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/
/*
** $Id: llex.h $
** Lexical Analyzer
** See Copyright Notice in lua.h
*/
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lopcodes.h $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/
/*
** $Id: lparser.h $
** Lua Parser
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltable.h $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/

/* maximum number of local variables per function (must be smaller
   than 250, due to the bytecode format) */

/* because all strings are unified by the scanner, the parser
   can use pointer equality for string equality */

/*
** nodes for block list (list of active blocks)
*/
typedef struct BlockCnt {
  struct BlockCnt *previous; /* chain */
  int firstlabel;            /* index of first label in this block */
  int firstgoto;             /* index of first pending goto in this block */
  lu_byte nactvar;           /* # active locals outside the block */
  lu_byte upval;     /* true if some variable in the block is an upvalue */
  lu_byte isloop;    /* true if 'block' is a loop */
  lu_byte insidetbc; /* true if inside the scope of a to-be-closed var. */
} BlockCnt;

/*
** prototypes for recursive non-terminal functions
*/
static void statement(LexState *ls);
static void expr(LexState *ls, expdesc *v);

static void __attribute__((noreturn)) error_expected(LexState *ls, int token) {
  luaX_syntaxerror(
      ls, luaO_pushfstring(ls->L, "%s expected", luaX_token2str(ls, token)));
}

static void __attribute__((noreturn))
errorlimit(FuncState *fs, int limit, const char *what) {
  lua_State *L = fs->ls->L;
  const char *msg;
  int line = fs->f->linedefined;
  const char *where = (line == 0)
                          ? "main function"
                          : luaO_pushfstring(L, "function at line %d", line);
  msg = luaO_pushfstring(L, "too many %s (limit is %d) in %s", what, limit,
                         where);
  luaX_syntaxerror(fs->ls, msg);
}

static void checklimit(FuncState *fs, int v, int l, const char *what) {
  if (v > l)
    errorlimit(fs, l, what);
}

/*
** Test whether next token is 'c'; if so, skip it.
*/
static int testnext(LexState *ls, int c) {
  if (ls->t.token == c) {
    luaX_next(ls);
    return 1;
  } else
    return 0;
}

/*
** Check that next token is 'c'.
*/
static void check(LexState *ls, int c) {
  if (ls->t.token != c)
    error_expected(ls, c);
}

/*
** Check that next token is 'c' and skip it.
*/
static void checknext(LexState *ls, int c) {
  check(ls, c);
  luaX_next(ls);
}

/*
** Check that next token is 'what' and skip it. In case of error,
** raise an error that the expected 'what' should match a 'who'
** in line 'where' (if that is not the current line).
*/
static void check_match(LexState *ls, int what, int who, int where) {
  if ((__builtin_expect(((!testnext(ls, what)) != 0), 0))) {
    if (where == ls->linenumber) /* all in the same line? */
      error_expected(ls, what);  /* do not need a complex message */
    else {
      luaX_syntaxerror(
          ls, luaO_pushfstring(ls->L, "%s expected (to close %s at line %d)",
                               luaX_token2str(ls, what),
                               luaX_token2str(ls, who), where));
    }
  }
}

static TString *str_checkname(LexState *ls) {
  TString *ts;
  check(ls, TK_NAME);
  ts = ls->t.seminfo.ts;
  luaX_next(ls);
  return ts;
}

static void init_exp(expdesc *e, expkind k, int i) {
  e->f = e->t = (-1);
  e->k = k;
  e->u.info = i;
}

static void codestring(LexState *ls, expdesc *e, TString *s) {
  init_exp(e, VK, luaK_stringK(ls->fs, s));
}

static void codename(LexState *ls, expdesc *e) {
  codestring(ls, e, str_checkname(ls));
}

/*
** Register a new local variable in the active 'Proto' (for debug
** information).
*/
static int registerlocalvar(LexState *ls, TString *varname) {
  FuncState *fs = ls->fs;
  Proto *f = fs->f;
  int oldsize = f->sizelocvars;
  ((f->locvars) = ((LocVar *)(luaM_growaux_(
       ls->L, f->locvars, fs->nlocvars, &(f->sizelocvars), sizeof(LocVar),
       ((((size_t)((32767))) <= ((size_t)(~(size_t)0)) / sizeof(LocVar))
            ? (32767)
            : ((unsigned int)(((((size_t)(~(size_t)0)) / sizeof(LocVar)))))),
       "local variables"))));
  while (oldsize < f->sizelocvars)
    f->locvars[oldsize++].varname = ((void *)0);
  f->locvars[fs->nlocvars].varname = varname;
  (((((f)->marked) & ((1 << (5 /* object is black */)))) &&
    (((varname)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                             (1 << (4 /* object is white (type 1) */))))))
       ? luaC_barrier_(ls->L, (&(((union GCUnion *)((f)))->gc)),
                       (&(((union GCUnion *)((varname)))->gc)))
       : ((void)((0))));
  return fs->nlocvars++;
}

/*
** Create a new local variable with the given 'name'.
*/
static void new_localvar(LexState *ls, TString *name) {
  FuncState *fs = ls->fs;
  Dyndata *dyd = ls->dyd;
  int reg = registerlocalvar(ls, name);
  checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal, 200, "local variables");
  ((dyd->actvar.arr) = ((Vardesc *)(luaM_growaux_(
       ls->L, dyd->actvar.arr, dyd->actvar.n + 1, &(dyd->actvar.size),
       sizeof(Vardesc),
       ((((size_t)((0x7fffffff /* maximum value of an int */))) <=
         ((size_t)(~(size_t)0)) / sizeof(Vardesc))
            ? (0x7fffffff /* maximum value of an int */)
            : ((unsigned int)(((((size_t)(~(size_t)0)) / sizeof(Vardesc)))))),
       "local variables"))));
  dyd->actvar.arr[dyd->actvar.n++].idx = ((short)(reg));
}

/*
** Get the debug-information entry for current variable 'i'.
*/
static LocVar *getlocvar(FuncState *fs, int i) {
  int idx = fs->ls->dyd->actvar.arr[fs->firstlocal + i].idx;
  ((void)0);
  return &fs->f->locvars[idx];
}

/*
** Start the scope for the last 'nvars' created variables.
** (debug info.)
*/
static void adjustlocalvars(LexState *ls, int nvars) {
  FuncState *fs = ls->fs;
  fs->nactvar = ((lu_byte)((fs->nactvar + nvars)));
  for (; nvars; nvars--) {
    getlocvar(fs, fs->nactvar - nvars)->startpc = fs->pc;
  }
}

/*
** Close the scope for all variables up to level 'tolevel'.
** (debug info.)
*/
static void removevars(FuncState *fs, int tolevel) {
  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);
  while (fs->nactvar > tolevel)
    getlocvar(fs, --fs->nactvar)->endpc = fs->pc;
}

/*
** Search the upvalues of the function 'fs' for one
** with the given 'name'.
*/
static int searchupvalue(FuncState *fs, TString *name) {
  int i;
  Upvaldesc *up = fs->f->upvalues;
  for (i = 0; i < fs->nups; i++) {
    if (((up[i].name) == (name)))
      return i;
  }
  return -1; /* not found */
}

static int newupvalue(FuncState *fs, TString *name, expdesc *v) {
  Proto *f = fs->f;
  int oldsize = f->sizeupvalues;
  checklimit(fs, fs->nups + 1, 255, "upvalues");
  ((f->upvalues) = ((Upvaldesc *)(luaM_growaux_(
       fs->ls->L, f->upvalues, fs->nups, &(f->sizeupvalues), sizeof(Upvaldesc),
       ((((size_t)((255))) <= ((size_t)(~(size_t)0)) / sizeof(Upvaldesc))
            ? (255)
            : ((unsigned int)(((((size_t)(~(size_t)0)) / sizeof(Upvaldesc)))))),
       "upvalues"))));
  while (oldsize < f->sizeupvalues)
    f->upvalues[oldsize++].name = ((void *)0);
  f->upvalues[fs->nups].instack = (v->k == VLOCAL);
  f->upvalues[fs->nups].idx = ((lu_byte)((v->u.info)));
  f->upvalues[fs->nups].name = name;
  (((((f)->marked) & ((1 << (5 /* object is black */)))) &&
    (((name)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                          (1 << (4 /* object is white (type 1) */))))))
       ? luaC_barrier_(fs->ls->L, (&(((union GCUnion *)((f)))->gc)),
                       (&(((union GCUnion *)((name)))->gc)))
       : ((void)((0))));
  return fs->nups++;
}

/*
** Look for an active local variable with the name 'n' in the
** function 'fs'.
*/
static int searchvar(FuncState *fs, TString *n) {
  int i;
  for (i = ((int)((fs->nactvar))) - 1; i >= 0; i--) {
    if (((n) == (getlocvar(fs, i)->varname)))
      return i;
  }
  return -1; /* not found */
}

/*
** Mark block where variable at given level was defined
** (to emit close instructions later).
*/
static void markupval(FuncState *fs, int level) {
  BlockCnt *bl = fs->bl;
  while (bl->nactvar > level)
    bl = bl->previous;
  bl->upval = 1;
  fs->needclose = 1;
}

/*
** Find a variable with the given name 'n'. If it is an upvalue, add
** this upvalue into all intermediate functions. If it is a global, set
** 'var' as 'void' as a flag.
*/
static void singlevaraux(FuncState *fs, TString *n, expdesc *var, int base) {
  if (fs == ((void *)0))     /* no more levels? */
    init_exp(var, VVOID, 0); /* default is global */
  else {
    int v = searchvar(fs, n);   /* look up locals at current level */
    if (v >= 0) {               /* found? */
      init_exp(var, VLOCAL, v); /* variable is local */
      if (!base)
        markupval(fs, v); /* local will be used as an upval */
    } else { /* not found as local at current level; try upvalues */
      int idx = searchupvalue(fs, n);      /* try existing upvalues */
      if (idx < 0) {                       /* not found? */
        singlevaraux(fs->prev, n, var, 0); /* try upper levels */
        if (var->k == VVOID)               /* not found? */
          return;                          /* it is a global */
        /* else was LOCAL or UPVAL */
        idx = newupvalue(fs, n, var); /* will be a new upvalue */
      }
      init_exp(var, VUPVAL, idx); /* new or old upvalue */
    }
  }
}

/*
** Find a variable with the given name 'n', handling global variables
** too.
*/
static void singlevar(LexState *ls, expdesc *var) {
  TString *varname = str_checkname(ls);
  FuncState *fs = ls->fs;
  singlevaraux(fs, varname, var, 1);
  if (var->k == VVOID) { /* global name? */
    expdesc key;
    singlevaraux(fs, ls->envn, var, 1); /* get environment variable */
    ((void)0);                          /* this one must exist */
    codestring(ls, &key, varname);      /* key is variable name */
    luaK_indexed(fs, var, &key);        /* env[varname] */
  }
}

/*
** Adjust the number of results from an expression list 'e' with 'nexps'
** expressions to 'nvars' values.
*/
static void adjust_assign(LexState *ls, int nvars, int nexps, expdesc *e) {
  FuncState *fs = ls->fs;
  int needed = nvars - nexps; /* extra values needed */
  if (((e->k) == VCALL ||
       (e->k) == VVARARG)) { /* last expression has multiple returns? */
    int extra = needed + 1;  /* discount last expression itself */
    if (extra < 0)
      extra = 0;
    luaK_setreturns(fs, e, extra); /* last exp. provides the difference */
  } else {
    if (e->k != VVOID)                   /* at least one expression? */
      luaK_exp2nextreg(fs, e);           /* close last expression */
    if (needed > 0)                      /* missing values? */
      luaK_nil(fs, fs->freereg, needed); /* complete with nils */
  }
  if (needed > 0)
    luaK_reserveregs(fs, needed); /* registers for extra values */
  else                     /* adding 'needed' is actually a subtraction */
    fs->freereg += needed; /* remove extra values */
}

/*
** Macros to limit the maximum recursion depth while parsing
*/

/*
** Generates an error that a goto jumps into the scope of some
** local variable.
*/
static void __attribute__((noreturn))
jumpscopeerror(LexState *ls, Labeldesc *gt) {
  const char *varname =
      (((char *)(((getlocvar(ls->fs, gt->nactvar)->varname)))) +
       sizeof(TString));
  const char *msg = "<goto %s> at line %d jumps into the scope of local '%s'";
  msg =
      luaO_pushfstring(ls->L, msg, (((char *)(((gt->name)))) + sizeof(TString)),
                       gt->line, varname);
  luaK_semerror(ls, msg); /* raise the error */
}

/*
** Solves the goto at index 'g' to given 'label' and removes it
** from the list of pending goto's.
** If it jumps into the scope of some variable, raises an error.
*/
static void solvegoto(LexState *ls, int g, Labeldesc *label) {
  int i;
  Labellist *gl = &ls->dyd->gt; /* list of goto's */
  Labeldesc *gt = &gl->arr[g];  /* goto to be resolved */
  ((void)0);
  if ((__builtin_expect(((gt->nactvar < label->nactvar) != 0),
                        0))) /* enter some scope? */
    jumpscopeerror(ls, gt);
  luaK_patchlist(ls->fs, gt->pc, label->pc);
  for (i = g; i < gl->n - 1; i++) /* remove goto from pending list */
    gl->arr[i] = gl->arr[i + 1];
  gl->n--;
}

/*
** Search for an active label with the given name.
*/
static Labeldesc *findlabel(LexState *ls, TString *name) {
  int i;
  Dyndata *dyd = ls->dyd;
  /* check labels in current function for a match */
  for (i = ls->fs->firstlabel; i < dyd->label.n; i++) {
    Labeldesc *lb = &dyd->label.arr[i];
    if (((lb->name) == (name))) /* correct label? */
      return lb;
  }
  return ((void *)0); /* label not found */
}

/*
** Adds a new label/goto in the corresponding list.
*/
static int newlabelentry(LexState *ls, Labellist *l, TString *name, int line,
                         int pc) {
  int n = l->n;
  ((l->arr) = ((Labeldesc *)(luaM_growaux_(
       ls->L, l->arr, n, &(l->size), sizeof(Labeldesc),
       ((((size_t)((32767))) <= ((size_t)(~(size_t)0)) / sizeof(Labeldesc))
            ? (32767)
            : ((unsigned int)(((((size_t)(~(size_t)0)) / sizeof(Labeldesc)))))),
       "labels/gotos"))));
  l->arr[n].name = name;
  l->arr[n].line = line;
  l->arr[n].nactvar = ls->fs->nactvar;
  l->arr[n].close = 0;
  l->arr[n].pc = pc;
  l->n = n + 1;
  return n;
}

static int newgotoentry(LexState *ls, TString *name, int line, int pc) {
  return newlabelentry(ls, &ls->dyd->gt, name, line, pc);
}

/*
** Solves forward jumps. Check whether new label 'lb' matches any
** pending gotos in current block and solves them. Return true
** if any of the goto's need to close upvalues.
*/
static int solvegotos(LexState *ls, Labeldesc *lb) {
  Labellist *gl = &ls->dyd->gt;
  int i = ls->fs->bl->firstgoto;
  int needsclose = 0;
  while (i < gl->n) {
    if (((gl->arr[i].name) == (lb->name))) {
      needsclose |= gl->arr[i].close;
      solvegoto(ls, i, lb); /* will remove 'i' from the list */
    } else
      i++;
  }
  return needsclose;
}

/*
** Create a new label with the given 'name' at the given 'line'.
** 'last' tells whether label is the last non-op statement in its
** block. Solves all pending goto's to this new label and adds
** a close instruction if necessary.
** Returns true iff it added a close instruction.
*/
static int createlabel(LexState *ls, TString *name, int line, int last) {
  FuncState *fs = ls->fs;
  Labellist *ll = &ls->dyd->label;
  int l = newlabelentry(ls, ll, name, line, luaK_getlabel(fs));
  if (last) { /* label is last no-op statement in the block? */
    /* assume that locals are already out of scope */
    ll->arr[l].nactvar = fs->bl->nactvar;
  }
  if (solvegotos(ls, &ll->arr[l])) { /* need close? */
    luaK_codeABCk(fs, OP_CLOSE, fs->nactvar, 0, 0, 0);
    return 1;
  }
  return 0;
}

/*
** Adjust pending gotos to outer level of a block.
*/
static void movegotosout(FuncState *fs, BlockCnt *bl) {
  int i;
  Labellist *gl = &fs->ls->dyd->gt;
  /* correct pending gotos to current block */
  for (i = bl->firstgoto; i < gl->n; i++) { /* for each pending goto */
    Labeldesc *gt = &gl->arr[i];
    if (gt->nactvar > bl->nactvar) { /* leaving a variable scope? */
      gt->nactvar = bl->nactvar;     /* update goto level */
      gt->close |= bl->upval;        /* jump may need a close */
    }
  }
}

static void enterblock(FuncState *fs, BlockCnt *bl, lu_byte isloop) {
  bl->isloop = isloop;
  bl->nactvar = fs->nactvar;
  bl->firstlabel = fs->ls->dyd->label.n;
  bl->firstgoto = fs->ls->dyd->gt.n;
  bl->upval = 0;
  bl->insidetbc = (fs->bl != ((void *)0) && fs->bl->insidetbc);
  bl->previous = fs->bl;
  fs->bl = bl;
  ((void)0);
}

/*
** generates an error for an undefined 'goto'.
*/
static void __attribute__((noreturn)) undefgoto(LexState *ls, Labeldesc *gt) {
  const char *msg;
  if (((gt->name) == ((luaS_newlstr(ls->L,
                                    ""
                                    "break",
                                    (sizeof("break") / sizeof(char)) - 1))))) {
    msg = "break outside loop at line %d";
    msg = luaO_pushfstring(ls->L, msg, gt->line);
  } else {
    msg = "no visible label '%s' for <goto> at line %d";
    msg = luaO_pushfstring(
        ls->L, msg, (((char *)(((gt->name)))) + sizeof(TString)), gt->line);
  }
  luaK_semerror(ls, msg);
}

static void leaveblock(FuncState *fs) {
  BlockCnt *bl = fs->bl;
  LexState *ls = fs->ls;
  int hasclose = 0;
  if (bl->isloop) /* fix pending breaks? */
    hasclose = createlabel(ls,
                           (luaS_newlstr(ls->L,
                                         ""
                                         "break",
                                         (sizeof("break") / sizeof(char)) - 1)),
                           0, 0);
  if (!hasclose && bl->previous && bl->upval)
    luaK_codeABCk(fs, OP_CLOSE, bl->nactvar, 0, 0, 0);
  fs->bl = bl->previous;
  removevars(fs, bl->nactvar);
  ((void)0);
  fs->freereg = fs->nactvar;         /* free registers */
  ls->dyd->label.n = bl->firstlabel; /* remove local labels */
  if (bl->previous)                  /* inner block? */
    movegotosout(fs, bl);            /* update pending gotos to outer block */
  else {
    if (bl->firstgoto < ls->dyd->gt.n) /* pending gotos in outer block? */
      undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]); /* error */
  }
}

/*
** adds a new prototype into list of prototypes
*/
static Proto *addprototype(LexState *ls) {
  Proto *clp;
  lua_State *L = ls->L;
  FuncState *fs = ls->fs;
  Proto *f = fs->f; /* prototype of current function */
  if (fs->np >= f->sizep) {
    int oldsize = f->sizep;
    ((f->p) = ((Proto **)(luaM_growaux_(
         L, f->p, fs->np, &(f->sizep), sizeof(Proto *),
         ((((size_t)((((1 << (8 + 8 + 1)) - 1)))) <=
           ((size_t)(~(size_t)0)) / sizeof(Proto *))
              ? (((1 << (8 + 8 + 1)) - 1))
              : ((unsigned int)(((((size_t)(~(size_t)0)) / sizeof(Proto *)))))),
         "functions"))));
    while (oldsize < f->sizep)
      f->p[oldsize++] = ((void *)0);
  }
  f->p[fs->np++] = clp = luaF_newproto(L);
  (((((f)->marked) & ((1 << (5 /* object is black */)))) &&
    (((clp)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                         (1 << (4 /* object is white (type 1) */))))))
       ? luaC_barrier_(L, (&(((union GCUnion *)((f)))->gc)),
                       (&(((union GCUnion *)((clp)))->gc)))
       : ((void)((0))));
  return clp;
}

/*
** codes instruction to create new closure in parent function.
** The OP_CLOSURE instruction must use the last available register,
** so that, if it invokes the GC, the GC knows which registers
** are in use at that time.
*/
static void codeclosure(LexState *ls, expdesc *v) {
  FuncState *fs = ls->fs->prev;
  init_exp(v, VRELOC, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));
  luaK_exp2nextreg(fs, v); /* fix it at the last register */
}

static void open_func(LexState *ls, FuncState *fs, BlockCnt *bl) {
  Proto *f = fs->f;
  fs->prev = ls->fs; /* linked list of funcstates */
  fs->ls = ls;
  ls->fs = fs;
  fs->pc = 0;
  fs->previousline = f->linedefined;
  fs->iwthabs = 0;
  fs->lasttarget = 0;
  fs->freereg = 0;
  fs->nk = 0;
  fs->nabslineinfo = 0;
  fs->np = 0;
  fs->nups = 0;
  fs->nlocvars = 0;
  fs->nactvar = 0;
  fs->needclose = 0;
  fs->firstlocal = ls->dyd->actvar.n;
  fs->firstlabel = ls->dyd->label.n;
  fs->bl = ((void *)0);
  f->source = ls->source;
  f->maxstacksize = 2; /* registers 0/1 are always valid */
  enterblock(fs, bl, 0);
}

static void close_func(LexState *ls) {
  lua_State *L = ls->L;
  FuncState *fs = ls->fs;
  Proto *f = fs->f;
  luaK_ret(fs, fs->nactvar, 0); /* final return */
  leaveblock(fs);
  ((void)0);
  luaK_finish(fs);
  ((f->code) = ((Instruction *)(luaM_shrinkvector_(
       L, f->code, &(f->sizecode), fs->pc, sizeof(Instruction)))));
  ((f->lineinfo) = ((ls_byte *)(luaM_shrinkvector_(
       L, f->lineinfo, &(f->sizelineinfo), fs->pc, sizeof(ls_byte)))));
  ((f->abslineinfo) = ((AbsLineInfo *)(luaM_shrinkvector_(
       L, f->abslineinfo, &(f->sizeabslineinfo), fs->nabslineinfo,
       sizeof(AbsLineInfo)))));
  ((f->k) = ((TValue *)(luaM_shrinkvector_(L, f->k, &(f->sizek), fs->nk,
                                           sizeof(TValue)))));
  ((f->p) = ((Proto **)(luaM_shrinkvector_(L, f->p, &(f->sizep), fs->np,
                                           sizeof(Proto *)))));
  ((f->locvars) = ((LocVar *)(luaM_shrinkvector_(
       L, f->locvars, &(f->sizelocvars), fs->nlocvars, sizeof(LocVar)))));
  ((f->upvalues) = ((Upvaldesc *)(luaM_shrinkvector_(
       L, f->upvalues, &(f->sizeupvalues), fs->nups, sizeof(Upvaldesc)))));
  ls->fs = fs->prev;
  {
    if ((L->l_G)->GCdebt > 0) {
      (void)0;
      luaC_step(L);
      (void)0;
    };
    ((void)0);
  };
}

/*============================================================*/
/* GRAMMAR RULES */
/*============================================================*/

/*
** check whether current token is in the follow set of a block.
** 'until' closes syntactical blocks, but do not close scope,
** so it is handled in separate.
*/
static int block_follow(LexState *ls, int withuntil) {
  switch (ls->t.token) {
  case TK_ELSE:
  case TK_ELSEIF:
  case TK_END:
  case TK_EOS:
    return 1;
  case TK_UNTIL:
    return withuntil;
  default:
    return 0;
  }
}

static void statlist(LexState *ls) {
  /* statlist -> { stat [';'] } */
  while (!block_follow(ls, 1)) {
    if (ls->t.token == TK_RETURN) {
      statement(ls);
      return; /* 'return' must be last statement */
    }
    statement(ls);
  }
}

static void fieldsel(LexState *ls, expdesc *v) {
  /* fieldsel -> ['.' | ':'] NAME */
  FuncState *fs = ls->fs;
  expdesc key;
  luaK_exp2anyregup(fs, v);
  luaX_next(ls); /* skip the dot or colon */
  codename(ls, &key);
  luaK_indexed(fs, v, &key);
}

static void yindex(LexState *ls, expdesc *v) {
  /* index -> '[' expr ']' */
  luaX_next(ls); /* skip the '[' */
  expr(ls, v);
  luaK_exp2val(ls->fs, v);
  checknext(ls, ']');
}

/*
** {======================================================================
** Rules for Constructors
** =======================================================================
*/

struct ConsControl {
  expdesc v;   /* last list item read */
  expdesc *t;  /* table descriptor */
  int nh;      /* total number of 'record' elements */
  int na;      /* total number of array elements */
  int tostore; /* number of array elements pending to be stored */
};

static void recfield(LexState *ls, struct ConsControl *cc) {
  /* recfield -> (NAME | '['exp']') = exp */
  FuncState *fs = ls->fs;
  int reg = ls->fs->freereg;
  expdesc tab, key, val;
  if (ls->t.token == TK_NAME) {
    checklimit(fs, cc->nh, 0x7fffffff /* maximum value of an int */,
               "items in a constructor");
    codename(ls, &key);
  } else /* ls->t.token == '[' */
    yindex(ls, &key);
  cc->nh++;
  checknext(ls, '=');
  tab = *cc->t;
  luaK_indexed(fs, &tab, &key);
  expr(ls, &val);
  luaK_storevar(fs, &tab, &val);
  fs->freereg = reg; /* free registers */
}

static void closelistfield(FuncState *fs, struct ConsControl *cc) {
  if (cc->v.k == VVOID)
    return; /* there is no list item */
  luaK_exp2nextreg(fs, &cc->v);
  cc->v.k = VVOID;
  if (cc->tostore == 50) {
    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore); /* flush */
    cc->tostore = 0; /* no more items pending */
  }
}

static void lastlistfield(FuncState *fs, struct ConsControl *cc) {
  if (cc->tostore == 0)
    return;
  if (((cc->v.k) == VCALL || (cc->v.k) == VVARARG)) {
    luaK_setreturns(fs, &cc->v, (-1));
    luaK_setlist(fs, cc->t->u.info, cc->na, (-1));
    cc->na--; /* do not count last expression (unknown number of elements) */
  } else {
    if (cc->v.k != VVOID)
      luaK_exp2nextreg(fs, &cc->v);
    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);
  }
}

static void listfield(LexState *ls, struct ConsControl *cc) {
  /* listfield -> exp */
  expr(ls, &cc->v);
  checklimit(ls->fs, cc->na, 0x7fffffff /* maximum value of an int */,
             "items in a constructor");
  cc->na++;
  cc->tostore++;
}

static void field(LexState *ls, struct ConsControl *cc) {
  /* field -> listfield | recfield */
  switch (ls->t.token) {
  case TK_NAME: {                  /* may be 'listfield' or 'recfield' */
    if (luaX_lookahead(ls) != '=') /* expression? */
      listfield(ls, cc);
    else
      recfield(ls, cc);
    break;
  }
  case '[': {
    recfield(ls, cc);
    break;
  }
  default: {
    listfield(ls, cc);
    break;
  }
  }
}

static void constructor(LexState *ls, expdesc *t) {
  /* constructor -> '{' [ field { sep field } [sep] ] '}'
     sep -> ',' | ';' */
  FuncState *fs = ls->fs;
  int line = ls->linenumber;
  int pc = luaK_codeABCk(fs, OP_NEWTABLE, 0, 0, 0, 0);
  struct ConsControl cc;
  cc.na = cc.nh = cc.tostore = 0;
  cc.t = t;
  init_exp(t, VRELOC, pc);
  init_exp(&cc.v, VVOID, 0);   /* no value (yet) */
  luaK_exp2nextreg(ls->fs, t); /* fix it at stack top */
  checknext(ls, '{');
  do {
    ((void)0);
    if (ls->t.token == '}')
      break;
    closelistfield(fs, &cc);
    field(ls, &cc);
  } while (testnext(ls, ',') || testnext(ls, ';'));
  check_match(ls, '}', '{', line);
  lastlistfield(fs, &cc);
  ((fs->f->code[pc]) =
       (((fs->f->code[pc]) &
         (~((~((~(Instruction)0) << (8))) << ((((0 + 7) + 8) + 1))))) |
        ((((Instruction)(luaO_int2fb(cc.na))) << (((0 + 7) + 8) + 1)) &
         ((~((~(Instruction)0) << (8)))
          << ((((0 + 7) + 8) + 1)))))); /* set initial array size */
  ((fs->f->code[pc]) =
       (((fs->f->code[pc]) &
         (~((~((~(Instruction)0) << (8))) << (((((0 + 7) + 8) + 1) + 8))))) |
        ((((Instruction)(luaO_int2fb(cc.nh))) << ((((0 + 7) + 8) + 1) + 8)) &
         ((~((~(Instruction)0) << (8)))
          << (((((0 + 7) + 8) + 1) + 8)))))); /* set initial table size */
}

/* }====================================================================== */

static void setvararg(FuncState *fs, int nparams) {
  fs->f->is_vararg = 1;
  luaK_codeABCk(fs, OP_VARARGPREP, nparams, 0, 0, 0);
}

static void parlist(LexState *ls) {
  /* parlist -> [ param { ',' param } ] */
  FuncState *fs = ls->fs;
  Proto *f = fs->f;
  int nparams = 0;
  int isvararg = 0;
  if (ls->t.token != ')') { /* is 'parlist' not empty? */
    do {
      switch (ls->t.token) {
      case TK_NAME: { /* param -> NAME */
        new_localvar(ls, str_checkname(ls));
        nparams++;
        break;
      }
      case TK_DOTS: { /* param -> '...' */
        luaX_next(ls);
        isvararg = 1;
        break;
      }
      default:
        luaX_syntaxerror(ls, "<name> or '...' expected");
      }
    } while (!isvararg && testnext(ls, ','));
  }
  adjustlocalvars(ls, nparams);
  f->numparams = ((lu_byte)((fs->nactvar)));
  if (isvararg)
    setvararg(fs, f->numparams);     /* declared vararg */
  luaK_reserveregs(fs, fs->nactvar); /* reserve registers for parameters */
}

static void body(LexState *ls, expdesc *e, int ismethod, int line) {
  /* body ->  '(' parlist ')' block END */
  FuncState new_fs;
  BlockCnt bl;
  new_fs.f = addprototype(ls);
  new_fs.f->linedefined = line;
  open_func(ls, &new_fs, &bl);
  checknext(ls, '(');
  if (ismethod) {
    new_localvar(ls, luaX_newstring(ls,
                                    ""
                                    "self",
                                    (sizeof("self") / sizeof(char)) - 1));
    ; /* create 'self' parameter */
    adjustlocalvars(ls, 1);
  }
  parlist(ls);
  checknext(ls, ')');
  statlist(ls);
  new_fs.f->lastlinedefined = ls->linenumber;
  check_match(ls, TK_END, TK_FUNCTION, line);
  codeclosure(ls, e);
  close_func(ls);
}

static int explist(LexState *ls, expdesc *v) {
  /* explist -> expr { ',' expr } */
  int n = 1; /* at least one expression */
  expr(ls, v);
  while (testnext(ls, ',')) {
    luaK_exp2nextreg(ls->fs, v);
    expr(ls, v);
    n++;
  }
  return n;
}

static void funcargs(LexState *ls, expdesc *f, int line) {
  FuncState *fs = ls->fs;
  expdesc args;
  int base, nparams;
  switch (ls->t.token) {
  case '(': { /* funcargs -> '(' [ explist ] ')' */
    luaX_next(ls);
    if (ls->t.token == ')') /* arg list is empty? */
      args.k = VVOID;
    else {
      explist(ls, &args);
      luaK_setreturns(fs, &args, (-1));
    }
    check_match(ls, ')', '(', line);
    break;
  }
  case '{': { /* funcargs -> constructor */
    constructor(ls, &args);
    break;
  }
  case TK_STRING: { /* funcargs -> STRING */
    codestring(ls, &args, ls->t.seminfo.ts);
    luaX_next(ls); /* must use 'seminfo' before 'next' */
    break;
  }
  default: {
    luaX_syntaxerror(ls, "function arguments expected");
  }
  }
  ((void)0);
  base = f->u.info; /* base register for call */
  if (((args.k) == VCALL || (args.k) == VVARARG))
    nparams = (-1); /* open call */
  else {
    if (args.k != VVOID)
      luaK_exp2nextreg(fs, &args); /* close last argument */
    nparams = fs->freereg - (base + 1);
  }
  init_exp(f, VCALL, luaK_codeABCk(fs, OP_CALL, base, nparams + 1, 2, 0));
  luaK_fixline(fs, line);
  fs->freereg = base + 1; /* call remove function and arguments and leaves
                              (unless changed) one result */
}

/*
** {======================================================================
** Expression parsing
** =======================================================================
*/

static void primaryexp(LexState *ls, expdesc *v) {
  /* primaryexp -> NAME | '(' expr ')' */
  switch (ls->t.token) {
  case '(': {
    int line = ls->linenumber;
    luaX_next(ls);
    expr(ls, v);
    check_match(ls, ')', '(', line);
    luaK_dischargevars(ls->fs, v);
    return;
  }
  case TK_NAME: {
    singlevar(ls, v);
    return;
  }
  default: {
    luaX_syntaxerror(ls, "unexpected symbol");
  }
  }
}

static void suffixedexp(LexState *ls, expdesc *v) {
  /* suffixedexp ->
       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */
  FuncState *fs = ls->fs;
  int line = ls->linenumber;
  primaryexp(ls, v);
  for (;;) {
    switch (ls->t.token) {
    case '.': { /* fieldsel */
      fieldsel(ls, v);
      break;
    }
    case '[': { /* '[' exp ']' */
      expdesc key;
      luaK_exp2anyregup(fs, v);
      yindex(ls, &key);
      luaK_indexed(fs, v, &key);
      break;
    }
    case ':': { /* ':' NAME funcargs */
      expdesc key;
      luaX_next(ls);
      codename(ls, &key);
      luaK_self(fs, v, &key);
      funcargs(ls, v, line);
      break;
    }
    case '(':
    case TK_STRING:
    case '{': { /* funcargs */
      luaK_exp2nextreg(fs, v);
      funcargs(ls, v, line);
      break;
    }
    default:
      return;
    }
  }
}

static void simpleexp(LexState *ls, expdesc *v) {
  /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |
                  constructor | FUNCTION body | suffixedexp */
  switch (ls->t.token) {
  case TK_FLT: {
    init_exp(v, VKFLT, 0);
    v->u.nval = ls->t.seminfo.r;
    break;
  }
  case TK_INT: {
    init_exp(v, VKINT, 0);
    v->u.ival = ls->t.seminfo.i;
    break;
  }
  case TK_STRING: {
    codestring(ls, v, ls->t.seminfo.ts);
    break;
  }
  case TK_NIL: {
    init_exp(v, VNIL, 0);
    break;
  }
  case TK_TRUE: {
    init_exp(v, VTRUE, 0);
    break;
  }
  case TK_FALSE: {
    init_exp(v, VFALSE, 0);
    break;
  }
  case TK_DOTS: { /* vararg */
    FuncState *fs = ls->fs;
    {
      if (!(fs->f->is_vararg))
        luaX_syntaxerror(ls, "cannot use '...' outside a vararg function");
    };
    init_exp(v, VVARARG, luaK_codeABCk(fs, OP_VARARG, 0, 0, 1, 0));
    break;
  }
  case '{': { /* constructor */
    constructor(ls, v);
    return;
  }
  case TK_FUNCTION: {
    luaX_next(ls);
    body(ls, v, 0, ls->linenumber);
    return;
  }
  default: {
    suffixedexp(ls, v);
    return;
  }
  }
  luaX_next(ls);
}

static UnOpr getunopr(int op) {
  switch (op) {
  case TK_NOT:
    return OPR_NOT;
  case '-':
    return OPR_MINUS;
  case '~':
    return OPR_BNOT;
  case '#':
    return OPR_LEN;
  default:
    return OPR_NOUNOPR;
  }
}

static BinOpr getbinopr(int op) {
  switch (op) {
  case '+':
    return OPR_ADD;
  case '-':
    return OPR_SUB;
  case '*':
    return OPR_MUL;
  case '%':
    return OPR_MOD;
  case '^':
    return OPR_POW;
  case '/':
    return OPR_DIV;
  case TK_IDIV:
    return OPR_IDIV;
  case '&':
    return OPR_BAND;
  case '|':
    return OPR_BOR;
  case '~':
    return OPR_BXOR;
  case TK_SHL:
    return OPR_SHL;
  case TK_SHR:
    return OPR_SHR;
  case TK_CONCAT:
    return OPR_CONCAT;
  case TK_NE:
    return OPR_NE;
  case TK_EQ:
    return OPR_EQ;
  case '<':
    return OPR_LT;
  case TK_LE:
    return OPR_LE;
  case '>':
    return OPR_GT;
  case TK_GE:
    return OPR_GE;
  case TK_AND:
    return OPR_AND;
  case TK_OR:
    return OPR_OR;
  default:
    return OPR_NOBINOPR;
  }
}

/*
** Priority table for binary operators.
*/
static const struct {
  lu_byte left;  /* left priority for each binary operator */
  lu_byte right; /* right priority */
} priority[] = {
    /* ORDER OPR */
    {10, 10}, {10, 10},         /* '+' '-' */
    {11, 11}, {11, 11},         /* '*' '%' */
    {14, 13},                   /* '^' (right associative) */
    {11, 11}, {11, 11},         /* '/' '//' */
    {6, 6},   {4, 4},   {5, 5}, /* '&' '|' '~' */
    {7, 7},   {7, 7},           /* '<<' '>>' */
    {9, 8},                     /* '..' (right associative) */
    {3, 3},   {3, 3},   {3, 3}, /* ==, <, <= */
    {3, 3},   {3, 3},   {3, 3}, /* ~=, >, >= */
    {2, 2},   {1, 1}            /* and, or */
};

/*
** subexpr -> (simpleexp | unop subexpr) { binop subexpr }
** where 'binop' is any binary operator with a priority higher than 'limit'
*/
static BinOpr subexpr(LexState *ls, expdesc *v, int limit) {
  BinOpr op;
  UnOpr uop;
  luaE_enterCcall((ls)->L);
  uop = getunopr(ls->t.token);
  if (uop != OPR_NOUNOPR) { /* prefix (unary) operator? */
    int line = ls->linenumber;
    luaX_next(ls); /* skip operator */
    subexpr(ls, v, 12 /* priority for unary operators */);
    luaK_prefix(ls->fs, uop, v, line);
  } else
    simpleexp(ls, v);
  /* expand while operators have priorities higher than 'limit' */
  op = getbinopr(ls->t.token);
  while (op != OPR_NOBINOPR && priority[op].left > limit) {
    expdesc v2;
    BinOpr nextop;
    int line = ls->linenumber;
    luaX_next(ls); /* skip operator */
    luaK_infix(ls->fs, op, v);
    /* read sub-expression with higher priority */
    nextop = subexpr(ls, &v2, priority[op].right);
    luaK_posfix(ls->fs, op, v, &v2, line);
    op = nextop;
  }
  (((ls)->L)->nCcalls--);
  return op; /* return first untreated operator */
}

static void expr(LexState *ls, expdesc *v) { subexpr(ls, v, 0); }

/* }==================================================================== */

/*
** {======================================================================
** Rules for Statements
** =======================================================================
*/

static void block(LexState *ls) {
  /* block -> statlist */
  FuncState *fs = ls->fs;
  BlockCnt bl;
  enterblock(fs, &bl, 0);
  statlist(ls);
  leaveblock(fs);
}

/*
** structure to chain all variables in the left-hand side of an
** assignment
*/
struct LHS_assign {
  struct LHS_assign *prev;
  expdesc v; /* variable (global, local, upvalue, or indexed) */
};

/*
** check whether, in an assignment to an upvalue/local variable, the
** upvalue/local variable is begin used in a previous assignment to a
** table. If so, save original upvalue/local value in a safe place and
** use this safe copy in the previous assignment.
*/
static void check_conflict(LexState *ls, struct LHS_assign *lh, expdesc *v) {
  FuncState *fs = ls->fs;
  int extra = fs->freereg; /* eventual position to save local variable */
  int conflict = 0;
  for (; lh; lh = lh->prev) { /* check all previous assignments */
    if ((VINDEXED <= (lh->v.k) &&
         (lh->v.k) <= VINDEXSTR)) { /* assignment to table field? */
      if (lh->v.k == VINDEXUP) {    /* is table an upvalue? */
        if (v->k == VUPVAL && lh->v.u.ind.t == v->u.info) {
          conflict = 1; /* table is the upvalue being assigned now */
          lh->v.k = VINDEXSTR;
          lh->v.u.ind.t = extra; /* assignment will use safe copy */
        }
      } else { /* table is a register */
        if (v->k == VLOCAL && lh->v.u.ind.t == v->u.info) {
          conflict = 1;          /* table is the local being assigned now */
          lh->v.u.ind.t = extra; /* assignment will use safe copy */
        }
        /* is index the local being assigned? */
        if (lh->v.k == VINDEXED && v->k == VLOCAL &&
            lh->v.u.ind.idx == v->u.info) {
          conflict = 1;
          lh->v.u.ind.idx = extra; /* previous assignment will use safe copy */
        }
      }
    }
  }
  if (conflict) {
    /* copy upvalue/local value to a temporary (in position 'extra') */
    OpCode op = (v->k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
    luaK_codeABCk(fs, op, extra, v->u.info, 0, 0);
    luaK_reserveregs(fs, 1);
  }
}

/*
** Parse and compile a mulitple assignment. The first "variable"
** (a 'suffixedexp') was already read by the caller.
**
** assignment -> suffixedexp restassign
** restassign -> ',' suffixedexp restassign | '=' explist
*/
static void restassign(LexState *ls, struct LHS_assign *lh, int nvars) {
  expdesc e;
  {
    if (!((VLOCAL <= (lh->v.k) && (lh->v.k) <= VINDEXSTR)))
      luaX_syntaxerror(ls, "syntax error");
  };
  if (testnext(ls, ',')) { /* restassign -> ',' suffixedexp restassign */
    struct LHS_assign nv;
    nv.prev = lh;
    suffixedexp(ls, &nv.v);
    if (!(VINDEXED <= (nv.v.k) && (nv.v.k) <= VINDEXSTR))
      check_conflict(ls, lh, &nv.v);
    luaE_enterCcall((ls)->L); /* control recursion depth */
    restassign(ls, &nv, nvars + 1);
    (((ls)->L)->nCcalls--);
  } else { /* restassign -> '=' explist */
    int nexps;
    checknext(ls, '=');
    nexps = explist(ls, &e);
    if (nexps != nvars)
      adjust_assign(ls, nvars, nexps, &e);
    else {
      luaK_setoneret(ls->fs, &e); /* close last expression */
      luaK_storevar(ls->fs, &lh->v, &e);
      return; /* avoid default */
    }
  }
  init_exp(&e, VNONRELOC, ls->fs->freereg - 1); /* default assignment */
  luaK_storevar(ls->fs, &lh->v, &e);
}

static int cond(LexState *ls) {
  /* cond -> exp */
  expdesc v;
  expr(ls, &v); /* read condition */
  if (v.k == VNIL)
    v.k = VFALSE; /* 'falses' are all equal here */
  luaK_goiftrue(ls->fs, &v);
  return v.f;
}

static void gotostat(LexState *ls) {
  FuncState *fs = ls->fs;
  int line = ls->linenumber;
  TString *name = str_checkname(ls); /* label's name */
  Labeldesc *lb = findlabel(ls, name);
  if (lb == ((void *)0)) /* no label? */
    /* forward jump; will be resolved when the label is declared */
    newgotoentry(ls, name, line, luaK_jump(fs));
  else { /* found a label */
    /* backward jump; will be resolved here */
    if (fs->nactvar > lb->nactvar) /* leaving the scope of some variable? */
      luaK_codeABCk(fs, OP_CLOSE, lb->nactvar, 0, 0, 0);
    /* create jump and link it to the label */
    luaK_patchlist(fs, luaK_jump(fs), lb->pc);
  }
}

/*
** Break statement. Semantically equivalent to "goto break".
*/
static void breakstat(LexState *ls) {
  int line = ls->linenumber;
  luaX_next(ls); /* skip break */
  newgotoentry(ls,
               (luaS_newlstr(ls->L,
                             ""
                             "break",
                             (sizeof("break") / sizeof(char)) - 1)),
               line, luaK_jump(ls->fs));
}

/*
** Check whether there is already a label with the given 'name'.
*/
static void checkrepeated(LexState *ls, TString *name) {
  Labeldesc *lb = findlabel(ls, name);
  if ((__builtin_expect(((lb != ((void *)0)) != 0),
                        0))) { /* already defined? */
    const char *msg = "label '%s' already defined on line %d";
    msg = luaO_pushfstring(ls->L, msg, (((char *)(((name)))) + sizeof(TString)),
                           lb->line);
    luaK_semerror(ls, msg); /* error */
  }
}

static void labelstat(LexState *ls, TString *name, int line) {
  /* label -> '::' NAME '::' */
  checknext(ls, TK_DBCOLON); /* skip double colon */
  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)
    statement(ls);         /* skip other no-op statements */
  checkrepeated(ls, name); /* check for repeated labels */
  createlabel(ls, name, line, block_follow(ls, 0));
}

static void whilestat(LexState *ls, int line) {
  /* whilestat -> WHILE cond DO block END */
  FuncState *fs = ls->fs;
  int whileinit;
  int condexit;
  BlockCnt bl;
  luaX_next(ls); /* skip WHILE */
  whileinit = luaK_getlabel(fs);
  condexit = cond(ls);
  enterblock(fs, &bl, 1);
  checknext(ls, TK_DO);
  block(ls);
  luaK_patchlist(fs, luaK_jump(fs), whileinit);
  check_match(ls, TK_END, TK_WHILE, line);
  leaveblock(fs);
  luaK_patchtohere(fs, condexit); /* false conditions finish the loop */
}

static void repeatstat(LexState *ls, int line) {
  /* repeatstat -> REPEAT block UNTIL cond */
  int condexit;
  FuncState *fs = ls->fs;
  int repeat_init = luaK_getlabel(fs);
  BlockCnt bl1, bl2;
  enterblock(fs, &bl1, 1); /* loop block */
  enterblock(fs, &bl2, 0); /* scope block */
  luaX_next(ls);           /* skip REPEAT */
  statlist(ls);
  check_match(ls, TK_UNTIL, TK_REPEAT, line);
  condexit = cond(ls);              /* read condition (inside scope block) */
  leaveblock(fs);                   /* finish scope */
  if (bl2.upval) {                  /* upvalues? */
    int exit = luaK_jump(fs);       /* normal exit must jump over fix */
    luaK_patchtohere(fs, condexit); /* repetition must close upvalues */
    luaK_codeABCk(fs, OP_CLOSE, bl2.nactvar, 0, 0, 0);
    condexit = luaK_jump(fs);   /* repeat after closing upvalues */
    luaK_patchtohere(fs, exit); /* normal exit comes to here */
  }
  luaK_patchlist(fs, condexit, repeat_init); /* close the loop */
  leaveblock(fs);                            /* finish loop */
}

/*
** Read an expression and generate code to put its results in next
** stack slot.
**
*/
static void exp1(LexState *ls) {
  expdesc e;
  expr(ls, &e);
  luaK_exp2nextreg(ls->fs, &e);
  ((void)0);
}

/*
** Fix for instruction at position 'pc' to jump to 'dest'.
** (Jump addresses are relative in Lua). 'back' true means
** a back jump.
*/
static void fixforjump(FuncState *fs, int pc, int dest, int back) {
  Instruction *jmp = &fs->f->code[pc];
  int offset = dest - (pc + 1);
  if (back)
    offset = -offset;
  if ((__builtin_expect(((offset > ((1 << (8 + 8 + 1)) - 1)) != 0), 0)))
    luaX_syntaxerror(fs->ls, "control structure too long");
  ((*jmp) = (((*jmp) &
              (~((~((~(Instruction)0) << ((8 + 8 + 1)))) << (((0 + 7) + 8))))) |
             ((((Instruction)(offset)) << ((0 + 7) + 8)) &
              ((~((~(Instruction)0) << ((8 + 8 + 1)))) << (((0 + 7) + 8))))));
}

/*
** Generate code for a 'for' loop.
*/
static void forbody(LexState *ls, int base, int line, int nvars, int isgen) {
  /* forbody -> DO block */
  static OpCode forprep[2] = {OP_FORPREP, OP_TFORPREP};
  static OpCode forloop[2] = {OP_FORLOOP, OP_TFORLOOP};
  BlockCnt bl;
  FuncState *fs = ls->fs;
  int prep, endfor;
  checknext(ls, TK_DO);
  prep = luaK_codeABx(fs, forprep[isgen], base, 0);
  enterblock(fs, &bl, 0); /* scope for declared variables */
  adjustlocalvars(ls, nvars);
  luaK_reserveregs(fs, nvars);
  block(ls);
  leaveblock(fs); /* end of scope for declared variables */
  fixforjump(fs, prep, luaK_getlabel(fs), 0);
  if (isgen) { /* generic for? */
    luaK_codeABCk(fs, OP_TFORCALL, base, 0, nvars, 0);
    luaK_fixline(fs, line);
    base += 2; /* base for 'OP_TFORLOOP' (skips function and state) */
  }
  endfor = luaK_codeABx(fs, forloop[isgen], base, 0);
  fixforjump(fs, endfor, prep + 1, 1);
  luaK_fixline(fs, line);
}

static void fornum(LexState *ls, TString *varname, int line) {
  /* fornum -> NAME = exp,exp[,exp] forbody */
  FuncState *fs = ls->fs;
  int base = fs->freereg;
  new_localvar(ls, luaX_newstring(ls,
                                  ""
                                  "(for index)",
                                  (sizeof("(for index)") / sizeof(char)) - 1));
  ;
  new_localvar(ls, luaX_newstring(ls,
                                  ""
                                  "(for limit)",
                                  (sizeof("(for limit)") / sizeof(char)) - 1));
  ;
  new_localvar(ls, luaX_newstring(ls,
                                  ""
                                  "(for step)",
                                  (sizeof("(for step)") / sizeof(char)) - 1));
  ;
  new_localvar(ls, varname);
  checknext(ls, '=');
  exp1(ls); /* initial value */
  checknext(ls, ',');
  exp1(ls); /* limit */
  if (testnext(ls, ','))
    exp1(ls); /* optional step */
  else {      /* default step = 1 */
    luaK_int(fs, fs->freereg, 1);
    luaK_reserveregs(fs, 1);
  }
  adjustlocalvars(ls, 3); /* control variables */
  forbody(ls, base, line, 1, 0);
}

static void forlist(LexState *ls, TString *indexname) {
  /* forlist -> NAME {,NAME} IN explist forbody */
  FuncState *fs = ls->fs;
  expdesc e;
  int nvars = 5; /* gen, state, control, toclose, 'indexname' */
  int line;
  int base = fs->freereg;
  /* create control variables */
  new_localvar(ls,
               luaX_newstring(ls,
                              ""
                              "(for generator)",
                              (sizeof("(for generator)") / sizeof(char)) - 1));
  ;
  new_localvar(ls, luaX_newstring(ls,
                                  ""
                                  "(for state)",
                                  (sizeof("(for state)") / sizeof(char)) - 1));
  ;
  markupval(fs, fs->nactvar); /* state may create an upvalue */
  new_localvar(ls,
               luaX_newstring(ls,
                              ""
                              "(for control)",
                              (sizeof("(for control)") / sizeof(char)) - 1));
  ;
  new_localvar(ls,
               luaX_newstring(ls,
                              ""
                              "(for toclose)",
                              (sizeof("(for toclose)") / sizeof(char)) - 1));
  ;
  /* create declared variables */
  new_localvar(ls, indexname);
  while (testnext(ls, ',')) {
    new_localvar(ls, str_checkname(ls));
    nvars++;
  }
  checknext(ls, TK_IN);
  line = ls->linenumber;
  adjust_assign(ls, 4, explist(ls, &e), &e);
  adjustlocalvars(ls, 4); /* control variables */
  luaK_checkstack(fs, 3); /* extra space to call generator */
  forbody(ls, base, line, nvars - 4, 1);
}

static void forstat(LexState *ls, int line) {
  /* forstat -> FOR (fornum | forlist) END */
  FuncState *fs = ls->fs;
  TString *varname;
  BlockCnt bl;
  enterblock(fs, &bl, 1);      /* scope for loop and control variables */
  luaX_next(ls);               /* skip 'for' */
  varname = str_checkname(ls); /* first variable name */
  switch (ls->t.token) {
  case '=':
    fornum(ls, varname, line);
    break;
  case ',':
  case TK_IN:
    forlist(ls, varname);
    break;
  default:
    luaX_syntaxerror(ls, "'=' or 'in' expected");
  }
  check_match(ls, TK_END, TK_FOR, line);
  leaveblock(fs); /* loop scope ('break' jumps to this point) */
}

/*
** Check whether next instruction is a single jump (a 'break', a 'goto'
** to a forward label, or a 'goto' to a backward label with no variable
** to close). If so, set the name of the 'label' it is jumping to
** ("break" for a 'break') or to where it is jumping to ('target') and
** return true. If not a single jump, leave input unchanged, to be
** handled as a regular statement.
*/
static int issinglejump(LexState *ls, TString **label, int *target) {
  if (testnext(ls, TK_BREAK)) { /* a break? */
    *label = (luaS_newlstr(ls->L,
                           ""
                           "break",
                           (sizeof("break") / sizeof(char)) - 1));
    return 1;
  } else if (ls->t.token != TK_GOTO || luaX_lookahead(ls) != TK_NAME)
    return 0; /* not a valid goto */
  else {
    TString *lname = ls->lookahead.seminfo.ts; /* label's id */
    Labeldesc *lb = findlabel(ls, lname);
    if (lb) {                            /* a backward jump? */
      if (ls->fs->nactvar > lb->nactvar) /* needs to close variables? */
        return 0; /* not a single jump; cannot optimize */
      *target = lb->pc;
    } else /* jump forward */
      *label = lname;
    luaX_next(ls); /* skip goto */
    luaX_next(ls); /* skip name */
    return 1;
  }
}

static void test_then_block(LexState *ls, int *escapelist) {
  /* test_then_block -> [IF | ELSEIF] cond THEN block */
  BlockCnt bl;
  int line;
  FuncState *fs = ls->fs;
  TString *jlb = ((void *)0);
  int target = (-1);
  expdesc v;
  int jf;        /* instruction to skip 'then' code (if condition is false) */
  luaX_next(ls); /* skip IF or ELSEIF */
  expr(ls, &v);  /* read condition */
  checknext(ls, TK_THEN);
  line = ls->linenumber;
  if (issinglejump(ls, &jlb, &target)) { /* 'if x then goto' ? */
    luaK_goiffalse(ls->fs, &v); /* will jump to label if condition is true */
    enterblock(fs, &bl, 0);     /* must enter block before 'goto' */
    if (jlb != ((void *)0))     /* forward jump? */
      newgotoentry(ls, jlb, line, v.t); /* will be resolved later */
    else                                /* backward jump */
      luaK_patchlist(fs, v.t, target);  /* jump directly to 'target' */
    while (testnext(ls, ';')) {
    }                          /* skip semicolons */
    if (block_follow(ls, 0)) { /* jump is the entire block? */
      leaveblock(fs);
      return; /* and that is it */
    } else    /* must skip over 'then' part if condition is false */
      jf = luaK_jump(fs);
  } else {                     /* regular case (not a jump) */
    luaK_goiftrue(ls->fs, &v); /* skip over block if condition is false */
    enterblock(fs, &bl, 0);
    jf = v.f;
  }
  statlist(ls); /* 'then' part */
  leaveblock(fs);
  if (ls->t.token == TK_ELSE ||
      ls->t.token == TK_ELSEIF) /* followed by 'else'/'elseif'? */
    luaK_concat(fs, escapelist, luaK_jump(fs)); /* must jump over it */
  luaK_patchtohere(fs, jf);
}

static void ifstat(LexState *ls, int line) {
  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
  FuncState *fs = ls->fs;
  int escapelist = (-1);            /* exit list for finished parts */
  test_then_block(ls, &escapelist); /* IF cond THEN block */
  while (ls->t.token == TK_ELSEIF)
    test_then_block(ls, &escapelist); /* ELSEIF cond THEN block */
  if (testnext(ls, TK_ELSE))
    block(ls); /* 'else' part */
  check_match(ls, TK_END, TK_IF, line);
  luaK_patchtohere(fs, escapelist); /* patch escape list to 'if' end */
}

static void localfunc(LexState *ls) {
  expdesc b;
  FuncState *fs = ls->fs;
  new_localvar(ls, str_checkname(ls)); /* new local variable */
  adjustlocalvars(ls, 1);              /* enter its scope */
  body(ls, &b, 0, ls->linenumber);     /* function created in next register */
  /* debug information will only see the variable after this point! */
  getlocvar(fs, b.u.info)->startpc = fs->pc;
}

static void commonlocalstat(LexState *ls) {
  /* stat -> LOCAL NAME {',' NAME} ['=' explist] */
  int nvars = 0;
  int nexps;
  expdesc e;
  do {
    new_localvar(ls, str_checkname(ls));
    nvars++;
  } while (testnext(ls, ','));
  if (testnext(ls, '='))
    nexps = explist(ls, &e);
  else {
    e.k = VVOID;
    nexps = 0;
  }
  adjust_assign(ls, nvars, nexps, &e);
  adjustlocalvars(ls, nvars);
}

static void tocloselocalstat(LexState *ls) {
  FuncState *fs = ls->fs;
  TString *attr = str_checkname(ls);
  if (strcmp((((char *)(((attr)))) + sizeof(TString)), "toclose") != 0)
    luaK_semerror(ls,
                  luaO_pushfstring(ls->L, "unknown attribute '%s'",
                                   (((char *)(((attr)))) + sizeof(TString))));
  new_localvar(ls, str_checkname(ls));
  checknext(ls, '=');
  exp1(ls);
  markupval(fs, fs->nactvar);
  fs->bl->insidetbc = 1; /* in the scope of a to-be-closed variable */
  adjustlocalvars(ls, 1);
  luaK_codeABCk(fs, OP_TBC, fs->nactvar - 1, 0, 0, 0);
}

static void localstat(LexState *ls) {
  /* stat -> LOCAL NAME {',' NAME} ['=' explist]
           | LOCAL *toclose NAME '=' exp */
  if (testnext(ls, '*'))
    tocloselocalstat(ls);
  else
    commonlocalstat(ls);
}

static int funcname(LexState *ls, expdesc *v) {
  /* funcname -> NAME {fieldsel} [':' NAME] */
  int ismethod = 0;
  singlevar(ls, v);
  while (ls->t.token == '.')
    fieldsel(ls, v);
  if (ls->t.token == ':') {
    ismethod = 1;
    fieldsel(ls, v);
  }
  return ismethod;
}

static void funcstat(LexState *ls, int line) {
  /* funcstat -> FUNCTION funcname body */
  int ismethod;
  expdesc v, b;
  luaX_next(ls); /* skip FUNCTION */
  ismethod = funcname(ls, &v);
  body(ls, &b, ismethod, line);
  luaK_storevar(ls->fs, &v, &b);
  luaK_fixline(ls->fs, line); /* definition "happens" in the first line */
}

static void exprstat(LexState *ls) {
  /* stat -> func | assignment */
  FuncState *fs = ls->fs;
  struct LHS_assign v;
  suffixedexp(ls, &v.v);
  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */
    v.prev = ((void *)0);
    restassign(ls, &v, 1);
  } else { /* stat -> func */
    Instruction *inst = &((fs)->f->code[(&v.v)->u.info]);
    {
      if (!(v.v.k == VCALL))
        luaX_syntaxerror(ls, "syntax error");
    };
    ((*inst) = (((*inst) & (~((~((~(Instruction)0) << (8)))
                              << (((((0 + 7) + 8) + 1) + 8))))) |
                ((((Instruction)(1)) << ((((0 + 7) + 8) + 1) + 8)) &
                 ((~((~(Instruction)0) << (8)))
                  << (((((0 + 7) + 8) + 1) +
                       8)))))); /* call statement uses no results */
  }
}

static void retstat(LexState *ls) {
  /* stat -> RETURN [explist] [';'] */
  FuncState *fs = ls->fs;
  expdesc e;
  int nret;                /* number of values being returned */
  int first = fs->nactvar; /* first slot to be returned */
  if (block_follow(ls, 1) || ls->t.token == ';')
    nret = 0; /* return no values */
  else {
    nret = explist(ls, &e); /* optional return values */
    if (((e.k) == VCALL || (e.k) == VVARARG)) {
      luaK_setreturns(fs, &e, (-1));
      if (e.k == VCALL && nret == 1 && !fs->bl->insidetbc) { /* tail call? */
        ((((fs)->f->code[(&e)->u.info])) =
             (((((fs)->f->code[(&e)->u.info])) &
               (~((~((~(Instruction)0) << (7))) << (0)))) |
              ((((Instruction)(OP_TAILCALL)) << 0) &
               ((~((~(Instruction)0) << (7))) << (0)))));
        ((void)0);
      }
      nret = (-1); /* return all values */
    } else {
      if (nret == 1)                     /* only one single value? */
        first = luaK_exp2anyreg(fs, &e); /* can use original slot */
      else { /* values must go to the top of the stack */
        luaK_exp2nextreg(fs, &e);
        ((void)0);
      }
    }
  }
  luaK_ret(fs, first, nret);
  testnext(ls, ';'); /* skip optional semicolon */
}

static void statement(LexState *ls) {
  int line = ls->linenumber; /* may be needed for error messages */
  luaE_enterCcall((ls)->L);
  switch (ls->t.token) {
  case ';': {      /* stat -> ';' (empty statement) */
    luaX_next(ls); /* skip ';' */
    break;
  }
  case TK_IF: { /* stat -> ifstat */
    ifstat(ls, line);
    break;
  }
  case TK_WHILE: { /* stat -> whilestat */
    whilestat(ls, line);
    break;
  }
  case TK_DO: {    /* stat -> DO block END */
    luaX_next(ls); /* skip DO */
    block(ls);
    check_match(ls, TK_END, TK_DO, line);
    break;
  }
  case TK_FOR: { /* stat -> forstat */
    forstat(ls, line);
    break;
  }
  case TK_REPEAT: { /* stat -> repeatstat */
    repeatstat(ls, line);
    break;
  }
  case TK_FUNCTION: { /* stat -> funcstat */
    funcstat(ls, line);
    break;
  }
  case TK_LOCAL: {                 /* stat -> localstat */
    luaX_next(ls);                 /* skip LOCAL */
    if (testnext(ls, TK_FUNCTION)) /* local function? */
      localfunc(ls);
    else
      localstat(ls);
    break;
  }
  case TK_DBCOLON: { /* stat -> label */
    luaX_next(ls);   /* skip double colon */
    labelstat(ls, str_checkname(ls), line);
    break;
  }
  case TK_RETURN: { /* stat -> retstat */
    luaX_next(ls);  /* skip RETURN */
    retstat(ls);
    break;
  }
  case TK_BREAK: { /* stat -> breakstat */
    breakstat(ls);
    break;
  }
  case TK_GOTO: {  /* stat -> 'goto' NAME */
    luaX_next(ls); /* skip 'goto' */
    gotostat(ls);
    break;
  }
  default: { /* stat -> func | assignment */
    exprstat(ls);
    break;
  }
  }
  ((void)0);
  ls->fs->freereg = ls->fs->nactvar; /* free registers */
  (((ls)->L)->nCcalls--);
}

/* }====================================================================== */

/*
** compiles the main function, which is a regular vararg function with an
** upvalue named LUA_ENV
*/
static void mainfunc(LexState *ls, FuncState *fs) {
  BlockCnt bl;
  expdesc v;
  open_func(ls, fs, &bl);
  setvararg(fs, 0);             /* main function is always declared vararg */
  init_exp(&v, VLOCAL, 0);      /* create and... */
  newupvalue(fs, ls->envn, &v); /* ...set environment upvalue */
  luaX_next(ls);                /* read first token */
  statlist(ls);                 /* parse main body */
  check(ls, TK_EOS);
  close_func(ls);
}

LClosure *luaY_parser(lua_State *L, ZIO *z, Mbuffer *buff, Dyndata *dyd,
                      const char *name, int firstchar) {
  LexState lexstate;
  FuncState funcstate;
  LClosure *cl = luaF_newLclosure(L, 1); /* create main closure */
  {
    TValue *io = ((&(L->top)->val));
    LClosure *x_ = (cl);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = ((((6 | (1 << 4)) /* Lua closure */) | (1 << 6))));
    ((void)0);
  }; /* anchor it (to avoid being collected) */
  luaD_inctop(L);
  lexstate.h = luaH_new(L); /* create table for scanner */
  {
    TValue *io = ((&(L->top)->val));
    Table *x_ = (lexstate.h);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((5) | (1 << 6))));
    ((void)0);
  }; /* anchor it */
  luaD_inctop(L);
  funcstate.f = cl->p = luaF_newproto(L);
  funcstate.f->source = luaS_new(L, name); /* create and anchor TString */
  (((((funcstate.f)->marked) & ((1 << (5 /* object is black */)))) &&
    (((funcstate.f->source)->marked) &
     (((1 << (3 /* object is white (type 0) */)) |
       (1 << (4 /* object is white (type 1) */))))))
       ? luaC_barrier_(L, (&(((union GCUnion *)((funcstate.f)))->gc)),
                       (&(((union GCUnion *)((funcstate.f->source)))->gc)))
       : ((void)((0))));
  lexstate.buff = buff;
  lexstate.dyd = dyd;
  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;
  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);
  mainfunc(&lexstate, &funcstate);
  ((void)0);
  /* all scopes should be correctly finished */
  ((void)0);
  L->top--;  /* remove scanner's table */
  return cl; /* closure is on the stack, too */
}
/*
** $Id: ldebug.c $
** Debug Interface
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lapi.h $
** Auxiliary functions from Lua API
** See Copyright Notice in lua.h
*/
/*
** $Id: lcode.h $
** Code generator for Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lfunc.h $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lopcodes.h $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltable.h $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltm.h $
** Tag methods
** See Copyright Notice in lua.h
*/
/*
** $Id: lvm.h $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

/* Active Lua function (given call info) */

static const char *funcnamefromcode(lua_State *L, CallInfo *ci,
                                    const char **name);

static int currentpc(CallInfo *ci) {
  ((void)0);
  return (
      ((int)(((ci->u.l.savedpc) -
              ((((&((((union GCUnion *)(((((&((ci)->func)->val))->value_).gc))))
                        ->cl.l))))
                   ->p)
                  ->code))) -
      1);
}

/*
** Get a "base line" to find the line corresponding to an instruction.
** For that, search the array of absolute line info for the largest saved
** instruction smaller or equal to the wanted instruction. A special
** case is when there is no absolute info or the instruction is before
** the first absolute one.
*/
static int getbaseline(const Proto *f, int pc, int *basepc) {
  if (f->sizeabslineinfo == 0 || pc < f->abslineinfo[0].pc) {
    *basepc = -1; /* start from the beginning */
    return f->linedefined;
  } else {
    unsigned int i;
    if (pc >= f->abslineinfo[f->sizeabslineinfo - 1].pc)
      i = f->sizeabslineinfo - 1; /* instruction is after last saved one */
    else {                        /* binary search */
      unsigned int j = f->sizeabslineinfo - 1; /* pc < anchorlines[j] */
      i = 0;                                   /* abslineinfo[i] <= pc */
      while (i < j - 1) {
        unsigned int m = (j + i) / 2;
        if (pc >= f->abslineinfo[m].pc)
          i = m;
        else
          j = m;
      }
    }
    *basepc = f->abslineinfo[i].pc;
    return f->abslineinfo[i].line;
  }
}

/*
** Get the line corresponding to instruction 'pc' in function 'f';
** first gets a base line and from there does the increments until
** the desired instruction.
*/
int luaG_getfuncline(const Proto *f, int pc) {
  if (f->lineinfo == ((void *)0)) /* no debug information? */
    return -1;
  else {
    int basepc;
    int baseline = getbaseline(f, pc, &basepc);
    while (basepc++ < pc) { /* walk until given instruction */
      ((void)0);
      baseline += f->lineinfo[basepc]; /* correct line */
    }
    return baseline;
  }
}

static int currentline(CallInfo *ci) {
  return luaG_getfuncline(
      (((&((((union GCUnion *)(((((&((ci)->func)->val))->value_).gc))))
               ->cl.l))))
          ->p,
      currentpc(ci));
}

/*
** This function can be called asynchronously (e.g. during a signal),
** under "reasonable" assumptions. A new 'ci' is completely linked
** in the list before it becomes part of the "active" list, and
** we assume that pointers are atomic (see comment in next function).
** (If we traverse one more item, there is no problem. If we traverse
** one less item, the worst that can happen is that the signal will
** not interrupt the script.)
*/
static void settraps(CallInfo *ci) {
  for (; ci != ((void *)0); ci = ci->previous)
    if ((!((ci)->callstatus & (1 << 1) /* call is running a C function */)))
      ci->u.l.trap = 1;
}

/*
** This function can be called asynchronously (e.g. during a signal),
** under "reasonable" assumptions.
** Fields 'oldpc', 'basehookcount', and 'hookcount' (set by
** 'resethookcount') are for debug only, and it is no problem if they
** get arbitrary values (causes at most one wrong hook call). 'hookmask'
** is an atomic value. We assume that pointers are atomic too (e.g., gcc
** ensures that for all platforms where it runs). Moreover, 'hook' is
** always checked before being called (see 'luaD_hook').
*/
extern void lua_sethook(lua_State *L, lua_Hook func, int mask, int count) {
  if (func == ((void *)0) || mask == 0) { /* turn off hooks? */
    mask = 0;
    func = ((void *)0);
  }
  if ((!((L->ci)->callstatus & (1 << 1) /* call is running a C function */)))
    L->oldpc = L->ci->u.l.savedpc;
  L->hook = func;
  L->basehookcount = count;
  (L->hookcount = L->basehookcount);
  L->hookmask = ((lu_byte)((mask)));
  if (mask)
    settraps(L->ci); /* to trace inside 'luaV_execute' */
}

extern lua_Hook lua_gethook(lua_State *L) { return L->hook; }

extern int lua_gethookmask(lua_State *L) { return L->hookmask; }

extern int lua_gethookcount(lua_State *L) { return L->basehookcount; }

extern int lua_getstack(lua_State *L, int level, lua_Debug *ar) {
  int status;
  CallInfo *ci;
  if (level < 0)
    return 0; /* invalid (negative) level */
  ((void)0);
  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)
    level--;
  if (level == 0 && ci != &L->base_ci) { /* level found? */
    status = 1;
    ar->i_ci = ci;
  } else
    status = 0; /* no such level */
  ((void)0);
  return status;
}

static const char *upvalname(const Proto *p, int uv) {
  TString *s = (p->upvalues[uv].name);
  if (s == ((void *)0))
    return "?";
  else
    return (((char *)(((s)))) + sizeof(TString));
}

static const char *findvararg(CallInfo *ci, int n, StkId *pos) {
  if (((&((((union GCUnion *)(((((&(ci->func)->val))->value_).gc))))->cl.l)))
          ->p->is_vararg) {
    int nextra = ci->u.l.nextraargs;
    if (n <= nextra) {
      *pos = ci->func - nextra + (n - 1);
      return "(vararg)"; /* generic name for any vararg */
    }
  }
  return ((void *)0); /* no such vararg */
}

const char *luaG_findlocal(lua_State *L, CallInfo *ci, int n, StkId *pos) {
  StkId base = ci->func + 1;
  const char *name = ((void *)0);
  if ((!((ci)->callstatus & (1 << 1) /* call is running a C function */))) {
    if (n < 0) /* access to vararg values? */
      return findvararg(ci, -n, pos);
    else
      name = luaF_getlocalname(
          (((&((((union GCUnion *)(((((&((ci)->func)->val))->value_).gc))))
                   ->cl.l))))
              ->p,
          n, currentpc(ci));
  }
  if (name == ((void *)0)) { /* no 'standard' name? */
    StkId limit = (ci == L->ci) ? L->top : ci->next->func;
    if (limit - base >= n && n > 0) { /* is 'n' inside 'ci' stack? */
      /* generic name for any valid slot */
      name = (!((ci)->callstatus & (1 << 1) /* call is running a C function */))
                 ? "(temporary)"
                 : "(C temporary)";
    } else
      return ((void *)0); /* no name */
  }
  if (pos)
    *pos = base + (n - 1);
  return name;
}

extern const char *lua_getlocal(lua_State *L, const lua_Debug *ar, int n) {
  const char *name;
  ((void)0);
  if (ar == ((void *)0)) { /* information about non-active function? */
    if (!(((((&(L->top - 1)->val)))->tt_) ==
          ((((6 | (1 << 4)) /* Lua closure */) |
            (1 << 6))))) /* not a Lua function? */
      name = ((void *)0);
    else /* consider live variables at function start (parameters) */
      name = luaF_getlocalname(
          ((&((((union GCUnion *)(((((&(L->top - 1)->val))->value_).gc))))
                  ->cl.l)))
              ->p,
          n, 0);
  } else {                   /* active function; get information through 'ar' */
    StkId pos = ((void *)0); /* to avoid warnings */
    name = luaG_findlocal(L, ar->i_ci, n, &pos);
    if (name) {
      {
        TValue *io1 = ((&(L->top)->val));
        const TValue *io2 = ((&(pos)->val));
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      {
        L->top++;
        ((void)0);
      };
    }
  }
  ((void)0);
  return name;
}

extern const char *lua_setlocal(lua_State *L, const lua_Debug *ar, int n) {
  StkId pos = ((void *)0); /* to avoid warnings */
  const char *name;
  ((void)0);
  name = luaG_findlocal(L, ar->i_ci, n, &pos);
  if (name) {
    {
      TValue *io1 = ((&(pos)->val));
      const TValue *io2 = ((&(L->top - 1)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    L->top--; /* pop value */
  }
  ((void)0);
  return name;
}

static void funcinfo(lua_Debug *ar, Closure *cl) {
  if (((cl) == ((void *)0) || (cl)->c.tt == (6 | (3 << 4)) /* C closure */)) {
    ar->source = "=[C]";
    ar->srclen = (sizeof("=[C]") / sizeof(char) - 1);
    ar->linedefined = -1;
    ar->lastlinedefined = -1;
    ar->what = "C";
  } else {
    const Proto *p = cl->l.p;
    if (p->source) {
      ar->source = (((char *)(((p->source)))) + sizeof(TString));
      ar->srclen =
          ((p->source)->tt == (4 | (1 << 4)) /* short strings */ ? (p->source)
                                                                       ->shrlen
                                                                 : (p->source)
                                                                       ->u
                                                                       .lnglen);
    } else {
      ar->source = "=?";
      ar->srclen = (sizeof("=?") / sizeof(char) - 1);
    }
    ar->linedefined = p->linedefined;
    ar->lastlinedefined = p->lastlinedefined;
    ar->what = (ar->linedefined == 0) ? "main" : "Lua";
  }
  luaO_chunkid(ar->short_src, ar->source, ar->srclen);
}

static int nextline(const Proto *p, int currentline, int pc) {
  if (p->lineinfo[pc] != (-0x80))
    return currentline + p->lineinfo[pc];
  else
    return luaG_getfuncline(p, pc);
}

static void collectvalidlines(lua_State *L, Closure *f) {
  if (((f) == ((void *)0) || (f)->c.tt == (6 | (3 << 4)) /* C closure */)) {
    (((&(L->top)->val))->tt_ = (0));
    {
      L->top++;
      ((void)0);
    };
  } else {
    int i;
    TValue v;
    const Proto *p = f->l.p;
    int currentline = p->linedefined;
    Table *t = luaH_new(L); /* new table to store active lines */
    {
      TValue *io = ((&(L->top)->val));
      Table *x_ = (t);
      ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
      ((io)->tt_ = (((5) | (1 << 6))));
      ((void)0);
    }; /* push it on stack */
    {
      L->top++;
      ((void)0);
    };
    {
      TValue *io = (&v);
      ((io)->value_).b = (1);
      ((io)->tt_ = (1));
    }; /* boolean 'true' to be the value of all indices */
    for (i = 0; i < p->sizelineinfo; i++) { /* for all lines with code */
      currentline = nextline(p, currentline, i);
      luaH_setint(L, t, currentline, &v); /* table[line] = true */
    }
  }
}

static const char *getfuncname(lua_State *L, CallInfo *ci, const char **name) {
  if (ci == ((void *)0)) /* no 'ci'? */
    return ((void *)0);  /* no info */
  else if (ci->callstatus &
           (1 << 6) /* call is running a finalizer */) { /* is this a finalizer?
                                                          */
    *name = "__gc";
    return "metamethod"; /* report it as such */
  }
  /* calling function is a known Lua function? */
  else if (!(ci->callstatus & (1 << 4) /* call was tail called */) &&
           (!((ci->previous)->callstatus &
              (1 << 1) /* call is running a C function */)))
    return funcnamefromcode(L, ci->previous, name);
  else
    return ((void *)0); /* no way to find a name */
}

static int auxgetinfo(lua_State *L, const char *what, lua_Debug *ar, Closure *f,
                      CallInfo *ci) {
  int status = 1;
  for (; *what; what++) {
    switch (*what) {
    case 'S': {
      funcinfo(ar, f);
      break;
    }
    case 'l': {
      ar->currentline =
          (ci &&
           (!((ci)->callstatus & (1 << 1) /* call is running a C function */)))
              ? currentline(ci)
              : -1;
      break;
    }
    case 'u': {
      ar->nups = (f == ((void *)0)) ? 0 : f->c.nupvalues;
      if (((f) == ((void *)0) || (f)->c.tt == (6 | (3 << 4)) /* C closure */)) {
        ar->isvararg = 1;
        ar->nparams = 0;
      } else {
        ar->isvararg = f->l.p->is_vararg;
        ar->nparams = f->l.p->numparams;
      }
      break;
    }
    case 't': {
      ar->istailcall =
          (ci) ? ci->callstatus & (1 << 4) /* call was tail called */ : 0;
      break;
    }
    case 'n': {
      ar->namewhat = getfuncname(L, ci, &ar->name);
      if (ar->namewhat == ((void *)0)) {
        ar->namewhat = ""; /* not found */
        ar->name = ((void *)0);
      }
      break;
    }
    case 'r': {
      if (ci == ((void *)0) ||
          !(ci->callstatus & (1 << 7) /* 'ci' has transfer information */))
        ar->ftransfer = ar->ntransfer = 0;
      else {
        ar->ftransfer = ci->u2.transferinfo.ftransfer;
        ar->ntransfer = ci->u2.transferinfo.ntransfer;
      }
    }
    case 'L':
    case 'f': /* handled by lua_getinfo */
      break;
    default:
      status = 0; /* invalid option */
    }
  }
  return status;
}

extern int lua_getinfo(lua_State *L, const char *what, lua_Debug *ar) {
  int status;
  Closure *cl;
  CallInfo *ci;
  TValue *func;
  ((void)0);
  if (*what == '>') {
    ci = ((void *)0);
    func = (&(L->top - 1)->val);
    ((void)0);
    what++;   /* skip the '>' */
    L->top--; /* pop function */
  } else {
    ci = ar->i_ci;
    func = (&(ci->func)->val);
    ((void)0);
  }
  cl = ((((func)->tt_) & 0x1F) == (6 | (1 << 4)) /* Lua closure */)
           ? ((&((((union GCUnion *)((((func)->value_).gc))))->cl)))
           : ((void *)0);
  status = auxgetinfo(L, what, ar, cl, ci);
  if (strchr(what, 'f')) {
    {
      TValue *io1 = ((&(L->top)->val));
      const TValue *io2 = (func);
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    {
      L->top++;
      ((void)0);
    };
  }
  if (strchr(what, 'L'))
    collectvalidlines(L, cl);
  ((void)0);
  return status;
}

/*
** {======================================================
** Symbolic Execution
** =======================================================
*/

static const char *getobjname(const Proto *p, int lastpc, int reg,
                              const char **name);

/*
** Find a "name" for the constant 'c'.
*/
static void kname(const Proto *p, int c, const char **name) {
  TValue *kvalue = &p->k[c];
  *name =
      ((((((((kvalue))->tt_)) & 0x0F)) == (4)))
          ? (((char *)(((
                 ((&((((union GCUnion *)((((kvalue)->value_).gc))))->ts))))))) +
             sizeof(TString))
          : "?";
}

/*
** Find a "name" for the register 'c'.
*/
static void rname(const Proto *p, int pc, int c, const char **name) {
  const char *what = getobjname(p, pc, c, name); /* search for 'c' */
  if (!(what && *what == 'c')) /* did not find a constant name? */
    *name = "?";
}

/*
** Find a "name" for a 'C' value in an RK instruction.
*/
static void rkname(const Proto *p, int pc, Instruction i, const char **name) {
  int c = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                    ((~((~(Instruction)0) << (8))) << (0))))))); /* key index */
  if (((((int)((
          ((i) >> (((0 + 7) + 8))) &
          ((~((~(Instruction)0) << (1))) << (0)))))))) /* is 'c' a constant? */
    kname(p, c, name);
  else /* 'c' is a register */
    rname(p, pc, c, name);
}

static int filterpc(int pc, int jmptarget) {
  if (pc < jmptarget) /* is code conditional (inside a jump)? */
    return -1;        /* cannot know who sets that register */
  else
    return pc; /* current position sets that register */
}

/*
** try to find last instruction before 'lastpc' that modified register 'reg'
*/
static int findsetreg(const Proto *p, int lastpc, int reg) {
  int pc;
  int setreg = -1;   /* keep last instruction that changed 'reg' */
  int jmptarget = 0; /* any code before this address is conditional */
  for (pc = 0; pc < lastpc; pc++) {
    Instruction i = p->code[pc];
    OpCode op =
        (((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))));
    int a = ((
        (int)((((i) >> ((0 + 7))) & ((~((~(Instruction)0) << (8))) << (0))))));
    int change; /* true if current instruction changed 'reg' */
    switch (op) {
    case OP_LOADNIL: { /* set registers from 'a' to 'a+b' */
      int b = ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                        ((~((~(Instruction)0) << (8))) << (0)))))));
      change = (a <= reg && reg <= a + b);
      break;
    }
    case OP_TFORCALL: { /* affect all regs above its base */
      change = (reg >= a + 2);
      break;
    }
    case OP_CALL:
    case OP_TAILCALL: { /* affect all registers above base */
      change = (reg >= a);
      break;
    }
    case OP_JMP: { /* doesn't change registers, but changes 'jmptarget' */
      int b =
          ((((int)((((i) >> ((0 + 7))) &
                    ((~((~(Instruction)0) << (((8 + 8 + 1) + 8)))) << (0)))))) -
           (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1));
      int dest = pc + 1 + b;
      /* jump does not skip 'lastpc' and is larger than current one? */
      if (dest <= lastpc && dest > jmptarget)
        jmptarget = dest; /* update 'jmptarget' */
      change = 0;
      break;
    }
    default: /* any instruction that sets A */
      change = ((luaP_opmodes[op] & (1 << 3)) && reg == a);
      break;
    }
    if (change)
      setreg = filterpc(pc, jmptarget);
  }
  return setreg;
}

/*
** Check whether table being indexed by instruction 'i' is the
** environment '_ENV'
*/
static const char *gxf(const Proto *p, int pc, Instruction i, int isup) {
  int t =
      ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                ((~((~(Instruction)0) << (8))) << (0))))))); /* table index */
  const char *name; /* name of indexed variable */
  if (isup)         /* is an upvalue? */
    name = upvalname(p, t);
  else
    getobjname(p, pc, t, &name);
  return (name && strcmp(name, "_ENV") == 0) ? "global" : "field";
}

const char *getobjname(const Proto *p, int lastpc, int reg, const char **name) {
  int pc;
  *name = luaF_getlocalname(p, reg + 1, lastpc);
  if (*name) /* is a local? */
    return "local";
  /* else try symbolic execution */
  pc = findsetreg(p, lastpc, reg);
  if (pc != -1) { /* could find instruction? */
    Instruction i = p->code[pc];
    OpCode op =
        (((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))));
    switch (op) {
    case OP_MOVE: {
      int b = ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                        ((~((~(Instruction)0) << (8)))
                         << (0))))))); /* move from 'b' to 'a' */
      if (b < (((int)((((i) >> ((0 + 7))) &
                       ((~((~(Instruction)0) << (8))) << (0)))))))
        return getobjname(p, pc, b, name); /* get name for 'b' */
      break;
    }
    case OP_GETTABUP: {
      int k =
          ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                    ((~((~(Instruction)0) << (8))) << (0))))))); /* key index */
      kname(p, k, name);
      return gxf(p, pc, i, 1);
    }
    case OP_GETTABLE: {
      int k =
          ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                    ((~((~(Instruction)0) << (8))) << (0))))))); /* key index */
      rname(p, pc, k, name);
      return gxf(p, pc, i, 0);
    }
    case OP_GETI: {
      *name = "integer index";
      return "field";
    }
    case OP_GETFIELD: {
      int k =
          ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                    ((~((~(Instruction)0) << (8))) << (0))))))); /* key index */
      kname(p, k, name);
      return gxf(p, pc, i, 0);
    }
    case OP_GETUPVAL: {
      *name =
          upvalname(p, ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0))))))));
      return "upvalue";
    }
    case OP_LOADK:
    case OP_LOADKX: {
      int b =
          (op == OP_LOADK)
              ? ((((int)((((i) >> (((0 + 7) + 8))) &
                          ((~((~(Instruction)0) << ((8 + 8 + 1)))) << (0)))))))
              : ((((int)((
                    ((p->code[pc + 1]) >> ((0 + 7))) &
                    ((~((~(Instruction)0) << (((8 + 8 + 1) + 8)))) << (0)))))));
      if ((((((((&p->k[b]))->tt_)) & 0x0F)) == (4))) {
        *name =
            (((char *)(((((
                 &((((union GCUnion *)((((&p->k[b])->value_).gc))))->ts))))))) +
             sizeof(TString));
        return "constant";
      }
      break;
    }
    case OP_SELF: {
      rkname(p, pc, i, name);
      return "method";
    }
    default:
      break; /* go through to return NULL */
    }
  }
  return ((void *)0); /* could not find reasonable name */
}

/*
** Try to find a name for a function based on the code that called it.
** (Only works when function was called by a Lua function.)
** Returns what the name is (e.g., "for iterator", "method",
** "metamethod") and sets '*name' to point to the name.
*/
static const char *funcnamefromcode(lua_State *L, CallInfo *ci,
                                    const char **name) {
  TMS tm = (TMS)0; /* (initial value avoids warnings) */
  const Proto *p =
      (((&((((union GCUnion *)(((((&((ci)->func)->val))->value_).gc))))
               ->cl.l))))
          ->p;                 /* calling function */
  int pc = currentpc(ci);      /* calling instruction index */
  Instruction i = p->code[pc]; /* calling instruction */
  if (ci->callstatus &
      (1 << 2) /* call is running a debug hook */) { /* was it called inside a
                                                        hook? */
    *name = "?";
    return "hook";
  }
  switch ((((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))) {
  case OP_CALL:
  case OP_TAILCALL:
    return getobjname(p, pc,
                      (((int)((((i) >> ((0 + 7))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))),
                      name); /* get function name */
  case OP_TFORCALL: {        /* for iterator */
    *name = "for iterator";
    return "for iterator";
  }
  /* other instructions can do calls through metamethods */
  case OP_SELF:
  case OP_GETTABUP:
  case OP_GETTABLE:
  case OP_GETI:
  case OP_GETFIELD:
    tm = TM_INDEX;
    break;
  case OP_SETTABUP:
  case OP_SETTABLE:
  case OP_SETI:
  case OP_SETFIELD:
    tm = TM_NEWINDEX;
    break;
  case OP_ADDI:
  case OP_SUBI:
  case OP_MULI:
  case OP_MODI:
  case OP_POWI:
  case OP_DIVI:
  case OP_IDIVI: {
    int offset =
        (((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0))))) -
        OP_ADDI;                   /* ORDER OP */
    tm = ((TMS)(offset + TM_ADD)); /* ORDER TM */
    break;
  }
  case OP_ADDK:
  case OP_SUBK:
  case OP_MULK:
  case OP_MODK:
  case OP_POWK:
  case OP_DIVK:
  case OP_IDIVK:
  case OP_BANDK:
  case OP_BORK:
  case OP_BXORK: {
    int offset =
        (((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0))))) -
        OP_ADDK;                   /* ORDER OP */
    tm = ((TMS)(offset + TM_ADD)); /* ORDER TM */
    break;
  }
  case OP_ADD:
  case OP_SUB:
  case OP_MUL:
  case OP_MOD:
  case OP_POW:
  case OP_DIV:
  case OP_IDIV:
  case OP_BAND:
  case OP_BOR:
  case OP_BXOR:
  case OP_SHL:
  case OP_SHR: {
    int offset =
        (((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0))))) -
        OP_ADD;                    /* ORDER OP */
    tm = ((TMS)(offset + TM_ADD)); /* ORDER TM */
    break;
  }
  case OP_UNM:
    tm = TM_UNM;
    break;
  case OP_BNOT:
    tm = TM_BNOT;
    break;
  case OP_LEN:
    tm = TM_LEN;
    break;
  case OP_CONCAT:
    tm = TM_CONCAT;
    break;
  case OP_EQ:
    tm = TM_EQ;
    break;
  case OP_LT:
  case OP_LE:
  case OP_LTI:
  case OP_LEI:
    *name = "order"; /* '<=' can call '__lt', etc. */
    return "metamethod";
  case OP_SHRI:
  case OP_SHLI:
    *name = "shift";
    return "metamethod";
  default:
    return ((void *)0); /* cannot find a reasonable name */
  }
  *name = (((char *)((((L->l_G)->tmname[tm])))) + sizeof(TString)) + 2;
  return "metamethod";
}

/* }====================================================== */

/*
** The subtraction of two potentially unrelated pointers is
** not ISO C, but it should not crash a program; the subsequent
** checks are ISO C and ensure a correct result.
*/
static int isinstack(CallInfo *ci, const TValue *o) {
  StkId base = ci->func + 1;
  ptrdiff_t i = ((StkId)(o)) - base;
  return (0 <= i && i < (ci->top - base) && (&(base + i)->val) == o);
}

/*
** Checks whether value 'o' came from an upvalue. (That can only happen
** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on
** upvalues.)
*/
static const char *getupvalname(CallInfo *ci, const TValue *o,
                                const char **name) {
  LClosure *c = ((
      (&((((union GCUnion *)(((((&((ci)->func)->val))->value_).gc))))->cl.l))));
  int i;
  for (i = 0; i < c->nupvalues; i++) {
    if (c->upvals[i]->v == o) {
      *name = upvalname(c->p, i);
      return "upvalue";
    }
  }
  return ((void *)0);
}

static const char *varinfo(lua_State *L, const TValue *o) {
  const char *name = ((void *)0); /* to avoid warnings */
  CallInfo *ci = L->ci;
  const char *kind = ((void *)0);
  if ((!((ci)->callstatus & (1 << 1) /* call is running a C function */))) {
    kind = getupvalname(ci, o, &name); /* check whether 'o' is an upvalue */
    if (!kind && isinstack(ci, o))     /* no? try a register */
      kind = getobjname(
          (((&((((union GCUnion *)(((((&((ci)->func)->val))->value_).gc))))
                   ->cl.l))))
              ->p,
          currentpc(ci), ((int)((((StkId)(o)) - (ci->func + 1)))), &name);
  }
  return (kind) ? luaO_pushfstring(L, " (%s '%s')", kind, name) : "";
}

void __attribute__((noreturn))
luaG_typeerror(lua_State *L, const TValue *o, const char *op) {
  const char *t = luaT_objtypename(L, o);
  luaG_runerror(L, "attempt to %s a %s value%s", op, t, varinfo(L, o));
}

void __attribute__((noreturn))
luaG_forerror(lua_State *L, const TValue *o, const char *what) {
  luaG_runerror(L, "bad 'for' %s (number expected, got %s)", what,
                luaT_objtypename(L, o));
}

void __attribute__((noreturn))
luaG_concaterror(lua_State *L, const TValue *p1, const TValue *p2) {
  if ((((((((p1))->tt_)) & 0x0F)) == (4)) ||
      (((((((p1))->tt_)) & 0x0F)) == (3)))
    p1 = p2;
  luaG_typeerror(L, p1, "concatenate");
}

void __attribute__((noreturn))
luaG_opinterror(lua_State *L, const TValue *p1, const TValue *p2,
                const char *msg) {
  if (!(((((((p1))->tt_)) & 0x0F)) == (3))) /* first operand is wrong? */
    p2 = p1;                                /* now second is wrong */
  luaG_typeerror(L, p2, msg);
}

/*
** Error when both values are convertible to numbers, but not to integers
*/
void __attribute__((noreturn))
luaG_tointerror(lua_State *L, const TValue *p1, const TValue *p2) {
  lua_Integer temp;
  if (!(((((p1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
            ? (*(&temp) = (((p1)->value_).i), 1)
            : luaV_tointegerns(p1, &temp, 0)))
    p2 = p1;
  luaG_runerror(L, "number%s has no integer representation", varinfo(L, p2));
}

void __attribute__((noreturn))
luaG_ordererror(lua_State *L, const TValue *p1, const TValue *p2) {
  const char *t1 = luaT_objtypename(L, p1);
  const char *t2 = luaT_objtypename(L, p2);
  if (strcmp(t1, t2) == 0)
    luaG_runerror(L, "attempt to compare two %s values", t1);
  else
    luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
}

/* add src:line information to 'msg' */
const char *luaG_addinfo(lua_State *L, const char *msg, TString *src,
                         int line) {
  char buff[60];
  if (src)
    luaO_chunkid(
        buff, (((char *)(((src)))) + sizeof(TString)),
        ((src)->tt == (4 | (1 << 4)) /* short strings */ ? (src)->shrlen
                                                         : (src)->u.lnglen));
  else { /* no source available; use "?" instead */
    buff[0] = '?';
    buff[1] = '\0';
  }
  return luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
}

void __attribute__((noreturn)) luaG_errormsg(lua_State *L) {
  if (L->errfunc != 0) { /* is there an error handling function? */
    StkId errfunc = ((StkId)((char *)L->stack + (L->errfunc)));
    ((void)0);
    {
      TValue *io1 = ((&(L->top)->val));
      const TValue *io2 = ((&(L->top - 1)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    }; /* move argument */
    {
      TValue *io1 = ((&(L->top - 1)->val));
      const TValue *io2 = ((&(errfunc)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };                                  /* push function */
    L->top++;                           /* assume EXTRA_STACK */
    luaD_callnoyield(L, L->top - 2, 1); /* call it */
  }
  luaD_throw(L, 2);
}

void __attribute__((noreturn))
luaG_runerror(lua_State *L, const char *fmt, ...) {
  CallInfo *ci = L->ci;
  const char *msg;
  va_list argp;
  {
    if ((L->l_G)->GCdebt > 0) {
      (void)0;
      luaC_step(L);
      (void)0;
    };
    ((void)0);
  }; /* error message uses memory */

  __builtin_va_start(argp, fmt);
  msg = luaO_pushvfstring(L, fmt, argp); /* format message */

  __builtin_va_end(argp);
  if ((!((ci)->callstatus &
         (1 << 1) /* call is running a C function */))) /* if Lua function, add
                                                           source:line
                                                           information */
    luaG_addinfo(
        L, msg,
        (((&((((union GCUnion *)(((((&((ci)->func)->val))->value_).gc))))
                 ->cl.l))))
            ->p->source,
        currentline(ci));
  luaG_errormsg(L);
}

/*
** Check whether new instruction 'newpc' is in a different line from
** previous instruction 'oldpc'.
*/
static int changedline(const Proto *p, int oldpc, int newpc) {
  while (oldpc++ < newpc) {
    if (p->lineinfo[oldpc] != 0)
      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));
  }
  return 0; /* no line changes in the way */
}

int luaG_traceexec(lua_State *L, const Instruction *pc) {
  CallInfo *ci = L->ci;
  lu_byte mask = L->hookmask;
  int counthook;
  if (!(mask & ((1 << 2) | (1 << 3)))) { /* no hooks? */
    ci->u.l.trap = 0;                    /* don't need to stop again */
    return 0;                            /* turn off 'trap' */
  }
  pc++;                 /* reference is always next instruction */
  ci->u.l.savedpc = pc; /* save 'pc' */
  counthook = (--L->hookcount == 0 && (mask & (1 << 3)));
  if (counthook)
    (L->hookcount = L->basehookcount); /* reset count */
  else if (!(mask & (1 << 2)))
    return 1; /* no line hook and count != 0; nothing to be done now */
  if (ci->callstatus &
      (1 << 5) /* last hook called yielded */) { /* called hook last time? */
    ci->callstatus &= ~(1 << 5) /* last hook called yielded */; /* erase mark */
    return 1; /* do not call hook again (VM yielded, so it did not move) */
  }
  if (!((luaP_opmodes[(((OpCode)(((*(ci->u.l.savedpc - 1)) >> 0) &
                                 ((~((~(Instruction)0) << (7))) << (0)))))] &
         (1 << 5)) &&
        ((((int)((((*(ci->u.l.savedpc - 1)) >> ((((0 + 7) + 8) + 1))) &
                  ((~((~(Instruction)0) << (8))) << (0))))))) == 0))
    L->top = ci->top; /* prepare top */
  if (counthook)
    luaD_hook(L, 3, -1, 0, 0); /* call count hook */
  if (mask & (1 << 2)) {
    const Proto *p =
        (((&((((union GCUnion *)(((((&((ci)->func)->val))->value_).gc))))
                 ->cl.l))))
            ->p;
    int npci = (((int)(((pc) - (p)->code))) - 1);
    if (npci == 0 ||      /* call linehook when enter a new function, */
        pc <= L->oldpc || /* when jump back (loop), or when */
        changedline(p, (((int)(((L->oldpc) - (p)->code))) - 1),
                    npci)) { /* enter new line */
      int newline = luaG_getfuncline(p, npci);
      luaD_hook(L, 2, newline, 0, 0); /* call line hook */
    }
    L->oldpc = pc; /* 'pc' of last call to line hook */
  }
  if (L->status == 1) { /* did hook yield? */
    if (counthook)
      L->hookcount = 1; /* undo decrement to zero */
    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */
    ci->callstatus |=
        (1 << 5) /* last hook called yielded */; /* mark that it yielded */
    luaD_throw(L, 1);
  }
  return 1; /* keep 'trap' on */
}
/*
** $Id: lfunc.c $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lfunc.h $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/
/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/

CClosure *luaF_newCclosure(lua_State *L, int n) {
  GCObject *o = luaC_newobj(L, (6 | (3 << 4)) /* C closure */,
                            (((int)((__builtin_offsetof(CClosure, upvalue)))) +
                             ((int)((sizeof(TValue)))) * (n)));
  CClosure *c = (&((((union GCUnion *)((o))))->cl.c));
  c->nupvalues = ((lu_byte)((n)));
  return c;
}

LClosure *luaF_newLclosure(lua_State *L, int n) {
  GCObject *o = luaC_newobj(L, (6 | (1 << 4)) /* Lua closure */,
                            (((int)((__builtin_offsetof(LClosure, upvals)))) +
                             ((int)((sizeof(TValue *)))) * (n)));
  LClosure *c = (&((((union GCUnion *)((o))))->cl.l));
  c->p = ((void *)0);
  c->nupvalues = ((lu_byte)((n)));
  while (n--)
    c->upvals[n] = ((void *)0);
  return c;
}

/*
** fill a closure with new closed upvalues
*/
void luaF_initupvals(lua_State *L, LClosure *cl) {
  int i;
  for (i = 0; i < cl->nupvalues; i++) {
    GCObject *o = luaC_newobj(L, 9 /* upvalues */, sizeof(UpVal));
    UpVal *uv = (&((((union GCUnion *)((o))))->upv));
    uv->v = &uv->u.value; /* make it closed */
    ((uv->v)->tt_ = (0));
    cl->upvals[i] = uv;
    (((((cl)->marked) & ((1 << (5 /* object is black */)))) &&
      (((o)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                         (1 << (4 /* object is white (type 1) */))))))
         ? luaC_barrier_(L, (&(((union GCUnion *)((cl)))->gc)),
                         (&(((union GCUnion *)((o)))->gc)))
         : ((void)((0))));
  }
}

/*
** Create a new upvalue with the given tag at the given level,
** and link it to the list of open upvalues of 'L' after entry 'prev'.
**/
static UpVal *newupval(lua_State *L, int tag, StkId level, UpVal **prev) {
  GCObject *o = luaC_newobj(L, tag, sizeof(UpVal));
  UpVal *uv = (&((((union GCUnion *)((o))))->upv));
  UpVal *next = *prev;
  uv->v = (&(level)->val); /* current value lives in the stack */
  uv->u.open.next = next;  /* link it to list of open upvalues */
  uv->u.open.previous = prev;
  if (next)
    next->u.open.previous = &uv->u.open.next;
  *prev = uv;
  if (!(L->twups != L)) { /* thread not in list of threads with upvalues? */
    L->twups = (L->l_G)->twups; /* link it to the list */
    (L->l_G)->twups = L;
  }
  return uv;
}

/*
** Find and reuse, or create if it does not exist, a regular upvalue
** at the given level.
*/
UpVal *luaF_findupval(lua_State *L, StkId level) {
  UpVal **pp = &L->openupval;
  UpVal *p;
  ((void)0);
  while ((p = *pp) != ((void *)0) &&
         (((StkId)((p)->v))) >= level) { /* search for it */
    if ((((StkId)((p)->v))) == level &&
        !(((p)->marked) &
          ((((L->l_G))->currentwhite ^
            ((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */))))))) /* corresponding
                                                               upvalue? */
      return p;                                             /* return it */
    pp = &p->u.open.next;
  }
  /* not found: create a new upvalue after 'pp' */
  return newupval(L, 9 /* upvalues */, level, pp);
}

static void callclose(lua_State *L, void *ud) {
  ((void)(ud));
  luaD_callnoyield(L, L->top - 3, 0);
}

/*
** Prepare closing method plus its arguments for object 'obj' with
** error message 'err'. (This function assumes EXTRA_STACK.)
*/
static int prepclosingmethod(lua_State *L, TValue *obj, TValue *err) {
  StkId top = L->top;
  const TValue *tm = luaT_gettmbyobj(L, obj, TM_CLOSE);
  if ((((((((tm))->tt_)) & 0x0F)) == (0))) /* no metamethod? */
    return 0;                              /* nothing to call */
  {
    TValue *io1 = ((&(top)->val));
    const TValue *io2 = (tm);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  }; /* will call metamethod... */
  {
    TValue *io1 = ((&(top + 1)->val));
    const TValue *io2 = (obj);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  }; /* with 'self' as the 1st argument */
  {
    TValue *io1 = ((&(top + 2)->val));
    const TValue *io2 = (err);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };                /* and error msg. as 2nd argument */
  L->top = top + 3; /* add function and arguments */
  return 1;
}

/*
** Prepare and call a closing method. If status is OK, code is still
** inside the original protected call, and so any error will be handled
** there. Otherwise, a previous error already activated original
** protected call, and so the call to the closing method must be
** protected here. (A status = CLOSEPROTECT behaves like a previous
** error, to also run the closing method in protected mode).
** If status is OK, the call to the closing method will be pushed
** at the top of the stack. Otherwise, values are pushed after
** the 'level' of the upvalue being closed, as everything after
** that won't be used again.
*/
static int callclosemth(lua_State *L, TValue *uv, StkId level, int status) {
  if ((__builtin_expect(((status == 0) != 0), 1))) {
    if (prepclosingmethod(L, uv, &(L->l_G)->nilvalue)) /* something to call? */
      callclose(L, ((void *)0));                       /* call closing method */
    else if (!(((((((uv))->tt_)) & 0x0F)) ==
               (0))) { /* non-closable non-nil value? */
      int idx = ((int)((level - L->ci->func)));
      const char *vname = luaG_findlocal(L, L->ci, idx, ((void *)0));
      if (vname == ((void *)0))
        vname = "?";
      luaG_runerror(L, "attempt to close non-closable variable '%s'", vname);
    }
  } else { /* there was an error */
    /* save error message and set stack top to 'level + 1' */
    luaD_seterrorobj(L, status, level);
    if (prepclosingmethod(L, uv, (&(level)->val))) { /* something to call? */
      int newstatus = luaD_pcall(L, callclose, ((void *)0),
                                 ((char *)(level) - (char *)L->stack), 0);
      if (newstatus != 0)   /* another error when closing? */
        status = newstatus; /* this will be the new error */
    }
    /* else no metamethod; ignore this case and keep original error */
  }
  return status;
}

/*
** Try to create a to-be-closed upvalue
** (can raise a memory-allocation error)
*/
static void trynewtbcupval(lua_State *L, void *ud) {
  StkId level = ((StkId)(ud));
  ((void)0);
  newupval(L, (9 /* upvalues */ | (1 << 4)), level, &L->openupval);
}

/*
** Create a to-be-closed upvalue. If there is a memory error
** when creating the upvalue, the closing method must be called here,
** as there is no upvalue to call it later.
*/
void luaF_newtbcupval(lua_State *L, StkId level) {
  int status = luaD_rawrunprotected(L, trynewtbcupval, level);
  if ((__builtin_expect(((status != 0) != 0),
                        0))) { /* memory error creating upvalue? */
    ((void)0);
    luaD_seterrorobj(L, 4, level + 1); /* save error message */
    if (prepclosingmethod(L, (&(level)->val), (&(level + 1)->val)))
      callclose(L, ((void *)0)); /* call closing method */
    luaD_throw(L, 4);            /* throw memory error */
  }
}

void luaF_unlinkupval(UpVal *uv) {
  ((void)0);
  *uv->u.open.previous = uv->u.open.next;
  if (uv->u.open.next)
    uv->u.open.next->u.open.previous = uv->u.open.previous;
}

int luaF_close(lua_State *L, StkId level, int status) {
  UpVal *uv;
  while ((uv = L->openupval) != ((void *)0) && (((StkId)((uv)->v))) >= level) {
    StkId upl = (((StkId)((uv)->v)));
    TValue *slot = &uv->u.value; /* new position for value */
    luaF_unlinkupval(uv);
    {
      TValue *io1 = (slot);
      const TValue *io2 = (uv->v);
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };            /* move value to upvalue slot */
    uv->v = slot; /* now current value lives here */
    if (!(((uv)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                             (1 << (4 /* object is white (type 1) */))))))
      (((uv)->marked) |=
       ((1 << (5 /* object is black */)))); /* closed upvalues cannot be gray */
    (((((slot)->tt_) & (1 << 6)) &&
      (((uv)->marked) & ((1 << (5 /* object is black */)))) &&
      ((((((slot)->value_).gc))->marked) &
       (((1 << (3 /* object is white (type 0) */)) |
         (1 << (4 /* object is white (type 1) */))))))
         ? luaC_barrier_(L, (&(((union GCUnion *)((uv)))->gc)),
                         (((slot)->value_).gc))
         : ((void)((0))));
    if (uv->tt == (9 /* upvalues */ | (1 << 4)) && status != (-1)) {
      /* must run closing method */
      ptrdiff_t levelrel = ((char *)(level) - (char *)L->stack);
      status = callclosemth(L, uv->v, upl, status); /* may change the stack */
      level = ((StkId)((char *)L->stack + (levelrel)));
    }
  }
  return status;
}

Proto *luaF_newproto(lua_State *L) {
  GCObject *o =
      luaC_newobj(L, (9 + 1) /* function prototypes */, sizeof(Proto));
  Proto *f = (&((((union GCUnion *)((o))))->p));
  f->k = ((void *)0);
  f->sizek = 0;
  f->p = ((void *)0);
  f->sizep = 0;
  f->code = ((void *)0);
  f->sizecode = 0;
  f->lineinfo = ((void *)0);
  f->sizelineinfo = 0;
  f->abslineinfo = ((void *)0);
  f->sizeabslineinfo = 0;
  f->upvalues = ((void *)0);
  f->sizeupvalues = 0;
  f->numparams = 0;
  f->is_vararg = 0;
  f->maxstacksize = 0;
  f->locvars = ((void *)0);
  f->sizelocvars = 0;
  f->linedefined = 0;
  f->lastlinedefined = 0;
  f->source = ((void *)0);
  return f;
}

void luaF_freeproto(lua_State *L, Proto *f) {
  luaM_free_(L, (f->code), (f->sizecode) * sizeof(*(f->code)));
  luaM_free_(L, (f->p), (f->sizep) * sizeof(*(f->p)));
  luaM_free_(L, (f->k), (f->sizek) * sizeof(*(f->k)));
  luaM_free_(L, (f->lineinfo), (f->sizelineinfo) * sizeof(*(f->lineinfo)));
  luaM_free_(L, (f->abslineinfo),
             (f->sizeabslineinfo) * sizeof(*(f->abslineinfo)));
  luaM_free_(L, (f->locvars), (f->sizelocvars) * sizeof(*(f->locvars)));
  luaM_free_(L, (f->upvalues), (f->sizeupvalues) * sizeof(*(f->upvalues)));
  luaM_free_(L, (f), sizeof(*(f)));
}

/*
** Look for n-th local variable at line 'line' in function 'func'.
** Returns NULL if not found.
*/
const char *luaF_getlocalname(const Proto *f, int local_number, int pc) {
  int i;
  for (i = 0; i < f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
    if (pc < f->locvars[i].endpc) { /* is variable active? */
      local_number--;
      if (local_number == 0)
        return (((char *)(((f->locvars[i].varname)))) + sizeof(TString));
    }
  }
  return ((void *)0); /* not found */
}
/*
** $Id: lobject.c $
** Some generic functions over Lua objects
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
        locale.h
        Values appropriate for the formatting of monetary and other
        numberic quantities.
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lctype.h $
** 'ctype' functions for Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: lvm.h $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

/*
** converts an integer to a "floating point byte", represented as
** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
** eeeee != 0 and (xxx) otherwise.
*/
int luaO_int2fb(unsigned int x) {
  int e = 0; /* exponent */
  if (x < 8)
    return x;
  while (x >= (8 << 4)) { /* coarse steps */
    x = (x + 0xf) >> 4;   /* x = ceil(x / 16) */
    e += 4;
  }
  while (x >= (8 << 1)) { /* fine steps */
    x = (x + 1) >> 1;     /* x = ceil(x / 2) */
    e++;
  }
  return ((e + 1) << 3) | (((int)((x))) - 8);
}

/* converts back */
int luaO_fb2int(int x) { return (x < 8) ? x : ((x & 7) + 8) << ((x >> 3) - 1); }

/*
** Computes ceil(log2(x))
*/
int luaO_ceillog2(unsigned int x) {
  static const lu_byte log_2[256] = {
      /* log_2[i] = ceil(log2(i - 1)) */
      0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};
  int l = 0;
  x--;
  while (x >= 256) {
    l += 8;
    x >>= 8;
  }
  return l + log_2[x];
}

static lua_Integer intarith(lua_State *L, int op, lua_Integer v1,
                            lua_Integer v2) {
  switch (op) {
  case 0 /* ORDER TM, ORDER OP */:
    return ((lua_Integer)(((lua_Unsigned)(v1)) + ((lua_Unsigned)(v2))));
  case 1:
    return ((lua_Integer)(((lua_Unsigned)(v1)) - ((lua_Unsigned)(v2))));
  case 2:
    return ((lua_Integer)(((lua_Unsigned)(v1)) * ((lua_Unsigned)(v2))));
  case 3:
    return luaV_mod(L, v1, v2);
  case 6:
    return luaV_idiv(L, v1, v2);
  case 7:
    return ((lua_Integer)(((lua_Unsigned)(v1)) & ((lua_Unsigned)(v2))));
  case 8:
    return ((lua_Integer)(((lua_Unsigned)(v1)) | ((lua_Unsigned)(v2))));
  case 9:
    return ((lua_Integer)(((lua_Unsigned)(v1)) ^ ((lua_Unsigned)(v2))));
  case 10:
    return luaV_shiftl(v1, v2);
  case 11:
    return luaV_shiftl(v1, -v2);
  case 12:
    return ((lua_Integer)(((lua_Unsigned)(0)) - ((lua_Unsigned)(v1))));
  case 13:
    return ((lua_Integer)(((lua_Unsigned)(~((lua_Unsigned)(0)))) ^
                          ((lua_Unsigned)(v1))));
  default:
    ((void)0);
    return 0;
  }
}

static lua_Number numarith(lua_State *L, int op, lua_Number v1, lua_Number v2) {
  switch (op) {
  case 0 /* ORDER TM, ORDER OP */:
    return ((v1) + (v2));
  case 1:
    return ((v1) - (v2));
  case 2:
    return ((v1) * (v2));
  case 5:
    return ((v1) / (v2));
  case 4:
    return ((void)L, pow(v1, v2));
  case 6:
    return ((void)L, (floor(((v1) / (v2)))));
  case 12:
    return (-(v1));
  case 3:
    return luaV_modf(L, v1, v2);
  default:
    ((void)0);
    return 0;
  }
}

int luaO_rawarith(lua_State *L, int op, const TValue *p1, const TValue *p2,
                  TValue *res) {
  switch (op) {
  case 7:
  case 8:
  case 9:
  case 10:
  case 11:
  case 13: { /* operate only on integers */
    lua_Integer i1;
    lua_Integer i2;
    if ((((((p1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
             ? (*(&i1) = (((p1)->value_).i), 1)
             : luaV_tointegerns(p1, &i1, 0)) &&
        (((((p2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
             ? (*(&i2) = (((p2)->value_).i), 1)
             : luaV_tointegerns(p2, &i2, 0))) {
      {
        TValue *io = (res);
        ((io)->value_).i = (intarith(L, op, i1, i2));
        ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
      };
      return 1;
    } else
      return 0; /* fail */
  }
  case 5:
  case 4: { /* operate only on floats */
    lua_Number n1;
    lua_Number n2;
    if ((((((p1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
             ? ((n1) = (((p1)->value_).n), 1)
             : (((((p1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                    ? ((n1) = ((lua_Number)(((((p1)->value_).i)))), 1)
                    : 0)) &&
        (((((p2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
             ? ((n2) = (((p2)->value_).n), 1)
             : (((((p2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                    ? ((n2) = ((lua_Number)(((((p2)->value_).i)))), 1)
                    : 0))) {
      {
        TValue *io = (res);
        ((io)->value_).n = (numarith(L, op, n1, n2));
        ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
      };
      return 1;
    } else
      return 0; /* fail */
  }
  default: { /* other operations */
    lua_Number n1;
    lua_Number n2;
    if (((((p1))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
        ((((p2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
      {
        TValue *io = (res);
        ((io)->value_).i =
            (intarith(L, op, (((p1)->value_).i), (((p2)->value_).i)));
        ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
      };
      return 1;
    } else if ((((((p1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                    ? ((n1) = (((p1)->value_).n), 1)
                    : (((((p1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                           ? ((n1) = ((lua_Number)(((((p1)->value_).i)))), 1)
                           : 0)) &&
               (((((p2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                    ? ((n2) = (((p2)->value_).n), 1)
                    : (((((p2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                           ? ((n2) = ((lua_Number)(((((p2)->value_).i)))), 1)
                           : 0))) {
      {
        TValue *io = (res);
        ((io)->value_).n = (numarith(L, op, n1, n2));
        ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
      };
      return 1;
    } else
      return 0; /* fail */
  }
  }
}

void luaO_arith(lua_State *L, int op, const TValue *p1, const TValue *p2,
                StkId res) {
  if (!luaO_rawarith(L, op, p1, p2, (&(res)->val))) {
    /* could not perform raw operation; try metamethod */
    luaT_trybinTM(L, p1, p2, res,
                  ((TMS)((op - 0 /* ORDER TM, ORDER OP */) + TM_ADD)));
  }
}

int luaO_hexavalue(int c) {
  if ((luai_ctype_[(c) + 1] & ((1 << (1)))))
    return c - '0';
  else
    return (((c) | ('A' ^ 'a')) - 'a') + 10;
}

static int isneg(const char **s) {
  if (**s == '-') {
    (*s)++;
    return 1;
  } else if (**s == '+')
    (*s)++;
  return 0;
}

/*
** {==================================================================
** Lua's implementation for 'lua_strx2number'
** ===================================================================
*/
/* }====================================================== */

/* maximum length of a numeral */

static const char *l_str2dloc(const char *s, lua_Number *result, int mode) {
  char *endptr;
  *result = (mode == 'x') ? strtod((s), (&endptr)) /* try to convert */
                          : strtod((s), (&endptr));
  if (endptr == s)
    return ((void *)0); /* nothing recognized? */
  while ((luai_ctype_[(((unsigned char)((*endptr)))) + 1] & ((1 << (3)))))
    endptr++; /* skip trailing spaces */
  return (*endptr == '\0') ? endptr
                           : ((void *)0); /* OK if no trailing characters */
}

/*
** Convert string 's' to a Lua number (put in 'result'). Return NULL
** on fail or the address of the ending '\0' on success.
** 'pmode' points to (and 'mode' contains) special things in the string:
** - 'x'/'X' means a hexadecimal numeral
** - 'n'/'N' means 'inf' or 'nan' (which should be rejected)
** - '.' just optimizes the search for the common case (nothing special)
** This function accepts both the current locale or a dot as the radix
** mark. If the conversion fails, it may mean number has a dot but
** locale accepts something else. In that case, the code copies 's'
** to a buffer (because 's' is read-only), changes the dot to the
** current locale radix mark, and tries to convert again.
*/
static const char *l_str2d(const char *s, lua_Number *result) {
  const char *endptr;
  const char *pmode = strpbrk(s, ".xXnN");
  int mode = pmode ? ((((unsigned char)((*pmode)))) | ('A' ^ 'a')) : 0;
  if (mode == 'n') /* reject 'inf' and 'nan' */
    return ((void *)0);
  endptr = l_str2dloc(s, result, mode); /* try to convert */
  if (endptr == ((void *)0)) {          /* failed? may be a different locale */
    char buff[200 + 1];
    const char *pdot = strchr(s, '.');
    if (strlen(s) > 200 || pdot == ((void *)0))
      return ((void *)0); /* string too long or no dot; fail */
    strcpy(buff, s);      /* copy string to buffer */
    buff[pdot - s] =
        (localeconv()->decimal_point[0]);    /* correct decimal point */
    endptr = l_str2dloc(buff, result, mode); /* try again */
    if (endptr != ((void *)0))
      endptr = s + (endptr - buff); /* make relative to 's' */
  }
  return endptr;
}

static const char *l_str2int(const char *s, lua_Integer *result) {
  lua_Unsigned a = 0;
  int empty = 1;
  int neg;
  while ((luai_ctype_[(((unsigned char)((*s)))) + 1] & ((1 << (3)))))
    s++; /* skip initial spaces */
  neg = isneg(&s);
  if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) { /* hex? */
    s += 2;                                          /* skip '0x' */
    for (; (luai_ctype_[(((unsigned char)((*s)))) + 1] & ((1 << (4)))); s++) {
      a = a * 16 + luaO_hexavalue(*s);
      empty = 0;
    }
  } else { /* decimal */
    for (; (luai_ctype_[(((unsigned char)((*s)))) + 1] & ((1 << (1)))); s++) {
      int d = *s - '0';
      if (a >= ((lua_Unsigned)(0x7fffffffffffffffLL / 10)) &&
          (a > ((lua_Unsigned)(0x7fffffffffffffffLL / 10)) ||
           d > ((int)((0x7fffffffffffffffLL % 10))) + neg)) /* overflow? */
        return ((void *)0); /* do not accept it (as integer) */
      a = a * 10 + d;
      empty = 0;
    }
  }
  while ((luai_ctype_[(((unsigned char)((*s)))) + 1] & ((1 << (3)))))
    s++; /* skip trailing spaces */
  if (empty || *s != '\0')
    return ((void *)0); /* something wrong in the numeral */
  else {
    *result = ((lua_Integer)((neg) ? 0u - a : a));
    return s;
  }
}

size_t luaO_str2num(const char *s, TValue *o) {
  lua_Integer i;
  lua_Number n;
  const char *e;
  if ((e = l_str2int(s, &i)) != ((void *)0)) { /* try as an integer */
    {
      TValue *io = (o);
      ((io)->value_).i = (i);
      ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
    };
  } else if ((e = l_str2d(s, &n)) != ((void *)0)) { /* else try as a float */
    {
      TValue *io = (o);
      ((io)->value_).n = (n);
      ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
    };
  } else
    return 0;         /* conversion failed */
  return (e - s) + 1; /* success; return string size */
}

int luaO_utf8esc(char *buff, unsigned long x) {
  int n = 1; /* number of bytes put in buffer (backwards) */
  ((void)0);
  if (x < 0x80) /* ascii? */
    buff[8 - 1] = ((char)((x)));
  else {                     /* need continuation bytes */
    unsigned int mfb = 0x3f; /* maximum that fits in first byte */
    do {                     /* add continuation bytes */
      buff[8 - (n++)] = ((char)((0x80 | (x & 0x3f))));
      x >>= 6;         /* remove added bits */
      mfb >>= 1;       /* now there is one less bit available in first byte */
    } while (x > mfb); /* still needs continuation byte? */
    buff[8 - n] = ((char)(((~mfb << 1) | x))); /* add first byte */
  }
  return n;
}

/* maximum length of the conversion of a number to a string */

/*
** Convert a number object to a string
*/
void luaO_tostring(lua_State *L, TValue *obj) {
  char buff[50];
  size_t len;
  ((void)0);
  if (((((obj))->tt_) == ((3 | (2 << 4)) /* integer numbers */)))
    len = snprintf((buff), sizeof(buff),
                   "%"
                   "ll"
                   "d",
                   (long long)((((obj)->value_).i)));
  else {
    len =
        snprintf((buff), sizeof(buff), "%.14g", (double)((((obj)->value_).n)));
    if (buff[strspn(buff, "-0123456789")] == '\0') { /* looks like an int? */
      buff[len++] = (localeconv()->decimal_point[0]);
      buff[len++] = '0'; /* adds '.0' to result */
    }
  }
  {
    TValue *io = (obj);
    TString *x_ = (luaS_newlstr(L, buff, len));
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((x_->tt) | (1 << 6))));
    ((void)0);
  };
}

static void pushstr(lua_State *L, const char *str, size_t l) {
  {
    TValue *io = ((&(L->top)->val));
    TString *x_ = (luaS_newlstr(L, str, l));
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((x_->tt) | (1 << 6))));
    ((void)0);
  };
  L->top++;
}

/*
** this function handles only '%d', '%c', '%f', '%p', and '%s'
   conventional formats, plus Lua-specific '%I' and '%U'
*/
const char *luaO_pushvfstring(lua_State *L, const char *fmt, va_list argp) {
  int n = 0;     /* number of strings in the stack to concatenate */
  const char *e; /* points to next conversion specifier */
  while ((e = strchr(fmt, '%')) != ((void *)0)) {
    pushstr(L, fmt, e - fmt); /* string up to conversion specifier */
    switch (*(e + 1)) {
    case 's': { /* zero-terminated string */
      const char *s = __builtin_va_arg(argp, char *);
      if (s == ((void *)0))
        s = "(null)";
      pushstr(L, s, strlen(s));
      break;
    }
    case 'c': { /* an 'int' as a character */
      char buff = ((char)((__builtin_va_arg(argp, int))));
      if ((luai_ctype_[(((unsigned char)((buff)))) + 1] & ((1 << (2)))))
        pushstr(L, &buff, 1);
      else /* non-printable character; print its code */
        luaO_pushfstring(L, "<\\%d>", ((unsigned char)((buff))));
      break;
    }
    case 'd': { /* an 'int' */
      {
        TValue *io = ((&(L->top)->val));
        ((io)->value_).i = (__builtin_va_arg(argp, int));
        ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
      };
      goto top2str;
    }
    case 'I': { /* a 'lua_Integer' */
      {
        TValue *io = ((&(L->top)->val));
        ((io)->value_).i = (((lua_Integer)(__builtin_va_arg(argp, l_uacInt))));
        ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
      };
      goto top2str;
    }
    case 'f': { /* a 'lua_Number' */
      {
        TValue *io = ((&(L->top)->val));
        ((io)->value_).n =
            (((lua_Number)((__builtin_va_arg(argp, l_uacNumber)))));
        ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
      };
    top2str: /* convert the top element to a string */
      L->top++;
      luaO_tostring(L, (&(L->top - 1)->val));
      break;
    }
    case 'p': {                          /* a pointer */
      char buff[4 * sizeof(void *) + 8]; /* should be enough space for a '%p' */
      void *p = __builtin_va_arg(argp, void *);
      int l = snprintf(buff, sizeof(buff), "%p", p);
      pushstr(L, buff, l);
      break;
    }
    case 'U': { /* a 'long' as a UTF-8 sequence */
      char buff[8];
      int l = luaO_utf8esc(buff, __builtin_va_arg(argp, long));
      pushstr(L, buff + 8 - l, l);
      break;
    }
    case '%': {
      pushstr(L, "%", 1);
      break;
    }
    default: {
      luaG_runerror(L, "invalid option '%%%c' to 'lua_pushfstring'", *(e + 1));
    }
    }
    n += 2;
    if (L->top + 2 > L->stack_last) { /* no free stack space? */
      luaV_concat(L, n);
      n = 1;
    }
    fmt = e + 2;
  }
  pushstr(L, fmt, strlen(fmt));
  if (n > 0)
    luaV_concat(L, n + 1);
  return (((char *)((
              (((&((((union GCUnion *)(((((&(L->top - 1)->val))->value_).gc))))
                       ->ts))))))) +
          sizeof(TString));
}

const char *luaO_pushfstring(lua_State *L, const char *fmt, ...) {
  const char *msg;
  va_list argp;

  __builtin_va_start(argp, fmt);
  msg = luaO_pushvfstring(L, fmt, argp);

  __builtin_va_end(argp);
  return msg;
}
void luaO_chunkid(char *out, const char *source, size_t srclen) {
  size_t bufflen = 60;     /* free space in buffer */
  if (*source == '=') {    /* 'literal' source */
    if (srclen <= bufflen) /* small enough? */
      memcpy(out, source + 1, srclen * sizeof(char));
    else { /* truncate it */
      (memcpy(out, source + 1, (bufflen - 1) * sizeof(char)),
       out += (bufflen - 1));
      *out = '\0';
    }
  } else if (*source == '@') { /* file name */
    if (srclen <= bufflen)     /* small enough? */
      memcpy(out, source + 1, srclen * sizeof(char));
    else { /* add '...' before rest of name */
      (memcpy(out, "...", ((sizeof("...") / sizeof(char) - 1)) * sizeof(char)),
       out += ((sizeof("...") / sizeof(char) - 1)));
      bufflen -= (sizeof("...") / sizeof(char) - 1);
      memcpy(out, source + 1 + srclen - bufflen, bufflen * sizeof(char));
    }
  } else { /* string; format as [string "source"] */
    const char *nl = strchr(source, '\n'); /* find first new line (if any) */
    (memcpy(out, "[string \"",
            ((sizeof("[string \"") / sizeof(char) - 1)) * sizeof(char)),
     out += ((sizeof("[string \"") / sizeof(char) - 1))); /* add prefix */
    bufflen -= (sizeof("[string \""
                       "..."
                       "\"]") /
                    sizeof(char) -
                1) +
               1; /* save space for prefix+suffix+'\0' */
    if (srclen < bufflen && nl == ((void *)0)) { /* small one-line source? */
      (memcpy(out, source, (srclen) * sizeof(char)),
       out += (srclen)); /* keep it */
    } else {
      if (nl != ((void *)0))
        srclen = nl - source; /* stop at first newline */
      if (srclen > bufflen)
        srclen = bufflen;
      (memcpy(out, source, (srclen) * sizeof(char)), out += (srclen));
      (memcpy(out, "...", ((sizeof("...") / sizeof(char) - 1)) * sizeof(char)),
       out += ((sizeof("...") / sizeof(char) - 1)));
    }
    memcpy(out, "\"]", ((sizeof("\"]") / sizeof(char) - 1) + 1) * sizeof(char));
  }
}
/*
** $Id: ltm.c $
** Tag methods
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltable.h $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltm.h $
** Tag methods
** See Copyright Notice in lua.h
*/
/*
** $Id: lvm.h $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

static const char udatatypename[] = "userdata";

static const char
    *const luaT_typenames_[((9 + 1) /* function prototypes */ + 2)] = {
        "no value", "nil",   "boolean",  udatatypename, "number",
        "string",   "table", "function", udatatypename, "thread",
        "upvalue",  "proto" /* these last cases are used for tests only */
};

void luaT_init(lua_State *L) {
  static const char *const luaT_eventname[] = {
      /* ORDER TM */
      "__index", "__newindex", "__gc",   "__mode", "__len", "__eq",   "__add",
      "__sub",   "__mul",      "__mod",  "__pow",  "__div", "__idiv", "__band",
      "__bor",   "__bxor",     "__shl",  "__shr",  "__unm", "__bnot", "__lt",
      "__le",    "__concat",   "__call", "__close"};
  int i;
  for (i = 0; i < TM_N; i++) {
    (L->l_G)->tmname[i] = luaS_new(L, luaT_eventname[i]);
    luaC_fix(L, (&(((union GCUnion *)(((L->l_G)->tmname[i])))
                       ->gc))); /* never collect these names */
  }
}

/*
** function to be used with macro "fasttm": optimized for absence of
** tag methods
*/
const TValue *luaT_gettm(Table *events, TMS event, TString *ename) {
  const TValue *tm = luaH_getshortstr(events, ename);
  ((void)0);
  if ((((((((tm))->tt_)) & 0x0F)) == (0))) {     /* no tag method? */
    events->flags |= ((lu_byte)((1u << event))); /* cache this fact */
    return ((void *)0);
  } else
    return tm;
}

const TValue *luaT_gettmbyobj(lua_State *L, const TValue *o, TMS event) {
  Table *mt;
  switch ((((((o)->tt_)) & 0x0F))) {
  case 5:
    mt = ((&((((union GCUnion *)((((o)->value_).gc))))->h)))->metatable;
    break;
  case 7:
    mt = ((&((((union GCUnion *)((((o)->value_).gc))))->u)))->metatable;
    break;
  default:
    mt = (L->l_G)->mt[(((((o)->tt_)) & 0x0F))];
  }
  return (mt ? luaH_getshortstr(mt, (L->l_G)->tmname[event])
             : &(L->l_G)->nilvalue);
}

/*
** Return the name of the type of an object. For tables and userdata
** with metatable, use their '__name' metafield, if present.
*/
const char *luaT_objtypename(lua_State *L, const TValue *o) {
  Table *mt;
  if ((((((o))->tt_) == (((5) | (1 << 6)))) &&
       (mt = ((&((((union GCUnion *)((((o)->value_).gc))))->h)))->metatable) !=
           ((void *)0)) ||
      ((((((((o))->tt_)) & 0x0F)) == (7)) &&
       (mt = ((&((((union GCUnion *)((((o)->value_).gc))))->u)))->metatable) !=
           ((void *)0))) {
    const TValue *name = luaH_getshortstr(mt, luaS_new(L, "__name"));
    if ((((((((name))->tt_)) & 0x0F)) == (4))) /* is '__name' a string? */
      return (((char *)((
                  (((&((((union GCUnion *)((((name)->value_).gc))))->ts))))))) +
              sizeof(TString)); /* use it as type name */
  }
  return luaT_typenames_[((((((o)->tt_)) & 0x0F))) +
                         1]; /* else use standard type name */
}

void luaT_callTM(lua_State *L, const TValue *f, const TValue *p1,
                 const TValue *p2, const TValue *p3) {
  StkId func = L->top;
  {
    TValue *io1 = ((&(func)->val));
    const TValue *io2 = (f);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  }; /* push function (assume EXTRA_STACK) */
  {
    TValue *io1 = ((&(func + 1)->val));
    const TValue *io2 = (p1);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  }; /* 1st argument */
  {
    TValue *io1 = ((&(func + 2)->val));
    const TValue *io2 = (p2);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  }; /* 2nd argument */
  {
    TValue *io1 = ((&(func + 3)->val));
    const TValue *io2 = (p3);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  }; /* 3rd argument */
  L->top = func + 4;
  /* metamethod may yield only when called from Lua code */
  if ((!((L->ci)->callstatus & ((1 << 1) /* call is running a C function */ |
                                (1 << 2) /* call is running a debug hook */))))
    luaD_call(L, func, 0);
  else
    luaD_callnoyield(L, func, 0);
}

void luaT_callTMres(lua_State *L, const TValue *f, const TValue *p1,
                    const TValue *p2, StkId res) {
  ptrdiff_t result = ((char *)(res) - (char *)L->stack);
  StkId func = L->top;
  {
    TValue *io1 = ((&(func)->val));
    const TValue *io2 = (f);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  }; /* push function (assume EXTRA_STACK) */
  {
    TValue *io1 = ((&(func + 1)->val));
    const TValue *io2 = (p1);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  }; /* 1st argument */
  {
    TValue *io1 = ((&(func + 2)->val));
    const TValue *io2 = (p2);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  }; /* 2nd argument */
  L->top += 3;
  /* metamethod may yield only when called from Lua code */
  if ((!((L->ci)->callstatus & ((1 << 1) /* call is running a C function */ |
                                (1 << 2) /* call is running a debug hook */))))
    luaD_call(L, func, 1);
  else
    luaD_callnoyield(L, func, 1);
  res = ((StkId)((char *)L->stack + (result)));
  {
    TValue *io1 = ((&(res)->val));
    const TValue *io2 = ((&(--L->top)->val));
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  }; /* move result to its place */
}

static int callbinTM(lua_State *L, const TValue *p1, const TValue *p2,
                     StkId res, TMS event) {
  const TValue *tm = luaT_gettmbyobj(L, p1, event); /* try first operand */
  if ((((((((tm))->tt_)) & 0x0F)) == (0)))
    tm = luaT_gettmbyobj(L, p2, event); /* try second operand */
  if ((((((((tm))->tt_)) & 0x0F)) == (0)))
    return 0;
  luaT_callTMres(L, tm, p1, p2, res);
  return 1;
}

void luaT_trybinTM(lua_State *L, const TValue *p1, const TValue *p2, StkId res,
                   TMS event) {
  if (!callbinTM(L, p1, p2, res, event)) {
    switch (event) {
    case TM_CONCAT:
      luaG_concaterror(L, p1, p2);
    /* call never returns, but to avoid warnings: */ /* FALLTHROUGH */
    case TM_BAND:
    case TM_BOR:
    case TM_BXOR:
    case TM_SHL:
    case TM_SHR:
    case TM_BNOT: {
      if ((((((((p1))->tt_)) & 0x0F)) == (3)) &&
          (((((((p2))->tt_)) & 0x0F)) == (3)))
        luaG_tointerror(L, p1, p2);
      else
        luaG_opinterror(L, p1, p2, "perform bitwise operation on");
    }
    /* calls never return, but to avoid warnings: */ /* FALLTHROUGH */
    default:
      luaG_opinterror(L, p1, p2, "perform arithmetic on");
    }
  }
}

void luaT_trybinassocTM(lua_State *L, const TValue *p1, const TValue *p2,
                        StkId res, int inv, TMS event) {
  if (inv)
    luaT_trybinTM(L, p2, p1, res, event);
  else
    luaT_trybinTM(L, p1, p2, res, event);
}

void luaT_trybiniTM(lua_State *L, const TValue *p1, lua_Integer i2, int inv,
                    StkId res, TMS event) {
  TValue aux;
  {
    TValue *io = (&aux);
    ((io)->value_).i = (i2);
    ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
  };
  luaT_trybinassocTM(L, p1, &aux, res, inv, event);
}

int luaT_callorderTM(lua_State *L, const TValue *p1, const TValue *p2,
                     TMS event) {
  if (callbinTM(L, p1, p2, L->top, event)) /* try original event */
    return !(((((((((&(L->top)->val)))->tt_)) & 0x0F)) == (0)) ||
             ((((((&(L->top)->val)))->tt_) == (1)) &&
              ((((&(L->top)->val))->value_).b) == 0));
  luaG_ordererror(L, p1, p2); /* no metamethod found */
  return 0;                   /* to avoid warnings */
}

int luaT_callorderiTM(lua_State *L, const TValue *p1, int v2, int inv,
                      int isfloat, TMS event) {
  TValue aux;
  const TValue *p2;
  if (isfloat) {
    {
      TValue *io = (&aux);
      ((io)->value_).n = (((lua_Number)((v2))));
      ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
    };
  } else {
    TValue *io = (&aux);
    ((io)->value_).i = (v2);
    ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
  };
  if (inv) { /* arguments were exchanged? */
    p2 = p1;
    p1 = &aux; /* correct them */
  } else
    p2 = &aux;
  return luaT_callorderTM(L, p1, p2, event);
}

void luaT_adjustvarargs(lua_State *L, int nfixparams, CallInfo *ci,
                        const Proto *p) {
  int i;
  int actual = ((int)((L->top - ci->func))) - 1; /* number of arguments */
  int nextra = actual - nfixparams;              /* number of extra arguments */
  ci->u.l.nextraargs = nextra;
  if (L->stack_last - L->top <= ((p->maxstacksize + 1))) {
    (void)0;
    luaD_growstack(L, (p->maxstacksize + 1), 1);
    {
      if ((L->l_G)->GCdebt > 0) {
        (void)0;
        luaC_step(L);
        (void)0;
      };
      ((void)0);
    };
  } else {
    ((void)0);
  };
  /* copy function to the top of the stack */
  {
    TValue *io1 = ((&(L->top++)->val));
    const TValue *io2 = ((&(ci->func)->val));
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
  /* move fixed parameters to the top of the stack */
  for (i = 1; i <= nfixparams; i++) {
    {
      TValue *io1 = ((&(L->top++)->val));
      const TValue *io2 = ((&(ci->func + i)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    (((&(ci->func + i)->val))->tt_ =
         (0)); /* erase original parameter (for GC) */
  }
  ci->func += actual + 1;
  ci->top += actual + 1;
  ((void)0);
}

void luaT_getvarargs(lua_State *L, CallInfo *ci, StkId where, int wanted) {
  int i;
  int nextra = ci->u.l.nextraargs;
  if (wanted < 0) {
    wanted = nextra; /* get all extra arguments available */
    if (L->stack_last - L->top <= (nextra)) {
      ptrdiff_t t__ = ((char *)(where) - (char *)L->stack); /* save 'p' */
      {
        if ((L->l_G)->GCdebt > 0) {
          (void)0;
          luaC_step(L);
          (void)0;
        };
        ((void)0);
      };
      luaD_growstack(L, nextra, 1); /* stack grow uses memory */
      where = ((StkId)((char *)L->stack + (t__)));
    } else {
      ((void)0);
    } /* 'pos' part: restore 'p' */; /* ensure stack space */
    L->top = where + nextra;         /* next instruction will need top */
  }
  for (i = 0; i < wanted && i < nextra; i++) {
    TValue *io1 = ((&(where + i)->val));
    const TValue *io2 = ((&(ci->func - nextra + i)->val));
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
  for (; i < wanted; i++) /* complete required results with nil */
    (((&(where + i)->val))->tt_ = (0));
}
/*
** $Id: lstring.c $
** String table (keeps all strings handled by Lua)
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/

/*
** Lua will use at most ~(2^LUAI_HASHLIMIT) bytes from a string to
** compute its hash
*/

/*
** Maximum size for string table.
*/

/*
** equality for long strings
*/
int luaS_eqlngstr(TString *a, TString *b) {
  size_t len = a->u.lnglen;
  ((void)0);
  return (a == b) ||              /* same instance or... */
         ((len == b->u.lnglen) && /* equal length and ... */
          (memcmp((((char *)(((a)))) + sizeof(TString)),
                  (((char *)(((b)))) + sizeof(TString)),
                  len) == 0)); /* equal contents */
}

unsigned int luaS_hash(const char *str, size_t l, unsigned int seed) {
  unsigned int h = seed ^ ((unsigned int)((l)));
  size_t step = (l >> 5) + 1;
  for (; l >= step; l -= step)
    h ^= ((h << 5) + (h >> 2) + ((lu_byte)((str[l - 1]))));
  return h;
}

unsigned int luaS_hashlongstr(TString *ts) {
  ((void)0);
  if (ts->extra == 0) { /* no hash? */
    ts->hash = luaS_hash((((char *)(((ts)))) + sizeof(TString)), ts->u.lnglen,
                         ts->hash);
    ts->extra = 1; /* now it has its hash */
  }
  return ts->hash;
}

static void tablerehash(TString **vect, int osize, int nsize) {
  int i;
  for (i = osize; i < nsize; i++) /* clear new elements */
    vect[i] = ((void *)0);
  for (i = 0; i < osize; i++) { /* rehash old part of the array */
    TString *p = vect[i];
    vect[i] = ((void *)0);
    while (p) {                    /* for each string in the list */
      TString *hnext = p->u.hnext; /* save next */
      unsigned int h =
          (((((int)(((p->hash) & ((nsize)-1))))))); /* new position */
      p->u.hnext = vect[h];                         /* chain it into array */
      vect[h] = p;
      p = hnext;
    }
  }
}

/*
** Resize the string table. If allocation fails, keep the current size.
** (This can degrade performance, but any non-zero size should work
** correctly.)
*/
void luaS_resize(lua_State *L, int nsize) {
  stringtable *tb = &(L->l_G)->strt;
  int osize = tb->size;
  TString **newvect;
  if (nsize < osize)                     /* shrinking table? */
    tablerehash(tb->hash, osize, nsize); /* depopulate shrinking part */
  newvect = (((TString **)(luaM_realloc_(
      L, tb->hash, ((size_t)((osize))) * sizeof(TString *),
      ((size_t)((nsize))) * sizeof(TString *)))));
  if ((__builtin_expect(((newvect == ((void *)0)) != 0),
                        0))) {             /* reallocation failed? */
    if (nsize < osize)                     /* was it shrinking table? */
      tablerehash(tb->hash, nsize, osize); /* restore to original size */
    /* leave table as it was */
  } else { /* allocation succeeded */
    tb->hash = newvect;
    tb->size = nsize;
    if (nsize > osize)
      tablerehash(newvect, osize, nsize); /* rehash for new size */
  }
}

/*
** Clear API string cache. (Entries cannot be empty, so fill them with
** a non-collectable string.)
*/
void luaS_clearcache(global_State *g) {
  int i, j;
  for (i = 0; i < 53; i++)
    for (j = 0; j < 2; j++) {
      if ((((g->strcache[i][j])->marked) &
           (((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */)))))) /* will entry be
                                                              collected? */
        g->strcache[i][j] = g->memerrmsg; /* replace it with something fixed */
    }
}

/*
** Initialize the string table and the string cache
*/
void luaS_init(lua_State *L) {
  global_State *g = (L->l_G);
  int i, j;
  stringtable *tb = &(L->l_G)->strt;
  tb->hash = ((TString **)(luaM_malloc_(L, (128) * sizeof(TString *), 0)));
  tablerehash(tb->hash, 0, 128); /* clear array */
  tb->size = 128;
  /* pre-create memory-error message */
  g->memerrmsg =
      (luaS_newlstr(L,
                    ""
                    "not enough memory",
                    (sizeof("not enough memory") / sizeof(char)) - 1));
  luaC_fix(L, (&(((union GCUnion *)((g->memerrmsg)))
                     ->gc))); /* it should never be collected */
  for (i = 0; i < 53; i++)    /* fill cache with valid strings */
    for (j = 0; j < 2; j++)
      g->strcache[i][j] = g->memerrmsg;
}

/*
** creates a new string object
*/
static TString *createstrobj(lua_State *L, size_t l, int tag, unsigned int h) {
  TString *ts;
  GCObject *o;
  size_t totalsize; /* total size of TString object */
  totalsize = (sizeof(TString) + ((l) + 1) * sizeof(char));
  o = luaC_newobj(L, tag, totalsize);
  ts = (&((((union GCUnion *)((o))))->ts));
  ts->hash = h;
  ts->extra = 0;
  (((char *)(((ts)))) + sizeof(TString))[l] = '\0'; /* ending 0 */
  return ts;
}

TString *luaS_createlngstrobj(lua_State *L, size_t l) {
  TString *ts =
      createstrobj(L, l, (4 | (2 << 4)) /* long strings */, (L->l_G)->seed);
  ts->u.lnglen = l;
  return ts;
}

void luaS_remove(lua_State *L, TString *ts) {
  stringtable *tb = &(L->l_G)->strt;
  TString **p = &tb->hash[(((((int)(((ts->hash) & ((tb->size) - 1)))))))];
  while (*p != ts) /* find previous element */
    p = &(*p)->u.hnext;
  *p = (*p)->u.hnext; /* remove element from its list */
  tb->nuse--;
}

static void growstrtab(lua_State *L, stringtable *tb) {
  if ((__builtin_expect(
          ((tb->nuse == 0x7fffffff /* maximum value of an int */) != 0),
          0))) {       /* too many strings? */
    luaC_fullgc(L, 1); /* try to free some... */
    if (tb->nuse ==
        0x7fffffff /* maximum value of an int */) /* still too many? */
      luaD_throw(L, 4); /* cannot even create a message... */
  }
  if (tb->size <=
      ((int)((((((size_t)((0x7fffffff /* maximum value of an int */))) <=
                ((size_t)(~(size_t)0)) / sizeof(TString *))
                   ? (0x7fffffff /* maximum value of an int */)
                   : ((unsigned int)((
                         (((size_t)(~(size_t)0)) / sizeof(TString *))))))))) /
          2) /* can grow string table? */
    luaS_resize(L, tb->size * 2);
}

/*
** Checks whether short string exists and reuses it or creates a new one.
*/
static TString *internshrstr(lua_State *L, const char *str, size_t l) {
  TString *ts;
  global_State *g = (L->l_G);
  stringtable *tb = &g->strt;
  unsigned int h = luaS_hash(str, l, g->seed);
  TString **list = &tb->hash[(((((int)(((h) & ((tb->size) - 1)))))))];
  ((void)0); /* otherwise 'memcmp'/'memcpy' are undefined */
  for (ts = *list; ts != ((void *)0); ts = ts->u.hnext) {
    if (l == ts->shrlen && (memcmp(str, (((char *)(((ts)))) + sizeof(TString)),
                                   l * sizeof(char)) == 0)) {
      /* found! */
      if ((((ts)->marked) &
           (((g)->currentwhite ^
             ((1 << (3 /* object is white (type 0) */)) |
              (1
               << (4 /* object is white (type 1) */))))))) /* dead (but not
                                                              collected yet)? */
        ((ts)->marked ^=
         ((1 << (3 /* object is white (type 0) */)) |
          (1 << (4 /* object is white (type 1) */)))); /* resurrect it */
      return ts;
    }
  }
  /* else must create a new string */
  if (tb->nuse >= tb->size) { /* need to grow string table? */
    growstrtab(L, tb);
    list = &tb->hash[(
        ((((int)(((h) & ((tb->size) - 1)))))))]; /* rehash with new size */
  }
  ts = createstrobj(L, l, (4 | (1 << 4)) /* short strings */, h);
  memcpy((((char *)(((ts)))) + sizeof(TString)), str, l * sizeof(char));
  ts->shrlen = ((lu_byte)((l)));
  ts->u.hnext = *list;
  *list = ts;
  tb->nuse++;
  return ts;
}

/*
** new string (with explicit length)
*/
TString *luaS_newlstr(lua_State *L, const char *str, size_t l) {
  if (l <= 40) /* short string? */
    return internshrstr(L, str, l);
  else {
    TString *ts;
    if ((__builtin_expect(((l >= ((sizeof(size_t) < sizeof(lua_Integer)
                                       ? ((size_t)(~(size_t)0))
                                       : (size_t)(0x7fffffffffffffffLL)) -
                                  sizeof(TString)) /
                                     sizeof(char)) != 0),
                          0)))
      luaM_toobig(L);
    ts = luaS_createlngstrobj(L, l);
    memcpy((((char *)(((ts)))) + sizeof(TString)), str, l * sizeof(char));
    return ts;
  }
}

/*
** Create or reuse a zero-terminated string, first checking in the
** cache (using the string address as a key). The cache can contain
** only zero-terminated strings, so it is safe to use 'strcmp' to
** check hits.
*/
TString *luaS_new(lua_State *L, const char *str) {
  unsigned int i =
      ((unsigned int)((size_t)(str) & (0x7fffffff * 2U + 1))) % 53; /* hash */
  int j;
  TString **p = (L->l_G)->strcache[i];
  for (j = 0; j < 2; j++) {
    if (strcmp(str, (((char *)(((p[j])))) + sizeof(TString))) == 0) /* hit? */
      return p[j]; /* that is it */
  }
  /* normal route */
  for (j = 2 - 1; j > 0; j--)
    p[j] = p[j - 1]; /* move out last element */
  /* new element is first in the list */
  p[0] = luaS_newlstr(L, str, strlen(str));
  return p[0];
}

Udata *luaS_newudata(lua_State *L, size_t s, int nuvalue) {
  Udata *u;
  int i;
  GCObject *o;
  if ((__builtin_expect(
          ((s > (sizeof(size_t) < sizeof(lua_Integer)
                     ? ((size_t)(~(size_t)0))
                     : (size_t)(0x7fffffffffffffffLL)) -
                    ((nuvalue) == 0 ? __builtin_offsetof(Udata0, bindata)
                                    : __builtin_offsetof(Udata, uv) +
                                          (sizeof(UValue) * (nuvalue)))) != 0),
          0)))
    luaM_toobig(L);
  o = luaC_newobj(L, 7,
                  (((nuvalue) == 0 ? __builtin_offsetof(Udata0, bindata)
                                   : __builtin_offsetof(Udata, uv) +
                                         (sizeof(UValue) * (nuvalue))) +
                   (s)));
  u = (&((((union GCUnion *)((o))))->u));
  u->len = s;
  u->nuvalue = nuvalue;
  u->metatable = ((void *)0);
  for (i = 0; i < nuvalue; i++)
    ((&u->uv[i].uv)->tt_ = (0));
  return u;
}
/*
** $Id: ltable.c $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
** Implementation of tables (aka arrays, objects, or hash tables).
** Tables keep its elements in two parts: an array part and a hash part.
** Non-negative integer keys are all candidates to be kept in the array
** part. The actual size of the array is the largest 'n' such that
** more than half the slots between 1 and n are in use.
** Hash uses a mix of chained scatter table with Brent's variation.
** A main invariant of these tables is that, if an element is not
** in its main position (i.e. the 'original' position that its hash gives
** to it), then the colliding element is in its own main position.
** Hence even when the load factor reaches 100%, performance remains good.
*/

/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltable.h $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/
/*
** $Id: lvm.h $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

/*
** MAXABITS is the largest integer such that MAXASIZE fits in an
** unsigned int.
*/

/*
** MAXASIZE is the maximum size of the array part. It is the minimum
** between 2^MAXABITS and the maximum size that, measured in bytes,
** fits in a 'size_t'.
*/

/*
** MAXHBITS is the largest integer such that 2^MAXHBITS fits in a
** signed int.
*/

/*
** MAXHSIZE is the maximum size of the hash part. It is the minimum
** between 2^MAXHBITS and the maximum size such that, measured in bytes,
** it fits in a 'size_t'.
*/
/*
** for some types, it is better to avoid modulus by power of 2, as
** they tend to have many 2 factors.
*/
static const Node dummynode_ = {
    {{((void *)0)},
     (0 | (1 << 4)), /* value's value and type */
     0,
     0,
     {((void *)0)}} /* key type, next, and key value */
};

static const TValue absentkey = {{((void *)0)}, (0 | (2 << 4))};

/*
** Hash for floating-point numbers.
** The main computation should be just
**     n = frexp(n, &i); return (n * INT_MAX) + i
** but there are some numerical subtleties.
** In a two-complement representation, INT_MAX does not has an exact
** representation as a float, but INT_MIN does; because the absolute
** value of 'frexp' is smaller than 1 (unless 'n' is inf/NaN), the
** absolute value of the product 'frexp * -INT_MIN' is smaller or equal
** to INT_MAX. Next, the use of 'unsigned int' avoids overflows when
** adding 'i'; the use of '~u' (instead of '-u') avoids problems with
** INT_MIN.
*/

static int l_hashfloat(lua_Number n) {
  int i;
  lua_Integer ni;
  n = frexp(n, &i) * -((lua_Number)(((-0x7fffffff - 1))));
  if (!((n) >= (double)((-0x7fffffffffffffffLL - 1)) &&
        (n) < -(double)((-0x7fffffffffffffffLL - 1)) &&
        (*(&ni) = (long long)(n), 1))) { /* is 'n' inf/-inf/NaN? */
    ((void)0);
    return 0;
  } else { /* normal case */
    unsigned int u = ((unsigned int)((i))) + ((unsigned int)((ni)));
    return ((int)((u <= ((unsigned int)((0x7fffffff))) ? u : ~u)));
  }
}

/*
** returns the 'main' position of an element in a table (that is,
** the index of its hash value). The key comes broken (tag in 'ktt'
** and value in 'vkl') so that we can call it on keys inserted into
** nodes.
*/
static Node *mainposition(const Table *t, int ktt, const Value *kvl) {
  switch (((ktt)&0x3F)) {
  case (3 | (2 << 4)) /* integer numbers */:
    return ((&(t)->node[(
        ((((int)((((((*kvl).i))) & ((((1 << ((t)->lsizenode)))) - 1)))))))]));
  case (3 | (1 << 4)) /* float numbers */:
    return ((&(t)->node[((l_hashfloat(((*kvl).n))) %
                         ((((1 << ((t)->lsizenode))) - 1) | 1))]));
  case (4 | (1 << 4)) /* short strings */:
    return ((&(t)->node[(
        ((((int)(((((((&((((union GCUnion *)(((*kvl).gc))))->ts))))->hash)) &
                  ((((1 << ((t)->lsizenode)))) - 1)))))))]));
  case (4 | (2 << 4)) /* long strings */:
    return ((&(t)->node[(((((int)((
        ((luaS_hashlongstr(((&((((union GCUnion *)(((*kvl).gc))))->ts)))))) &
        ((((1 << ((t)->lsizenode)))) - 1)))))))]));
  case 1:
    return ((&(t)->node[(
        ((((int)((((((*kvl).b))) & ((((1 << ((t)->lsizenode)))) - 1)))))))]));
  case 2:
    return ((&(t)->node[(
        (((unsigned int)((size_t)(((*kvl).p)) & (0x7fffffff * 2U + 1)))) %
        ((((1 << ((t)->lsizenode))) - 1) | 1))]));
  case (6 | (2 << 4)) /* light C function */:
    return ((&(t)->node[(
        (((unsigned int)((size_t)(((*kvl).f)) & (0x7fffffff * 2U + 1)))) %
        ((((1 << ((t)->lsizenode))) - 1) | 1))]));
  default:
    return ((&(t)->node[(
        (((unsigned int)((size_t)(((*kvl).gc)) & (0x7fffffff * 2U + 1)))) %
        ((((1 << ((t)->lsizenode))) - 1) | 1))]));
  }
}

static Node *mainpositionTV(const Table *t, const TValue *key) {
  return mainposition(t, ((key)->tt_), (&((key)->value_)));
}

/*
** Check whether key 'k1' is equal to the key in node 'n2'.
** This equality is raw, so there are no metamethods. Floats
** with integer values have been normalized, so integers cannot
** be equal to floats. It is assumed that 'eqshrstr' is simply
** pointer equality, so that short strings are handled in the
** default case.
*/
static int equalkey(const TValue *k1, const Node *n2) {
  if (((k1)->tt_) != ((n2)->u.key_tt)) /* not the same variants? */
    return 0;                          /* cannot be same key */
  switch (((((k1)->tt_)) & 0x3F)) {
  case 0:
    return 1;
  case (3 | (2 << 4)) /* integer numbers */:
    return ((((k1)->value_).i) == (((n2)->u.key_val).i));
  case (3 | (1 << 4)) /* float numbers */:
    return (((((k1)->value_).n)) == (((((n2)->u.key_val)).n)));
  case 1:
    return (((k1)->value_).b) == ((((n2)->u.key_val)).b);
  case 2:
    return (((k1)->value_).p) == ((((n2)->u.key_val)).p);
  case (6 | (2 << 4)) /* light C function */:
    return (((k1)->value_).f) == ((((n2)->u.key_val)).f);
  case (4 | (2 << 4)) /* long strings */:
    return luaS_eqlngstr(
        ((&((((union GCUnion *)((((k1)->value_).gc))))->ts))),
        ((&((((union GCUnion *)((((n2)->u.key_val).gc))))->ts))));
  default:
    return (((k1)->value_).gc) == ((((n2)->u.key_val)).gc);
  }
}

/*
** True if value of 'alimit' is equal to the real size of the array
** part of table 't'. (Otherwise, the array part must be larger than
** 'alimit'.)
*/

/*
** Returns the real size of the 'array' array
*/
static unsigned int luaH_realasize(const Table *t) {
  if (((!((t)->marked & (1 << 7))) ||
       ((((t)->alimit) & (((t)->alimit) - 1)) == 0)))
    return t->alimit; /* this is the size */
  else {
    unsigned int size = t->alimit;
    /* compute the smallest power of 2 not smaller than 'n' */
    size |= (size >> 1);
    size |= (size >> 2);
    size |= (size >> 4);
    size |= (size >> 8);
    size |= (size >> 16);

    size++;
    ((void)0);
    return size;
  }
}

/*
** Check whether real size of the array is a power of 2.
** (If it is not, 'alimit' cannot be changed to any other value
** without changing the real size.)
*/
static int ispow2realasize(const Table *t) {
  return (!(!((t)->marked & (1 << 7))) ||
          (((t->alimit) & ((t->alimit) - 1)) == 0));
}

static unsigned int setlimittosize(Table *t) {
  t->alimit = luaH_realasize(t);
  ((t)->marked &= ((lu_byte)((~(1 << 7)))));
  return t->alimit;
}

/*
** "Generic" get version. (Not that generic: not valid for integers,
** which may be in array part, nor for floats with integral values.)
*/
static const TValue *getgeneric(Table *t, const TValue *key) {
  Node *n = mainpositionTV(t, key);
  for (;;) { /* check whether 'key' is somewhere in the chain */
    if (equalkey(key, n))
      return (&(n)->i_val); /* that's it */
    else {
      int nx = ((n)->u.next);
      if (nx == 0)
        return &absentkey; /* not found */
      n += nx;
    }
  }
}

/*
** returns the index for 'k' if 'k' is an appropriate key to live in
** the array part of a table, 0 otherwise.
*/
static unsigned int arrayindex(lua_Integer k) {
  if (((lua_Unsigned)(k)) - 1u <
      ((((size_t)((1u << ((int)((sizeof(int) * 8 - 1)))))) <=
        ((size_t)(~(size_t)0)) / sizeof(TValue))
           ? (1u << ((int)((sizeof(int) * 8 - 1))))
           : ((unsigned int)(((((size_t)(~(size_t)0)) /
                               sizeof(TValue))))))) /* 'k' in [1, MAXASIZE]? */
    return ((unsigned int)((k))); /* 'key' is an appropriate array index */
  else
    return 0;
}

/*
** returns the index of a 'key' for table traversals. First goes all
** elements in the array part, then elements in the hash part. The
** beginning of a traversal is signaled by 0.
*/
static unsigned int findindex(lua_State *L, Table *t, TValue *key,
                              unsigned int asize) {
  unsigned int i;
  if ((((((((key))->tt_)) & 0x0F)) == (0)))
    return 0; /* first iteration */
  i = ((((key))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
          ? arrayindex((((key)->value_).i))
          : 0;
  if (i - 1u < asize) /* is 'key' inside array part? */
    return i;         /* yes; that's the index */
  else {
    const TValue *n = getgeneric(t, key);
    if ((__builtin_expect(((((((n))->tt_) == ((0 | (2 << 4))))) != 0), 0)))
      luaG_runerror(L, "invalid key to 'next'"); /* key not found */
    i = ((int)((((Node *)((n))) -
                (&(t)->node[0])))); /* key index in hash table */
    /* hash elements are numbered after array ones */
    return (i + 1) + asize;
  }
}

int luaH_next(lua_State *L, Table *t, StkId key) {
  unsigned int asize = luaH_realasize(t);
  unsigned int i =
      findindex(L, t, (&(key)->val), asize); /* find original key */
  for (; i < asize; i++) {                   /* try first array part */
    if (!(((((((&t->array[i]))->tt_)) & 0x0F)) ==
          (0))) { /* a non-empty entry? */
      {
        TValue *io = ((&(key)->val));
        ((io)->value_).i = (i + 1);
        ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
      };
      {
        TValue *io1 = ((&(key + 1)->val));
        const TValue *io2 = (&t->array[i]);
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      return 1;
    }
  }
  for (i -= asize; ((int)((i))) < ((1 << ((t)->lsizenode)));
       i++) { /* hash part */
    if (!((((((((&((&(t)->node[i]))->i_val)))->tt_)) & 0x0F)) ==
          (0))) { /* a non-empty entry? */
      Node *n = (&(t)->node[i]);
      {
        TValue *io_ = ((&(key)->val));
        const Node *n_ = (n);
        io_->value_ = n_->u.key_val;
        io_->tt_ = n_->u.key_tt;
        (void)L;
        ((void)0);
      };
      {
        TValue *io1 = ((&(key + 1)->val));
        const TValue *io2 = ((&(n)->i_val));
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      return 1;
    }
  }
  return 0; /* no more elements */
}

static void freehash(lua_State *L, Table *t) {
  if (!((t)->lastfree == ((void *)0)))
    luaM_free_(L, (t->node),
               (((size_t)((((1 << ((t)->lsizenode))))))) * sizeof(*(t->node)));
}

/*
** {=============================================================
** Rehash
** ==============================================================
*/

/*
** Compute the optimal size for the array part of table 't'. 'nums' is a
** "count array" where 'nums[i]' is the number of integers in the table
** between 2^(i - 1) + 1 and 2^i. 'pna' enters with the total number of
** integer keys in the table and leaves with the number of keys that
** will go to the array part; return the optimal size.  (The condition
** 'twotoi > 0' in the for loop stops the loop if 'twotoi' overflows.)
*/
static unsigned int computesizes(unsigned int nums[], unsigned int *pna) {
  int i;
  unsigned int twotoi;      /* 2^i (candidate for optimal size) */
  unsigned int a = 0;       /* number of elements smaller than 2^i */
  unsigned int na = 0;      /* number of elements to go to array part */
  unsigned int optimal = 0; /* optimal size for array part */
  /* loop while keys can fill more than half of total size */
  for (i = 0, twotoi = 1; twotoi > 0 && *pna > twotoi / 2; i++, twotoi *= 2) {
    a += nums[i];
    if (a > twotoi / 2) { /* more than half elements present? */
      optimal = twotoi;   /* optimal size (till now) */
      na = a; /* all elements up to 'optimal' will go to array part */
    }
  }
  ((void)0);
  *pna = na;
  return optimal;
}

static int countint(lua_Integer key, unsigned int *nums) {
  unsigned int k = arrayindex(key);
  if (k != 0) {               /* is 'key' an appropriate array index? */
    nums[luaO_ceillog2(k)]++; /* count as such */
    return 1;
  } else
    return 0;
}

/*
** Count keys in array part of table 't': Fill 'nums[i]' with
** number of keys that will go into corresponding slice and return
** total number of non-nil keys.
*/
static unsigned int numusearray(const Table *t, unsigned int *nums) {
  int lg;
  unsigned int ttlg;                /* 2^lg */
  unsigned int ause = 0;            /* summation of 'nums' */
  unsigned int i = 1;               /* count to traverse all array keys */
  unsigned int asize = (t->alimit); /* real array size */
  /* traverse each slice */
  for (lg = 0, ttlg = 1; lg <= ((int)((sizeof(int) * 8 - 1)));
       lg++, ttlg *= 2) {
    unsigned int lc = 0; /* counter */
    unsigned int lim = ttlg;
    if (lim > asize) {
      lim = asize; /* adjust upper limit */
      if (i > lim)
        break; /* no more elements to count */
    }
    /* count elements in range (2^(lg - 1), 2^lg] */
    for (; i <= lim; i++) {
      if (!(((((((&t->array[i - 1]))->tt_)) & 0x0F)) == (0)))
        lc++;
    }
    nums[lg] += lc;
    ause += lc;
  }
  return ause;
}

static int numusehash(const Table *t, unsigned int *nums, unsigned int *pna) {
  int totaluse = 0; /* total number of elements */
  int ause = 0;     /* elements added to 'nums' (can go to array part) */
  int i = ((1 << ((t)->lsizenode)));
  while (i--) {
    Node *n = &t->node[i];
    if (!((((((((&(n)->i_val)))->tt_)) & 0x0F)) == (0))) {
      if ((((n)->u.key_tt) == (3 | (2 << 4)) /* integer numbers */))
        ause += countint((((n)->u.key_val).i), nums);
      totaluse++;
    }
  }
  *pna += ause;
  return totaluse;
}

/*
** Creates an array for the hash part of a table with the given
** size, or reuses the dummy node if size is zero.
** The computation for size overflow is in two steps: the first
** comparison ensures that the shift in the second one does not
** overflow.
*/
static void setnodevector(lua_State *L, Table *t, unsigned int size) {
  if (size == 0) {                       /* no elements to hash part? */
    t->node = ((Node *)((&dummynode_))); /* use common 'dummynode' */
    t->lsizenode = 0;
    t->lastfree = ((void *)0); /* signal that it is using dummy node */
  } else {
    int i;
    int lsize = luaO_ceillog2(size);
    if (lsize > (((int)((sizeof(int) * 8 - 1))) - 1) ||
        (1u << lsize) >
            ((((size_t)((1u << (((int)((sizeof(int) * 8 - 1))) - 1)))) <=
              ((size_t)(~(size_t)0)) / sizeof(Node))
                 ? (1u << (((int)((sizeof(int) * 8 - 1))) - 1))
                 : ((unsigned int)(((((size_t)(~(size_t)0)) / sizeof(Node)))))))
      luaG_runerror(L, "table overflow");
    size = (1 << (lsize));
    t->node = ((Node *)(luaM_malloc_(L, (size) * sizeof(Node), 0)));
    for (i = 0; i < (int)size; i++) {
      Node *n = (&(t)->node[i]);
      ((n)->u.next) = 0;
      (((n)->u.key_tt) = 0);
      (((&(n)->i_val))->tt_ = ((0 | (1 << 4))));
    }
    t->lsizenode = ((lu_byte)((lsize)));
    t->lastfree = (&(t)->node[size]); /* all positions are free */
  }
}

/*
** (Re)insert all elements from the hash part of 'ot' into table 't'.
*/
static void reinsert(lua_State *L, Table *ot, Table *t) {
  int j;
  int size = ((1 << ((ot)->lsizenode)));
  for (j = 0; j < size; j++) {
    Node *old = (&(ot)->node[j]);
    if (!((((((((&(old)->i_val)))->tt_)) & 0x0F)) == (0))) {
      /* doesn't need barrier/invalidate cache, as entry was
         already present in the table */
      TValue k;
      {
        TValue *io_ = (&k);
        const Node *n_ = (old);
        io_->value_ = n_->u.key_val;
        io_->tt_ = n_->u.key_tt;
        (void)L;
        ((void)0);
      };
      {
        TValue *io1 = (luaH_set(L, t, &k));
        const TValue *io2 = ((&(old)->i_val));
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
    }
  }
}

/*
** Exchange the hash part of 't1' and 't2'.
*/
static void exchangehashpart(Table *t1, Table *t2) {
  lu_byte lsizenode = t1->lsizenode;
  Node *node = t1->node;
  Node *lastfree = t1->lastfree;
  t1->lsizenode = t2->lsizenode;
  t1->node = t2->node;
  t1->lastfree = t2->lastfree;
  t2->lsizenode = lsizenode;
  t2->node = node;
  t2->lastfree = lastfree;
}

/*
** Resize table 't' for the new given sizes. Both allocations (for
** the hash part and for the array part) can fail, which creates some
** subtleties. If the first allocation, for the hash part, fails, an
** error is raised and that is it. Otherwise, it copies the elements from
** the shrinking part of the array (if it is shrinking) into the new
** hash. Then it reallocates the array part.  If that fails, the table
** is in its original state; the function frees the new hash part and then
** raises the allocation error. Otherwise, it sets the new hash part
** into the table, initializes the new part of the array (if any) with
** nils and reinserts the elements of the old hash back into the new
** parts of the table.
*/
void luaH_resize(lua_State *L, Table *t, unsigned int newasize,
                 unsigned int nhsize) {
  unsigned int i;
  Table newt; /* to keep the new hash part */
  unsigned int oldasize = setlimittosize(t);
  TValue *newarray;
  /* create new hash part with appropriate size into 'newt' */
  setnodevector(L, &newt, nhsize);
  if (newasize < oldasize) {    /* will array shrink? */
    t->alimit = newasize;       /* pretend array has new size... */
    exchangehashpart(t, &newt); /* and new hash */
    /* re-insert into the new hash the elements from vanishing slice */
    for (i = newasize; i < oldasize; i++) {
      if (!(((((((&t->array[i]))->tt_)) & 0x0F)) == (0)))
        luaH_setint(L, t, i + 1, &t->array[i]);
    }
    t->alimit = oldasize;       /* restore current size... */
    exchangehashpart(t, &newt); /* and hash (in case of errors) */
  }
  /* allocate new array */
  newarray = (((TValue *)(luaM_realloc_(
      L, t->array, ((size_t)((oldasize))) * sizeof(TValue),
      ((size_t)((newasize))) * sizeof(TValue)))));
  if ((__builtin_expect(((newarray == ((void *)0) && newasize > 0) != 0),
                        0))) { /* allocation failed? */
    freehash(L, &newt);        /* release new hash part */
    luaD_throw(L, 4);          /* raise error (with array unchanged) */
  }
  /* allocation ok; initialize new part of the array */
  exchangehashpart(t, &newt); /* 't' has the new hash ('newt' has the old) */
  t->array = newarray;        /* set new array part */
  t->alimit = newasize;
  for (i = oldasize; i < newasize; i++) /* clear new slice of the array */
    ((&t->array[i])->tt_ = ((0 | (1 << 4))));
  /* re-insert elements from old hash part into new parts */
  reinsert(L, &newt, t); /* 'newt' now has the old hash */
  freehash(L, &newt);    /* free old hash part */
}

void luaH_resizearray(lua_State *L, Table *t, unsigned int nasize) {
  int nsize = (((t)->lastfree == ((void *)0)) ? 0 : ((1 << ((t)->lsizenode))));
  luaH_resize(L, t, nasize, nsize);
}

/*
** nums[i] = number of keys 'k' where 2^(i - 1) < k <= 2^i
*/
static void rehash(lua_State *L, Table *t, const TValue *ek) {
  unsigned int asize; /* optimal size for array part */
  unsigned int na;    /* number of keys in the array part */
  unsigned int nums[((int)((sizeof(int) * 8 - 1))) + 1];
  int i;
  int totaluse;
  for (i = 0; i <= ((int)((sizeof(int) * 8 - 1))); i++)
    nums[i] = 0; /* reset counts */
  setlimittosize(t);
  na = numusearray(t, nums);            /* count keys in array part */
  totaluse = na;                        /* all those keys are integer keys */
  totaluse += numusehash(t, nums, &na); /* count keys in hash part */
  /* count extra key */
  if (((((ek))->tt_) == ((3 | (2 << 4)) /* integer numbers */)))
    na += countint((((ek)->value_).i), nums);
  totaluse++;
  /* compute new size for array part */
  asize = computesizes(nums, &na);
  /* resize the table to new computed sizes */
  luaH_resize(L, t, asize, totaluse - na);
}

/*
** }=============================================================
*/

Table *luaH_new(lua_State *L) {
  GCObject *o = luaC_newobj(L, 5, sizeof(Table));
  Table *t = (&((((union GCUnion *)((o))))->h));
  t->metatable = ((void *)0);
  t->flags = ((lu_byte)((~0)));
  t->array = ((void *)0);
  t->alimit = 0;
  setnodevector(L, t, 0);
  return t;
}

void luaH_free(lua_State *L, Table *t) {
  freehash(L, t);
  luaM_free_(L, (t->array), (luaH_realasize(t)) * sizeof(*(t->array)));
  luaM_free_(L, (t), sizeof(*(t)));
}

static Node *getfreepos(Table *t) {
  if (!((t)->lastfree == ((void *)0))) {
    while (t->lastfree > t->node) {
      t->lastfree--;
      if ((((t->lastfree)->u.key_tt) == 0))
        return t->lastfree;
    }
  }
  return ((void *)0); /* could not find a free place */
}

/*
** inserts a new key into a hash table; first, check whether key's main
** position is free. If not, check whether colliding node is in its main
** position or not: if it is not, move colliding node to an empty place and
** put new key in its main position; otherwise (colliding node is in its main
** position), new key goes to an empty position.
*/
TValue *luaH_newkey(lua_State *L, Table *t, const TValue *key) {
  Node *mp;
  TValue aux;
  if ((__builtin_expect((((((((((key))->tt_)) & 0x0F)) == (0))) != 0), 0)))
    luaG_runerror(L, "table index is nil");
  else if (((((key))->tt_) == ((3 | (1 << 4)) /* float numbers */))) {
    lua_Number f = (((key)->value_).n);
    lua_Integer k;
    if (luaV_flttointeger(f, &k, 0)) { /* does key fit in an integer? */
      {
        TValue *io = (&aux);
        ((io)->value_).i = (k);
        ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
      };
      key = &aux; /* insert it as an integer */
    } else if ((__builtin_expect((((!(((f)) == ((f))))) != 0), 0)))
      luaG_runerror(L, "table index is NaN");
  }
  mp = mainpositionTV(t, key);
  if (!((((((((&(mp)->i_val)))->tt_)) & 0x0F)) == (0)) ||
      ((t)->lastfree == ((void *)0))) { /* main position is taken? */
    Node *othern;
    Node *f = getfreepos(t); /* get a free place */
    if (f == ((void *)0)) {  /* cannot find a free place? */
      rehash(L, t, key);     /* grow table */
      /* whatever called 'newkey' takes care of TM cache */
      return luaH_set(L, t, key); /* insert key into grown table */
    }
    ((void)0);
    othern = mainposition(t, ((mp)->u.key_tt), &((mp)->u.key_val));
    if (othern != mp) { /* is colliding node out of its main position? */
      /* yes; move colliding node into free position */
      while (othern + ((othern)->u.next) != mp) /* find previous */
        othern += ((othern)->u.next);
      ((othern)->u.next) = ((int)((f - othern))); /* rechain to point to 'f' */
      *f = *mp; /* copy colliding node into free pos. (mp->next also goes) */
      if (((mp)->u.next) != 0) {
        ((f)->u.next) += ((int)((mp - f))); /* correct 'next' */
        ((mp)->u.next) = 0;                 /* now 'mp' is free */
      }
      (((&(mp)->i_val))->tt_ = ((0 | (1 << 4))));
    } else { /* colliding node is in its own main position */
      /* new node will go into free position */
      if (((mp)->u.next) != 0)
        ((f)->u.next) =
            ((int)(((mp + ((mp)->u.next)) - f))); /* chain new position */
      else
        ((void)0);
      ((mp)->u.next) = ((int)((f - mp)));
      mp = f;
    }
  }
  {
    Node *n_ = (mp);
    const TValue *io_ = (key);
    n_->u.key_val = io_->value_;
    n_->u.key_tt = io_->tt_;
    (void)L;
    ((void)0);
  };
  (((((key)->tt_) & (1 << 6)) &&
    ((((&(((union GCUnion *)((t)))->gc)))->marked) &
     ((1 << (5 /* object is black */)))) &&
    ((((((key)->value_).gc))->marked) &
     (((1 << (3 /* object is white (type 0) */)) |
       (1 << (4 /* object is white (type 1) */))))))
       ? luaC_barrierback_(L, (&(((union GCUnion *)((t)))->gc)))
       : ((void)((0))));
  ((void)0);
  return (&(mp)->i_val);
}

/*
** Search function for integers. If integer is inside 'alimit', get it
** directly from the array part. Otherwise, if 'alimit' is not equal to
** the real size of the array, key still can be in the array part. In
** this case, try to avoid a call to 'luaH_realasize' when key is just
** one more than the limit (so that it can be incremented without
** changing the real size of the array).
*/
const TValue *luaH_getint(Table *t, lua_Integer key) {
  if (((lua_Unsigned)(key)) - 1u < t->alimit) /* 'key' in [1, t->alimit]? */
    return &t->array[key - 1];
  else if (!((!((t)->marked & (1 << 7))) ||
             ((((t)->alimit) & (((t)->alimit) - 1)) ==
              0)) && /* key still may be in the array part? */
           (((lua_Unsigned)(key)) == t->alimit + 1 ||
            ((lua_Unsigned)(key)) - 1u < luaH_realasize(t))) {
    t->alimit = ((unsigned int)((key))); /* probably '#t' is here now */
    return &t->array[key - 1];
  } else {
    Node *n = ((&(t)->node[(
        ((((int)((((key)) & ((((1 << ((t)->lsizenode)))) - 1)))))))]));
    for (;;) { /* check whether 'key' is somewhere in the chain */
      if ((((n)->u.key_tt) == (3 | (2 << 4)) /* integer numbers */) &&
          (((n)->u.key_val).i) == key)
        return (&(n)->i_val); /* that's it */
      else {
        int nx = ((n)->u.next);
        if (nx == 0)
          break;
        n += nx;
      }
    }
    return &absentkey;
  }
}

/*
** search function for short strings
*/
const TValue *luaH_getshortstr(Table *t, TString *key) {
  Node *n = ((&(t)->node[(
      ((((int)(((((key)->hash)) & ((((1 << ((t)->lsizenode)))) - 1)))))))]));
  ((void)0);
  for (;;) { /* check whether 'key' is somewhere in the chain */
    if ((((n)->u.key_tt) ==
         (((4 | (1 << 4)) /* short strings */) | (1 << 6))) &&
        ((((&((((union GCUnion *)((((n)->u.key_val).gc))))->ts)))) == (key)))
      return (&(n)->i_val); /* that's it */
    else {
      int nx = ((n)->u.next);
      if (nx == 0)
        return &absentkey; /* not found */
      n += nx;
    }
  }
}

const TValue *luaH_getstr(Table *t, TString *key) {
  if (key->tt == (4 | (1 << 4)) /* short strings */)
    return luaH_getshortstr(t, key);
  else { /* for long strings, use generic case */
    TValue ko;
    {
      TValue *io = (&ko);
      TString *x_ = (key);
      ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
      ((io)->tt_ = (((x_->tt) | (1 << 6))));
      ((void)0);
    };
    return getgeneric(t, &ko);
  }
}

/*
** main search function
*/
const TValue *luaH_get(Table *t, const TValue *key) {
  switch (((((key)->tt_)) & 0x3F)) {
  case (4 | (1 << 4)) /* short strings */:
    return luaH_getshortstr(
        t, ((&((((union GCUnion *)((((key)->value_).gc))))->ts))));
  case (3 | (2 << 4)) /* integer numbers */:
    return luaH_getint(t, (((key)->value_).i));
  case 0:
    return &absentkey;
  case (3 | (1 << 4)) /* float numbers */: {
    lua_Integer k;
    if (luaV_flttointeger((((key)->value_).n), &k,
                          0))   /* index is an integral? */
      return luaH_getint(t, k); /* use specialized version */
    /* else... */
  } /* FALLTHROUGH */
  default:
    return getgeneric(t, key);
  }
}

/*
** beware: when using this function you probably need to check a GC
** barrier and invalidate the TM cache.
*/
TValue *luaH_set(lua_State *L, Table *t, const TValue *key) {
  const TValue *p = luaH_get(t, key);
  if (!((((p))->tt_) == ((0 | (2 << 4)))))
    return ((TValue *)(p));
  else
    return luaH_newkey(L, t, key);
}

void luaH_setint(lua_State *L, Table *t, lua_Integer key, TValue *value) {
  const TValue *p = luaH_getint(t, key);
  TValue *cell;
  if (!((((p))->tt_) == ((0 | (2 << 4)))))
    cell = ((TValue *)(p));
  else {
    TValue k;
    {
      TValue *io = (&k);
      ((io)->value_).i = (key);
      ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
    };
    cell = luaH_newkey(L, t, &k);
  }
  {
    TValue *io1 = (cell);
    const TValue *io2 = (value);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
}

/*
** Try to find a boundary in the hash part of table 't'. From the
** caller, we know that 'j' is zero or present and that 'j + 1' is
** present. We want to find a larger key that is absent from the
** table, so that we can do a binary search between the two keys to
** find a boundary. We keep doubling 'j' until we get an absent index.
** If the doubling would overflow, we try LUA_MAXINTEGER. If it is
** absent, we are ready for the binary search. ('j', being max integer,
** is larger or equal to 'i', but it cannot be equal because it is
** absent while 'i' is present; so 'j > i'.) Otherwise, 'j' is a
** boundary. ('j + 1' cannot be a present integer key because it is
** not a valid integer in Lua.)
*/
static lua_Unsigned hash_search(Table *t, lua_Unsigned j) {
  lua_Unsigned i;
  if (j == 0)
    j++; /* the caller ensures 'j + 1' is present */
  do {
    i = j; /* 'i' is a present index */
    if (j <= ((lua_Unsigned)(0x7fffffffffffffffLL)) / 2)
      j *= 2;
    else {
      j = 0x7fffffffffffffffLL;
      if ((((((((luaH_getint(t, j)))->tt_)) & 0x0F)) ==
           (0)))  /* t[j] not present? */
        break;    /* 'j' now is an absent index */
      else        /* weird case */
        return j; /* well, max integer is a boundary... */
    }
  } while (!(((((((luaH_getint(t, j)))->tt_)) & 0x0F)) ==
             (0))); /* repeat until an absent t[j] */
  /* i < j  &&  t[i] present  &&  t[j] absent */
  while (j - i > 1u) { /* do a binary search between them */
    lua_Unsigned m = (i + j) / 2;
    if ((((((((luaH_getint(t, m)))->tt_)) & 0x0F)) == (0)))
      j = m;
    else
      i = m;
  }
  return i;
}

static unsigned int binsearch(const TValue *array, unsigned int i,
                              unsigned int j) {
  while (j - i > 1u) { /* binary search */
    unsigned int m = (i + j) / 2;
    if ((((((((&array[m - 1]))->tt_)) & 0x0F)) == (0)))
      j = m;
    else
      i = m;
  }
  return i;
}

/*
** Try to find a boundary in table 't'. (A 'boundary' is an integer index
** such that t[i] is present and t[i+1] is absent, or 0 if t[1] is absent
** and 'maxinteger' if t[maxinteger] is present.)
** (In the next explanation, we use Lua indices, that is, with base 1.
** The code itself uses base 0 when indexing the array part of the table.)
** The code starts with 'limit', a position in the array part that may
** be a boundary.
** (1) If 't[limit]' is empty, there must be a boundary before it.
** As a common case (e.g., after 't[#t]=nil'), check whether 'hint-1'
** is present. If so, it is a boundary. Otherwise, do a binary search
** between 0 and limit to find a boundary. In both cases, try to
** use this boundary as the new 'limit', as a hint for the next call.
** (2) If 't[limit]' is not empty and the array has more elements
** after 'limit', try to find a boundary there. Again, try first
** the special case (which should be quite frequent) where 'limit+1'
** is empty, so that 'limit' is a boundary. Otherwise, check the
** last element of the array part (set it as a new limit). If it is empty,
** there must be a boundary between the old limit (present) and the new
** limit (absent), which is found with a binary search. (This boundary
** always can be a new limit.)
** (3) The last case is when there are no elements in the array part
** (limit == 0) or its last element (the new limit) is present.
** In this case, must check the hash part. If there is no hash part,
** the boundary is 0. Otherwise, if 'limit+1' is absent, 'limit' is
** a boundary. Finally, if 'limit+1' is present, call 'hash_search'
** to find a boundary in the hash part of the table. (In those
** cases, the boundary is not inside the array part, and therefore
** cannot be used as a new limit.)
*/
lua_Unsigned luaH_getn(Table *t) {
  unsigned int limit = t->alimit;
  if (limit > 0 && (((((((&t->array[limit - 1]))->tt_)) & 0x0F)) == (0))) {
    /* (1) there must be a boundary before 'limit' */
    if (limit >= 2 && !(((((((&t->array[limit - 2]))->tt_)) & 0x0F)) == (0))) {
      /* 'limit - 1' is a boundary; can it be a new limit? */
      if (ispow2realasize(t) && !(((limit - 1) & ((limit - 1) - 1)) == 0)) {
        t->alimit = limit - 1;
        ((t)->marked |= (1 << 7));
      }
      return limit - 1;
    } else { /* must search for a boundary in [0, limit] */
      unsigned int boundary = binsearch(t->array, 0, limit);
      /* can this boundary represent the real size of the array? */
      if (ispow2realasize(t) && boundary > luaH_realasize(t) / 2) {
        t->alimit = boundary; /* use it as the new limit */
        ((t)->marked |= (1 << 7));
      }
      return boundary;
    }
  }
  /* 'limit' is zero or present in table */
  if (!((!((t)->marked & (1 << 7))) ||
        ((((t)->alimit) & (((t)->alimit) - 1)) == 0))) {
    /* (2) 'limit' > 0 and array has more elements after 'limit' */
    if ((((((((&t->array[limit]))->tt_)) & 0x0F)) ==
         (0)))      /* 'limit + 1' is empty? */
      return limit; /* this is the boundary */
    /* else, try last element in the array */
    limit = luaH_realasize(t);
    if ((((((((&t->array[limit - 1]))->tt_)) & 0x0F)) == (0))) { /* empty? */
      /* there must be a boundary in the array after old limit,
         and it must be a valid new limit */
      unsigned int boundary = binsearch(t->array, t->alimit, limit);
      t->alimit = boundary;
      return boundary;
    }
    /* else, new limit is present in the table; check the hash part */
  }
  /* (3) 'limit' is the last element and either is zero or present in table */
  ((void)0);
  if (((t)->lastfree == ((void *)0)) ||
      (((((((luaH_getint(t, ((lua_Integer)(limit + 1)))))->tt_)) & 0x0F)) ==
       (0)))
    return limit; /* 'limit + 1' is absent... */
  else            /* 'limit + 1' is also present */
    return hash_search(t, limit);
}
/*
** $Id: ldo.c $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
        setjmp.h
        stubs for future use.
*/
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lapi.h $
** Auxiliary functions from Lua API
** See Copyright Notice in lua.h
*/
/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lfunc.h $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/
/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lopcodes.h $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/
/*
** $Id: lparser.h $
** Lua Parser
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltable.h $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltm.h $
** Tag methods
** See Copyright Notice in lua.h
*/
/*
** $Id: lundump.h $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/
/*
** $Id: lvm.h $
** Lua virtual machine
** See Copyright Notice in lua.h
*/
/*
** $Id: lzio.h $
** Buffered streams
** See Copyright Notice in lua.h
*/

/*
** {======================================================
** Error-recovery functions
** =======================================================
*/

/*
** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By
** default, Lua handles errors with exceptions when compiling as
** C++ code, with _longjmp/_setjmp when asked to use them, and with
** longjmp/setjmp otherwise.
*/
/* ISO C handling with long jumps */
/* chain list of long jump buffers */
struct lua_longjmp {
  struct lua_longjmp *previous;
  jmp_buf b;
  volatile int status; /* error code */
};

void luaD_seterrorobj(lua_State *L, int errcode, StkId oldtop) {
  switch (errcode) {
  case 4: { /* memory error? */
    {
      TValue *io = ((&(oldtop)->val));
      TString *x_ = ((L->l_G)->memerrmsg);
      ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
      ((io)->tt_ = (((x_->tt) | (1 << 6))));
      ((void)0);
    }; /* reuse preregistered msg. */
    break;
  }
  case 5: {
    {
      TValue *io = ((&(oldtop)->val));
      TString *x_ = ((luaS_newlstr(
          L,
          ""
          "error in error handling",
          (sizeof("error in error handling") / sizeof(char)) - 1)));
      ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
      ((io)->tt_ = (((x_->tt) | (1 << 6))));
      ((void)0);
    };
    break;
  }
  case (-2): {
    (((&(oldtop)->val))->tt_ = (0)); /* no error message */
    break;
  }
  default: {
    {
      TValue *io1 = ((&(oldtop)->val));
      const TValue *io2 = ((&(L->top - 1)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    }; /* error message on current top */
    break;
  }
  }
  L->top = oldtop + 1;
}

void __attribute__((noreturn)) luaD_throw(lua_State *L, int errcode) {
  if (L->errorJmp) {               /* thread has an error handler? */
    L->errorJmp->status = errcode; /* set status */
    longjmp((L->errorJmp)->b, 1);  /* jump to it */
  } else {                         /* thread has no error handler */
    global_State *g = (L->l_G);
    errcode = luaF_close(L, L->stack, errcode); /* close all upvalues */
    L->status = ((lu_byte)((errcode)));         /* mark it as dead */
    if (g->mainthread->errorJmp) {              /* main thread has a handler? */
      {
        TValue *io1 = ((&(g->mainthread->top++)->val));
        const TValue *io2 = ((&(L->top - 1)->val));
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };                                      /* copy error obj. */
      luaD_throw(g->mainthread, errcode);     /* re-throw in main thread */
    } else {                                  /* no handler at all; abort */
      if (g->panic) {                         /* panic function? */
        luaD_seterrorobj(L, errcode, L->top); /* assume EXTRA_STACK */
        if (L->ci->top < L->top)
          L->ci->top = L->top; /* pushing msg. can break this invariant */
        ((void)0);
        g->panic(L); /* call panic function (last chance to jump out) */
      }
      abort();
    }
  }
}

int luaD_rawrunprotected(lua_State *L, Pfunc f, void *ud) {
  l_uint32 oldnCcalls = L->nCcalls - L->nci;
  struct lua_longjmp lj;
  ((void)0);
  lj.status = 0;
  lj.previous = L->errorJmp; /* chain new error handler */
  L->errorJmp = &lj;
  if (setjmp((&lj)->b) == 0) {
    (*f)(L, ud);
  }

  ;
  L->errorJmp = lj.previous; /* restore old error handler */
  L->nCcalls = oldnCcalls + L->nci;
  return lj.status;
}

/* }====================================================== */

/*
** {==================================================================
** Stack reallocation
** ===================================================================
*/
static void correctstack(lua_State *L, StkId oldstack, StkId newstack) {
  CallInfo *ci;
  UpVal *up;
  if (oldstack == newstack)
    return; /* stack address did not change */
  L->top = (L->top - oldstack) + newstack;
  for (up = L->openupval; up != ((void *)0); up = up->u.open.next)
    up->v = (&(((((StkId)((up)->v))) - oldstack) + newstack)->val);
  for (ci = L->ci; ci != ((void *)0); ci = ci->previous) {
    ci->top = (ci->top - oldstack) + newstack;
    ci->func = (ci->func - oldstack) + newstack;
    if ((!((ci)->callstatus & (1 << 1) /* call is running a C function */)))
      ci->u.l.trap = 1; /* signal to update 'trap' in 'luaV_execute' */
  }
}

/* some space for error handling */

int luaD_reallocstack(lua_State *L, int newsize, int raiseerror) {
  int lim = L->stacksize;
  StkId newstack = (((StackValue *)(luaM_realloc_(
      L, L->stack, ((size_t)((lim))) * sizeof(StackValue),
      ((size_t)((newsize))) * sizeof(StackValue)))));
  ((void)0);
  ((void)0);
  if ((__builtin_expect(((newstack == ((void *)0)) != 0),
                        0))) { /* reallocation failed? */
    if (raiseerror)
      luaD_throw(L, 4);
    else
      return 0; /* do not raise an error */
  }
  for (; lim < newsize; lim++)
    (((&(newstack + lim)->val))->tt_ = (0)); /* erase new segment */
  correctstack(L, L->stack, newstack);
  L->stack = newstack;
  L->stacksize = newsize;
  L->stack_last = L->stack + newsize - 5;
  return 1;
}

/*
** Try to grow the stack by at least 'n' elements. when 'raiseerror'
** is true, raises any error; otherwise, return 0 in case of errors.
*/
int luaD_growstack(lua_State *L, int n, int raiseerror) {
  int size = L->stacksize;
  int newsize = 2 * size; /* tentative new size */
  if ((__builtin_expect(((size > 1000000) != 0),
                        0))) { /* need more space after extra size? */
    if (raiseerror)
      luaD_throw(L, 5); /* error inside message handler */
    else
      return 0;
  } else {
    int needed = ((int)((L->top - L->stack))) + n + 5;
    if (newsize > 1000000) /* cannot cross the limit */
      newsize = 1000000;
    if (newsize < needed) /* but must respect what was asked for */
      newsize = needed;
    if ((__builtin_expect(((newsize > 1000000) != 0),
                          0))) { /* stack overflow? */
      /* add extra size to be able to handle the error message */
      luaD_reallocstack(L, (1000000 + 200), raiseerror);
      if (raiseerror)
        luaG_runerror(L, "stack overflow");
      else
        return 0;
    }
  } /* else no errors */
  return luaD_reallocstack(L, newsize, raiseerror);
}

static int stackinuse(lua_State *L) {
  CallInfo *ci;
  StkId lim = L->top;
  for (ci = L->ci; ci != ((void *)0); ci = ci->previous) {
    if (lim < ci->top)
      lim = ci->top;
  }
  ((void)0);
  return ((int)((lim - L->stack))) + 1; /* part of stack in use */
}

void luaD_shrinkstack(lua_State *L) {
  int inuse = stackinuse(L);
  int goodsize = inuse + (inuse / 8) + 2 * 5;
  if (goodsize > 1000000)
    goodsize = 1000000; /* respect stack limit */
  /* if thread is currently not handling a stack overflow and its
     good size is smaller than current size, shrink its stack */
  if (inuse <= (1000000 - 5) && goodsize < L->stacksize)
    luaD_reallocstack(L, goodsize, 0); /* ok if that fails */
  else                                 /* don't change stack */
    ((void)0);                         /* (change only for debugging) */
  luaE_shrinkCI(L);                    /* shrink CI list */
}

void luaD_inctop(lua_State *L) {
  if (L->stack_last - L->top <= (1)) {
    (void)0;
    luaD_growstack(L, 1, 1);
    (void)0;
  } else {
    ((void)0);
  };
  L->top++;
}

/* }================================================================== */

/*
** Call a hook for the given event. Make sure there is a hook to be
** called. (Both 'L->hook' and 'L->hookmask', which trigger this
** function, can be changed asynchronously by signals.)
*/
void luaD_hook(lua_State *L, int event, int line, int ftransfer,
               int ntransfer) {
  lua_Hook hook = L->hook;
  if (hook && L->allowhook) { /* make sure there is a hook */
    int mask = (1 << 2) /* call is running a debug hook */;
    CallInfo *ci = L->ci;
    ptrdiff_t top = ((char *)(L->top) - (char *)L->stack);
    ptrdiff_t ci_top = ((char *)(ci->top) - (char *)L->stack);
    lua_Debug ar;
    ar.event = event;
    ar.currentline = line;
    ar.i_ci = ci;
    if (ntransfer != 0) {
      mask |= (1 << 7) /* 'ci' has transfer information */; /* 'ci' has transfer
                                                               information */
      ci->u2.transferinfo.ftransfer = ftransfer;
      ci->u2.transferinfo.ntransfer = ntransfer;
    }
    if (L->stack_last - L->top <= (20)) {
      (void)0;
      luaD_growstack(L, 20, 1);
      (void)0;
    } else {
      ((void)0);
    }; /* ensure minimum stack size */
    if (L->top + 20 > ci->top)
      ci->top = L->top + 20;
    L->allowhook = 0; /* cannot call hooks inside a hook */
    ci->callstatus |= mask;
    ((void)0);
    (*hook)(L, &ar);
    ((void)0);
    ((void)0);
    L->allowhook = 1;
    ci->top = ((StkId)((char *)L->stack + (ci_top)));
    L->top = ((StkId)((char *)L->stack + (top)));
    ci->callstatus &= ~mask;
  }
}

/*
** Executes a call hook for Lua functions. This function is called
** whenever 'hookmask' is not zero, so it checks whether call hooks are
** active.
*/
void luaD_hookcall(lua_State *L, CallInfo *ci) {
  int hook = (ci->callstatus & (1 << 4) /* call was tail called */) ? 4 : 0;
  Proto *p;
  if (!(L->hookmask & (1 << 0))) /* some other hook? */
    return;                      /* don't call hook */
  p = ((&((((union GCUnion *)(((((&(ci->func)->val))->value_).gc))))->cl.l)))
          ->p;
  L->top = ci->top;  /* prepare top */
  ci->u.l.savedpc++; /* hooks assume 'pc' is already incremented */
  luaD_hook(L, hook, -1, 1, p->numparams);
  ci->u.l.savedpc--; /* correct 'pc' */
}

static StkId rethook(lua_State *L, CallInfo *ci, StkId firstres, int nres) {
  ptrdiff_t oldtop =
      ((char *)(L->top) - (char *)L->stack); /* hook may change top */
  int delta = 0;
  if ((!((ci)->callstatus & ((1 << 1) /* call is running a C function */ |
                             (1 << 2) /* call is running a debug hook */)))) {
    Proto *p =
        ((&((((union GCUnion *)(((((&(ci->func)->val))->value_).gc))))->cl.l)))
            ->p;
    if (p->is_vararg)
      delta = ci->u.l.nextraargs + p->numparams + 1;
    if (L->top < ci->top)
      L->top = ci->top; /* correct top to run hook */
  }
  if (L->hookmask & (1 << 1)) { /* is return hook on? */
    int ftransfer;
    ci->func += delta; /* if vararg, back to virtual 'func' */
    ftransfer = ((unsigned short)(firstres - ci->func));
    luaD_hook(L, 1, -1, ftransfer, nres); /* call it */
    ci->func -= delta;
  }
  if ((!((ci->previous)->callstatus &
         (1 << 1) /* call is running a C function */)))
    L->oldpc = ci->previous->u.l.savedpc; /* update 'oldpc' */
  return ((StkId)((char *)L->stack + (oldtop)));
}

/*
** Check whether __call metafield of 'func' is a function. If so, put
** it in stack below original 'func' so that 'luaD_call' can call
** it. Raise an error if __call metafield is not a function.
*/
void luaD_tryfuncTM(lua_State *L, StkId func) {
  const TValue *tm = luaT_gettmbyobj(L, (&(func)->val), TM_CALL);
  StkId p;
  if ((__builtin_expect(((!((((((tm)->tt_)) & 0x0F)) == (6))) != 0), 0)))
    luaG_typeerror(L, (&(func)->val), "call");
  for (p = L->top; p > func; p--) {
    TValue *io1 = ((&(p)->val));
    const TValue *io2 = ((&(p - 1)->val));
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
  L->top++; /* assume EXTRA_STACK */
  {
    TValue *io1 = ((&(func)->val));
    const TValue *io2 = (tm);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  }; /* metamethod is the new function to be called */
}

/*
** Given 'nres' results at 'firstResult', move 'wanted' of them to 'res'.
** Handle most typical cases (zero results for commands, one result for
** expressions, multiple results for tail calls/single parameters)
** separated.
*/
static void moveresults(lua_State *L, StkId res, int nres, int wanted) {
  StkId firstresult;
  int i;
  switch (wanted) { /* handle typical cases separately */
  case 0:           /* no values needed */
    L->top = res;
    return;
  case 1:                           /* one value needed */
    if (nres == 0)                  /* no results? */
      (((&(res)->val))->tt_ = (0)); /* adjust with nil */
    else {
      TValue *io1 = ((&(res)->val));
      const TValue *io2 = ((&(L->top - nres)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    }; /* move it to proper place */
    L->top = res + 1;
    return;
  case (-1):
    wanted = nres; /* we want all results */
    break;
  default:                   /* multiple results (or to-be-closed variables) */
    if (((wanted) < (-1))) { /* to-be-closed variables? */
      ptrdiff_t savedres = ((char *)(res) - (char *)L->stack);
      luaF_close(L, res, 0); /* may change the stack */
      res = ((StkId)((char *)L->stack + (savedres)));
      wanted = (-(wanted)-3); /* correct value */
      if (wanted == (-1))
        wanted = nres;
    }
    break;
  }
  firstresult = L->top - nres; /* index of first result */
  /* move all results to correct place */
  for (i = 0; i < nres && i < wanted; i++) {
    TValue *io1 = ((&(res + i)->val));
    const TValue *io2 = ((&(firstresult + i)->val));
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
  for (; i < wanted; i++) /* complete wanted number of results */
    (((&(res + i)->val))->tt_ = (0));
  L->top = res + wanted; /* top points after the last result */
}

/*
** Finishes a function call: calls hook if necessary, removes CallInfo,
** moves current number of results to proper place.
*/
void luaD_poscall(lua_State *L, CallInfo *ci, int nres) {
  if (L->hookmask)
    L->top = rethook(L, ci, L->top - nres, nres);
  L->ci = ci->previous; /* back to caller */
  /* move results to proper place */
  moveresults(L, ci->func, nres, ci->nresults);
}

/*
** Prepare a function for a tail call, building its call info on top
** of the current call info. 'narg1' is the number of arguments plus 1
** (so that it includes the function itself).
*/
void luaD_pretailcall(lua_State *L, CallInfo *ci, StkId func, int narg1) {
  Proto *p =
      ((&((((union GCUnion *)(((((&(func)->val))->value_).gc))))->cl.l)))->p;
  int fsize = p->maxstacksize; /* frame size */
  int nfixparams = p->numparams;
  int i;
  for (i = 0; i < narg1; i++) /* move down function and arguments */
  {
    TValue *io1 = ((&(ci->func + i)->val));
    const TValue *io2 = ((&(func + i)->val));
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
  if (L->stack_last - L->top <= ((fsize))) {
    (void)0;
    luaD_growstack(L, (fsize), 1);
    {
      if ((L->l_G)->GCdebt > 0) {
        (void)0;
        luaC_step(L);
        (void)0;
      };
      ((void)0);
    };
  } else {
    ((void)0);
  };
  func = ci->func; /* moved-down function */
  for (; narg1 <= nfixparams; narg1++)
    (((&(func + narg1)->val))->tt_ = (0)); /* complete missing arguments */
  ci->top = func + 1 + fsize;              /* top for new function */
  ((void)0);
  ci->u.l.savedpc = p->code; /* starting point */
  ci->callstatus |= (1 << 4) /* call was tail called */;
  L->top = func + narg1; /* set top */
}

/*
** Call a function (C or Lua). The function to be called is at *func.
** The arguments are on the stack, right after the function.
** When returns, all the results are on the stack, starting at the original
** function position.
*/
void luaD_call(lua_State *L, StkId func, int nresults) {
  lua_CFunction f;
  TValue *funcv = (&(func)->val);
  switch (((((funcv)->tt_)) & 0x3F)) {
  case (6 | (3 << 4)) /* C closure */: /* C closure */
    f = ((&((((union GCUnion *)((((funcv)->value_).gc))))->cl.c)))->f;
    goto Cfunc;
  case (6 | (2 << 4)) /* light C function */: /* light C function */
    f = (((funcv)->value_).f);
  Cfunc : {
    int n; /* number of returns */
    CallInfo *ci;
    if (L->stack_last - L->top <= (20)) {
      ptrdiff_t t__ = ((char *)(func) - (char *)L->stack); /* save 'p' */
      {
        if ((L->l_G)->GCdebt > 0) {
          (void)0;
          luaC_step(L);
          (void)0;
        };
        ((void)0);
      };
      luaD_growstack(L, 20, 1); /* stack grow uses memory */
      func = ((StkId)((char *)L->stack + (t__)));
    } else {
      ((void)0);
    } /* 'pos' part: restore 'p' */; /* ensure minimum stack size */
    ci = (L->ci = (L->ci->next ? L->ci->next : luaE_extendCI(L)));
    ci->nresults = nresults;
    ci->callstatus = (1 << 1) /* call is running a C function */;
    ci->top = L->top + 20;
    ci->func = func;
    ((void)0);
    if (L->hookmask & (1 << 0)) {
      int narg = ((int)((L->top - func))) - 1;
      luaD_hook(L, 0, -1, 1, narg);
    }
    ((void)0);
    n = (*f)(L); /* do the actual call */
    ((void)0);
    ((void)0);
    luaD_poscall(L, ci, n);
    break;
  }
  case (6 | (1 << 4)) /* Lua closure */: { /* Lua function */
    CallInfo *ci;
    Proto *p = ((&((((union GCUnion *)((((funcv)->value_).gc))))->cl.l)))->p;
    int narg = ((int)((L->top - func))) - 1; /* number of real arguments */
    int nfixparams = p->numparams;
    int fsize = p->maxstacksize; /* frame size */
    if (L->stack_last - L->top <= (fsize)) {
      ptrdiff_t t__ = ((char *)(func) - (char *)L->stack); /* save 'p' */
      {
        if ((L->l_G)->GCdebt > 0) {
          (void)0;
          luaC_step(L);
          (void)0;
        };
        ((void)0);
      };
      luaD_growstack(L, fsize, 1); /* stack grow uses memory */
      func = ((StkId)((char *)L->stack + (t__)));
    } else {
      ((void)0);
    } /* 'pos' part: restore 'p' */;
    ci = (L->ci = (L->ci->next ? L->ci->next : luaE_extendCI(L)));
    ci->nresults = nresults;
    ci->u.l.savedpc = p->code; /* starting point */
    ci->callstatus = 0;
    ci->top = func + 1 + fsize;
    ci->func = func;
    for (; narg < nfixparams; narg++)
      (((&(L->top++)->val))->tt_ = (0)); /* complete missing arguments */
    ((void)0);
    luaV_execute(L, ci); /* run the function */
    break;
  }
  default: {                      /* not a function */
    luaD_tryfuncTM(L, func);      /* try to get '__call' metamethod */
    luaD_call(L, func, nresults); /* now it must be a function */
    break;
  }
  }
}

/*
** Similar to 'luaD_call', but does not allow yields during the call.
** If there is a stack overflow, freeing all CI structures will
** force the subsequent call to invoke 'luaE_extendCI', which then
** will raise any errors.
*/
void luaD_callnoyield(lua_State *L, StkId func, int nResults) {
  ((L)->nCcalls += 0x10000 + 10);
  if (((L)->nCcalls & 0xffff) >= 2200) /* possible stack overflow? */
    luaE_freeCI(L);
  luaD_call(L, func, nResults);
  ((L)->nCcalls -= 0x10000 + 10);
}

/*
** Completes the execution of an interrupted C function, calling its
** continuation function.
*/
static void finishCcall(lua_State *L, int status) {
  CallInfo *ci = L->ci;
  int n;
  /* must have a continuation and must be able to call it */
  ((void)0);
  /* error status can only happen in a protected call */
  ((void)0);
  if (ci->callstatus &
      (1 << 3) /* call is a yieldable protected call */) { /* was inside a
                                                              pcall? */
    ci->callstatus &=
        ~(1 << 3) /* call is a yieldable protected call */; /* continuation is
                                                               also inside it */
    L->errfunc = ci->u.c.old_errfunc; /* with the same error function */
  }
  /* finish 'lua_callk'/'lua_pcall'; CIST_YPCALL and 'errfunc' already
     handled */
  {
    if ((ci->nresults) <= (-1) && L->ci->top < L->top)
      L->ci->top = L->top;
  };
  ((void)0);
  n = (*ci->u.c.k)(L, status, ci->u.c.ctx); /* call continuation function */
  ((void)0);
  ((void)0);
  luaD_poscall(L, ci, n); /* finish 'luaD_call' */
}

/*
** Executes "full continuation" (everything in the stack) of a
** previously interrupted coroutine until the stack is empty (or another
** interruption long-jumps out of the loop). If the coroutine is
** recovering from an error, 'ud' points to the error status, which must
** be passed to the first continuation function (otherwise the default
** status is LUA_YIELD).
*/
static void unroll(lua_State *L, void *ud) {
  CallInfo *ci;
  if (ud != ((void *)0))                /* error status? */
    finishCcall(L, *(int *)ud);         /* finish 'lua_pcallk' callee */
  while ((ci = L->ci) != &L->base_ci) { /* something in the stack */
    if (!(!((ci)->callstatus &
            (1 << 1) /* call is running a C function */))) /* C function? */
      finishCcall(L, 1);   /* complete its execution */
    else {                 /* Lua function */
      luaV_finishOp(L);    /* finish interrupted instruction */
      luaV_execute(L, ci); /* execute down to higher C 'boundary' */
    }
  }
}

/*
** Try to find a suspended protected call (a "recover point") for the
** given thread.
*/
static CallInfo *findpcall(lua_State *L) {
  CallInfo *ci;
  for (ci = L->ci; ci != ((void *)0);
       ci = ci->previous) { /* search for a pcall */
    if (ci->callstatus & (1 << 3) /* call is a yieldable protected call */)
      return ci;
  }
  return ((void *)0); /* no pending pcall */
}

/*
** Recovers from an error in a coroutine. Finds a recover point (if
** there is one) and completes the execution of the interrupted
** 'luaD_pcall'. If there is no recover point, returns zero.
*/
static int recover(lua_State *L, int status) {
  StkId oldtop;
  CallInfo *ci = findpcall(L);
  if (ci == ((void *)0))
    return 0; /* no recovery point */
  /* "finish" luaD_pcall */
  oldtop = ((StkId)((char *)L->stack + (ci->u2.funcidx)));
  luaF_close(L, oldtop, status); /* may change the stack */
  oldtop = ((StkId)((char *)L->stack + (ci->u2.funcidx)));
  luaD_seterrorobj(L, status, oldtop);
  L->ci = ci;
  L->allowhook =
      ((ci->callstatus) &
       (1 << 0) /* original value of 'allowhook' */); /* restore original
                                                         'allowhook' */
  luaD_shrinkstack(L);
  L->errfunc = ci->u.c.old_errfunc;
  return 1; /* continue running the coroutine */
}

/*
** Signal an error in the call to 'lua_resume', not in the execution
** of the coroutine itself. (Such errors should not be handled by any
** coroutine error handler and should not kill the coroutine.)
*/
static int resume_error(lua_State *L, const char *msg, int narg) {
  L->top -= narg; /* remove args from the stack */
  {
    TValue *io = ((&(L->top)->val));
    TString *x_ = (luaS_new(L, msg));
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((x_->tt) | (1 << 6))));
    ((void)0);
  }; /* push error message */
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
  return 2;
}

/*
** Do the work for 'lua_resume' in protected mode. Most of the work
** depends on the status of the coroutine: initial state, suspended
** inside a hook, or regularly suspended (optionally with a continuation
** function), plus erroneous cases: non-suspended coroutine or dead
** coroutine.
*/
static void resume(lua_State *L, void *ud) {
  int n = *(((int *)(ud)));    /* number of arguments */
  StkId firstArg = L->top - n; /* first argument */
  CallInfo *ci = L->ci;
  if (L->status == 0) { /* starting a coroutine? */
    luaD_call(L, firstArg - 1, (-1));
  } else { /* resuming from previous yield */
    ((void)0);
    L->status = 0; /* mark that it is running (again) */
    if ((!((ci)->callstatus &
           (1 << 1) /* call is running a C function */))) /* yielded inside a
                                                             hook? */
      luaV_execute(L, ci); /* just continue running Lua code */
    else {                 /* 'common' yield */
      if (ci->u.c.k !=
          ((void *)0)) { /* does it have a continuation function? */
        ((void)0);
        n = (*ci->u.c.k)(L, 1, ci->u.c.ctx); /* call continuation */
        ((void)0);
        ((void)0);
      }
      luaD_poscall(L, ci, n); /* finish 'luaD_call' */
    }
    unroll(L, ((void *)0)); /* run continuation */
  }
}

extern int lua_resume(lua_State *L, lua_State *from, int nargs, int *nresults) {
  int status;
  ((void)0);
  if (L->status == 0) {       /* may be starting a coroutine */
    if (L->ci != &L->base_ci) /* not in base level? */
      return resume_error(L, "cannot resume non-suspended coroutine", nargs);
  } else if (L->status != 1)
    return resume_error(L, "cannot resume dead coroutine", nargs);
  if (from == ((void *)0))
    L->nCcalls = 1;
  else /* correct 'nCcalls' for this thread */
    L->nCcalls = ((from)->nCcalls & 0xffff) - from->nci + L->nci + 10;
  if (L->nCcalls >= 2200)
    return resume_error(L, "C stack overflow", nargs);
  ((void)L);
  ((void)0);
  status = luaD_rawrunprotected(L, resume, &nargs);
  /* continue running after recoverable errors */
  while (((status) > 1) && recover(L, status)) {
    /* unroll continuation */
    status = luaD_rawrunprotected(L, unroll, &status);
  }
  if ((__builtin_expect(((!((status) > 1)) != 0), 1)))
    ((void)0);                                 /* normal end or yield */
  else {                                       /* unrecoverable error */
    status = luaF_close(L, L->stack, status);  /* close all upvalues */
    L->status = ((lu_byte)((status)));         /* mark thread as 'dead' */
    luaD_seterrorobj(L, status, L->stack + 1); /* push error message */
    L->ci = &L->base_ci; /* back to the original C level */
    L->ci->top = L->top;
  }
  *nresults =
      (status == 1) ? L->ci->u2.nyield : ((int)((L->top - (L->ci->func + 1))));
  ((void)0);
  return status;
}

extern int lua_isyieldable(lua_State *L) {
  return (((L)->nCcalls & 0xffff0000) == 0);
}

extern int lua_yieldk(lua_State *L, int nresults, lua_KContext ctx,
                      lua_KFunction k) {
  CallInfo *ci = L->ci;
  ((void)L);
  ((void)0);
  ((void)0);
  if ((__builtin_expect(((!(((L)->nCcalls & 0xffff0000) == 0)) != 0), 0))) {
    if (L != (L->l_G)->mainthread)
      luaG_runerror(L, "attempt to yield across a C-call boundary");
    else
      luaG_runerror(L, "attempt to yield from outside a coroutine");
  }
  L->status = 1;
  if ((!((ci)->callstatus &
         (1 << 1) /* call is running a C function */))) { /* inside a hook? */
    ((void)0);
    ((void)0);
    ci->u2.nyield = 0; /* no results */
  } else {
    if ((ci->u.c.k = k) != ((void *)0)) /* is there a continuation? */
      ci->u.c.ctx = ctx;                /* save context */
    ci->u2.nyield = nresults;           /* save number of results */
    luaD_throw(L, 1);
  }
  ((void)0); /* must be inside a hook */
  ((void)0);
  return 0; /* return to 'luaD_hook' */
}

/*
** Call the C function 'func' in protected mode, restoring basic
** thread information ('allowhook', etc.) and in particular
** its stack level in case of errors.
*/
int luaD_pcall(lua_State *L, Pfunc func, void *u, ptrdiff_t old_top,
               ptrdiff_t ef) {
  int status;
  CallInfo *old_ci = L->ci;
  lu_byte old_allowhooks = L->allowhook;
  ptrdiff_t old_errfunc = L->errfunc;
  L->errfunc = ef;
  status = luaD_rawrunprotected(L, func, u);
  if ((__builtin_expect(((status != 0) != 0), 0))) { /* an error occurred? */
    StkId oldtop = ((StkId)((char *)L->stack + (old_top)));
    L->ci = old_ci;
    L->allowhook = old_allowhooks;
    status = luaF_close(L, oldtop, status);
    oldtop = ((StkId)((char *)L->stack +
                      (old_top))); /* previous call may change stack */
    luaD_seterrorobj(L, status, oldtop);
    luaD_shrinkstack(L);
  }
  L->errfunc = old_errfunc;
  return status;
}

/*
** Execute a protected parser.
*/
struct SParser { /* data to 'f_parser' */
  ZIO *z;
  Mbuffer buff; /* dynamic structure used by the scanner */
  Dyndata dyd;  /* dynamic structures used by the parser */
  const char *mode;
  const char *name;
};

static void checkmode(lua_State *L, const char *mode, const char *x) {
  if (mode && strchr(mode, x[0]) == ((void *)0)) {
    luaO_pushfstring(L, "attempt to load a %s chunk (mode is '%s')", x, mode);
    luaD_throw(L, 3);
  }
}

static void f_parser(lua_State *L, void *ud) {
  LClosure *cl;
  struct SParser *p = ((struct SParser *)(ud));
  int c = (((p->z)->n--) > 0 ? ((unsigned char)((*(p->z)->p++)))
                             : luaZ_fill(p->z)); /* read first character */
  if (c == "\x1bLua"[0]) {
    checkmode(L, p->mode, "binary");
    cl = luaU_undump(L, p->z, p->name);
  } else {
    checkmode(L, p->mode, "text");
    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);
  }
  ((void)0);
  luaF_initupvals(L, cl);
}

int luaD_protectedparser(lua_State *L, ZIO *z, const char *name,
                         const char *mode) {
  struct SParser p;
  int status;
  ((L)->nCcalls += 0x10000); /* cannot yield during parsing */
  p.z = z;
  p.name = name;
  p.mode = mode;
  p.dyd.actvar.arr = ((void *)0);
  p.dyd.actvar.size = 0;
  p.dyd.gt.arr = ((void *)0);
  p.dyd.gt.size = 0;
  p.dyd.label.arr = ((void *)0);
  p.dyd.label.size = 0;
  ((&p.buff)->buffer = ((void *)0), (&p.buff)->buffsize = 0);
  status = luaD_pcall(L, f_parser, &p, ((char *)(L->top) - (char *)L->stack),
                      L->errfunc);
  ((&p.buff)->buffer = ((char *)((luaM_saferealloc_(
       L, ((&p.buff)->buffer), ((&p.buff)->buffsize) * sizeof(char),
       (0) * sizeof(char))))),
   (&p.buff)->buffsize = 0);
  luaM_free_(L, (p.dyd.actvar.arr),
             (p.dyd.actvar.size) * sizeof(*(p.dyd.actvar.arr)));
  luaM_free_(L, (p.dyd.gt.arr), (p.dyd.gt.size) * sizeof(*(p.dyd.gt.arr)));
  luaM_free_(L, (p.dyd.label.arr),
             (p.dyd.label.size) * sizeof(*(p.dyd.label.arr)));
  ((L)->nCcalls -= 0x10000);
  return status;
}
/*
** $Id: lvm.c $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 2002-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>
 */
/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */

/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lfunc.h $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/
/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lopcodes.h $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltable.h $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltm.h $
** Tag methods
** See Copyright Notice in lua.h
*/
/*
** $Id: lvm.h $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

/*
** By default, use jump tables in the main interpreter loop on gcc
** and compatible compilers.
*/
/* limit for table tag-method chains (to avoid infinite loops) */

/*
** 'l_intfitsf' checks whether a given integer is in the range that
** can be converted to a float without rounding. Used in comparisons.
*/

/* number of bits in the mantissa of a float */

/*
** Check whether some integers may not fit in a float, testing whether
** (maxinteger >> NBM) > 0. (That implies (1 << NBM) <= maxinteger.)
** (The shifts are done in parts, to avoid shifting by more than the size
** of an integer. In a worst case, NBM == 113 for long double and
** sizeof(long) == 32.)
*/

/* limit for integers that fit in a float */

/* check whether 'i' is in the interval [-MAXINTFITSF, MAXINTFITSF] */
/*
** Try to convert a value to a float. The float case is already handled
** by the macro 'tonumber'.
*/
int luaV_tonumber_(const TValue *obj, lua_Number *n) {
  TValue v;
  if (((((obj))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
    *n = ((lua_Number)(((((obj)->value_).i))));
    return 1;
  } else if ((((((((obj))->tt_)) & 0x0F)) ==
              (4)) && /* string coercible to number? */
             luaO_str2num(
                 (((char *)(((((
                      &((((union GCUnion *)((((obj)->value_).gc))))->ts))))))) +
                  sizeof(TString)),
                 &v) ==
                 ((((&((((union GCUnion *)((((obj)->value_).gc))))->ts))))
                              ->tt == (4 | (1 << 4)) /* short strings */
                      ? (((&((((union GCUnion *)((((obj)->value_).gc))))->ts))))
                            ->shrlen
                      : (((&((((union GCUnion *)((((obj)->value_).gc))))->ts))))
                            ->u.lnglen) +
                     1) {
    *n = ((((((&v))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
               ? ((lua_Number)(((((&v)->value_).i))))
               : (((&v)->value_)
                      .n))); /* convert result of 'luaO_str2num' to a float */
    return 1;
  } else
    return 0; /* conversion failed */
}

/*
** try to convert a float to an integer, rounding according to 'mode':
** mode == 0: accepts only integral values
** mode == 1: takes the floor of the number
** mode == 2: takes the ceil of the number
*/
int luaV_flttointeger(lua_Number n, lua_Integer *p, int mode) {
  lua_Number f = (floor(n));
  if (n != f) { /* not an integral value? */
    if (mode == 0)
      return 0;        /* fails if mode demands integral value */
    else if (mode > 1) /* needs ceil? */
      f += 1;          /* convert floor to ceil (remember: n != f) */
  }
  return ((f) >= (double)((-0x7fffffffffffffffLL - 1)) &&
          (f) < -(double)((-0x7fffffffffffffffLL - 1)) &&
          (*(p) = (long long)(f), 1));
}

/*
** try to convert a value to an integer, rounding according to 'mode',
** without string coercion.
** ("Fast track" handled by macro 'tointegerns'.)
*/
int luaV_tointegerns(const TValue *obj, lua_Integer *p, int mode) {
  if (((((obj))->tt_) == ((3 | (1 << 4)) /* float numbers */)))
    return luaV_flttointeger((((obj)->value_).n), p, mode);
  else if (((((obj))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
    *p = (((obj)->value_).i);
    return 1;
  } else
    return 0;
}

/*
** try to convert a value to an integer.
*/
int luaV_tointeger(const TValue *obj, lua_Integer *p, int mode) {
  TValue v;
  if ((((((((obj))->tt_)) & 0x0F)) == (4)) &&
      luaO_str2num((((char *)(((((&(
                        (((union GCUnion *)((((obj)->value_).gc))))->ts))))))) +
                    sizeof(TString)),
                   &v) ==
          ((((&((((union GCUnion *)((((obj)->value_).gc))))->ts))))->tt ==
                   (4 | (1 << 4)) /* short strings */
               ? (((&((((union GCUnion *)((((obj)->value_).gc))))->ts))))
                     ->shrlen
               : (((&((((union GCUnion *)((((obj)->value_).gc))))->ts))))
                     ->u.lnglen) +
              1)
    obj = &v; /* change string to its corresponding number */
  return luaV_tointegerns(obj, p, mode);
}

/*
** Try to convert a 'for' limit to an integer, preserving the semantics
** of the loop.  (The following explanation assumes a positive step;
** it is valid for negative steps mutatis mutandis.)
** Return true if the loop must not run.
** If the limit is an integer or can be converted to an integer,
** rounding down, that is the limit.
** Otherwise, check whether the limit can be converted to a float. If
** the float is too large, clip it to LUA_MAXINTEGER.  If the float
** is too negative, the loop should not run, because any initial
** integer value is greater than such limit; so, it returns true to
** signal that.
** (For this latter case, no integer limit would be correct; even a
** limit of LUA_MININTEGER would run the loop once for an initial
** value equal to LUA_MININTEGER.)
*/
static int forlimit(lua_State *L, lua_Integer init, const TValue *lim,
                    lua_Integer *p, lua_Integer step) {
  if (!luaV_tointeger(lim, p, (step < 0 ? 2 : 1))) {
    /* not coercible to in integer */
    lua_Number flim; /* try to convert to float */
    if (!(((((lim))->tt_) == ((3 | (1 << 4)) /* float numbers */))
              ? (*(&flim) = (((lim)->value_).n), 1)
              : luaV_tonumber_(lim, &flim))) /* cannot convert to float? */
      luaG_forerror(L, lim, "limit");
    /* else 'flim' is a float out of integer bounds */
    if (((0) < (flim))) { /* if it is positive, it is too large */
      if (step < 0)
        return 1;                /* initial value must be less than it */
      *p = 0x7fffffffffffffffLL; /* truncate */
    } else {                     /* it is less than min integer */
      if (step > 0)
        return 1; /* initial value must be greater than it */
      *p = (-0x7fffffffffffffffLL - 1); /* truncate */
    }
  }
  return (step > 0 ? init > *p : init < *p); /* not to run? */
}

/*
** Finish the table access 'val = t[key]'.
** if 'slot' is NULL, 't' is not a table; otherwise, 'slot' points to
** t[k] entry (which must be empty).
*/
void luaV_finishget(lua_State *L, const TValue *t, TValue *key, StkId val,
                    const TValue *slot) {
  int loop;         /* counter to avoid infinite loops */
  const TValue *tm; /* metamethod */
  for (loop = 0; loop < 2000; loop++) {
    if (slot == ((void *)0)) { /* 't' is not a table? */
      ((void)0);
      tm = luaT_gettmbyobj(L, t, TM_INDEX);
      if ((__builtin_expect((((((((((tm))->tt_)) & 0x0F)) == (0))) != 0), 0)))
        luaG_typeerror(L, t, "index"); /* no metamethod */
      /* else will try the metamethod */
    } else { /* 't' is a table */
      ((void)0);
      tm = ((((&((((union GCUnion *)((((t)->value_).gc))))->h)))->metatable) ==
                    ((void *)0)
                ? ((void *)0)
                : ((((&((((union GCUnion *)((((t)->value_).gc))))->h)))
                        ->metatable)
                       ->flags &
                   (1u << (TM_INDEX)))
                      ? ((void *)0)
                      : luaT_gettm(
                            ((&((((union GCUnion *)((((t)->value_).gc))))->h)))
                                ->metatable,
                            TM_INDEX,
                            ((L->l_G))
                                ->tmname[TM_INDEX])); /* table's metamethod */
      if (tm == ((void *)0)) {                        /* no metamethod? */
        (((&(val)->val))->tt_ = (0));                 /* result is nil */
        return;
      }
      /* else will try the metamethod */
    }
    if (((((((tm)->tt_)) & 0x0F)) == (6))) { /* is metamethod a function? */
      luaT_callTMres(L, tm, t, key, val);    /* call it */
      return;
    }
    t = tm; /* else try to access 'tm[key]' */
    if ((!((((t))->tt_) == (((5) | (1 << 6))))
             ? (slot = ((void *)0),
                0) /* not a table; 'slot' is NULL and result is 0 */
             : (slot = luaH_get(
                    ((&((((union GCUnion *)((((t)->value_).gc))))->h))), key),
                /* else, do raw access */ !(
                    ((((((slot))->tt_)) & 0x0F)) ==
                    (0)))) /* result not empty? */) { /* fast track? */
      {
        TValue *io1 = ((&(val)->val));
        const TValue *io2 = (slot);
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      }; /* done */
      return;
    }
    /* else repeat (tail call 'luaV_finishget') */
  }
  luaG_runerror(L, "'__index' chain too long; possible loop");
}

/*
** Finish a table assignment 't[key] = val'.
** If 'slot' is NULL, 't' is not a table.  Otherwise, 'slot' points
** to the entry 't[key]', or to a value with an absent key if there
** is no such entry.  (The value at 'slot' must be empty, otherwise
** 'luaV_fastget' would have done the job.)
*/
void luaV_finishset(lua_State *L, const TValue *t, TValue *key, TValue *val,
                    const TValue *slot) {
  int loop; /* counter to avoid infinite loops */
  for (loop = 0; loop < 2000; loop++) {
    const TValue *tm;          /* '__newindex' metamethod */
    if (slot != ((void *)0)) { /* is 't' a table? */
      Table *h = ((&(
          (((union GCUnion *)((((t)->value_).gc))))->h))); /* save 't' table */
      ((void)0); /* slot must be empty */
      tm = ((h->metatable) == ((void *)0)
                ? ((void *)0)
                : ((h->metatable)->flags & (1u << (TM_NEWINDEX)))
                      ? ((void *)0)
                      : luaT_gettm(
                            h->metatable, TM_NEWINDEX,
                            ((L->l_G))
                                ->tmname[TM_NEWINDEX])); /* get metamethod */
      if (tm == ((void *)0)) {                           /* no metamethod? */
        if (((((slot))->tt_) == ((0 | (2 << 4))))) /* no previous entry? */
          slot = luaH_newkey(L, h, key);           /* create one */
        /* no metamethod and (now) there is an entry with given key */
        {
          TValue *io1 = (((TValue *)(slot)));
          const TValue *io2 = (val);
          io1->value_ = io2->value_;
          io1->tt_ = io2->tt_;
          (void)L;
          ((void)0);
          ((void)0);
        }; /* set its new value */
        ((h)->flags = 0);
        (((((val)->tt_) & (1 << 6)) &&
          ((((&(((union GCUnion *)((h)))->gc)))->marked) &
           ((1 << (5 /* object is black */)))) &&
          ((((((val)->value_).gc))->marked) &
           (((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */))))))
             ? luaC_barrierback_(L, (&(((union GCUnion *)((h)))->gc)))
             : ((void)((0))));
        return;
      }
      /* else will try the metamethod */
    } else { /* not a table; check metamethod */
      tm = luaT_gettmbyobj(L, t, TM_NEWINDEX);
      if ((__builtin_expect((((((((((tm))->tt_)) & 0x0F)) == (0))) != 0), 0)))
        luaG_typeerror(L, t, "index");
    }
    /* try the metamethod */
    if (((((((tm)->tt_)) & 0x0F)) == (6))) {
      luaT_callTM(L, tm, t, key, val);
      return;
    }
    t = tm; /* else repeat assignment over 'tm' */
    if ((!((((t))->tt_) == (((5) | (1 << 6))))
             ? (slot = ((void *)0),
                0) /* not a table; 'slot' is NULL and result is 0 */
             : (slot = luaH_get(
                    ((&((((union GCUnion *)((((t)->value_).gc))))->h))), key),
                /* else, do raw access */ !(((((((slot))->tt_)) & 0x0F)) ==
                                            (0)))) /* result not empty? */) {
      {
        {
          TValue *io1 = (((TValue *)(slot)));
          const TValue *io2 = (val);
          io1->value_ = io2->value_;
          io1->tt_ = io2->tt_;
          (void)L;
          ((void)0);
          ((void)0);
        };
        (((((val)->tt_) & (1 << 6)) &&
          ((((((t)->value_).gc))->marked) &
           ((1 << (5 /* object is black */)))) &&
          ((((((val)->value_).gc))->marked) &
           (((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */))))))
             ? luaC_barrierback_(L, (((t)->value_).gc))
             : ((void)((0))));
      };
      return; /* done */
    }
    /* else 'return luaV_finishset(L, t, key, val, slot)' (loop) */
  }
  luaG_runerror(L, "'__newindex' chain too long; possible loop");
}

/*
** Compare two strings 'ls' x 'rs', returning an integer less-equal-
** -greater than zero if 'ls' is less-equal-greater than 'rs'.
** The code is a little tricky because it allows '\0' in the strings
** and it uses 'strcoll' (to respect locales) for each segments
** of the strings.
*/
static int l_strcmp(const TString *ls, const TString *rs) {
  const char *l = (((char *)(((ls)))) + sizeof(TString));
  size_t ll = ((ls)->tt == (4 | (1 << 4)) /* short strings */ ? (ls)->shrlen
                                                              : (ls)->u.lnglen);
  const char *r = (((char *)(((rs)))) + sizeof(TString));
  size_t lr = ((rs)->tt == (4 | (1 << 4)) /* short strings */ ? (rs)->shrlen
                                                              : (rs)->u.lnglen);
  for (;;) { /* for each segment */
    int temp = strcoll(l, r);
    if (temp != 0)                  /* not equal? */
      return temp;                  /* done */
    else {                          /* strings are equal up to a '\0' */
      size_t len = strlen(l);       /* index of first '\0' in both strings */
      if (len == lr)                /* 'rs' is finished? */
        return (len == ll) ? 0 : 1; /* check 'ls' */
      else if (len == ll)           /* 'ls' is finished? */
        return -1; /* 'ls' is less than 'rs' ('rs' is not finished) */
      /* both strings longer than 'len'; go on comparing after the '\0' */
      len++;
      l += len;
      ll -= len;
      r += len;
      lr -= len;
    }
  }
}

/*
** Check whether integer 'i' is less than float 'f'. If 'i' has an
** exact representation as a float ('l_intfitsf'), compare numbers as
** floats. Otherwise, use the equivalence 'i < f <=> i < ceil(f)'.
** If 'ceil(f)' is out of integer range, either 'f' is greater than
** all integers or less than all integers.
** (The test with 'l_intfitsf' is only for performance; the else
** case is correct for all values, but it is slow due to the conversion
** from float to int.)
** When 'f' is NaN, comparisons must result in false.
*/
static int LTintfloat(lua_Integer i, lua_Number f) {
  if (((((lua_Unsigned)1 << ((53))) + ((lua_Unsigned)(i))) <=
       (2 * ((lua_Unsigned)1 << ((53))))))
    return ((((lua_Number)((i)))) < (f)); /* compare them as floats */
  else {                                  /* i < f <=> i < ceil(f) */
    lua_Integer fi;
    if (luaV_flttointeger(f, &fi, 2)) /* fi = ceil(f) */
      return i < fi;                  /* compare them as integers */
    else            /* 'f' is either greater or less than all integers */
      return f > 0; /* greater? */
  }
}

/*
** Check whether integer 'i' is less than or equal to float 'f'.
** See comments on previous function.
*/
static int LEintfloat(lua_Integer i, lua_Number f) {
  if (((((lua_Unsigned)1 << ((53))) + ((lua_Unsigned)(i))) <=
       (2 * ((lua_Unsigned)1 << ((53))))))
    return ((((lua_Number)((i)))) <= (f)); /* compare them as floats */
  else {                                   /* i <= f <=> i <= floor(f) */
    lua_Integer fi;
    if (luaV_flttointeger(f, &fi, 1)) /* fi = floor(f) */
      return i <= fi;                 /* compare them as integers */
    else            /* 'f' is either greater or less than all integers */
      return f > 0; /* greater? */
  }
}

/*
** Check whether float 'f' is less than integer 'i'.
** See comments on previous function.
*/
static int LTfloatint(lua_Number f, lua_Integer i) {
  if (((((lua_Unsigned)1 << ((53))) + ((lua_Unsigned)(i))) <=
       (2 * ((lua_Unsigned)1 << ((53))))))
    return ((f) < (((lua_Number)((i))))); /* compare them as floats */
  else {                                  /* f < i <=> floor(f) < i */
    lua_Integer fi;
    if (luaV_flttointeger(f, &fi, 1)) /* fi = floor(f) */
      return fi < i;                  /* compare them as integers */
    else            /* 'f' is either greater or less than all integers */
      return f < 0; /* less? */
  }
}

/*
** Check whether float 'f' is less than or equal to integer 'i'.
** See comments on previous function.
*/
static int LEfloatint(lua_Number f, lua_Integer i) {
  if (((((lua_Unsigned)1 << ((53))) + ((lua_Unsigned)(i))) <=
       (2 * ((lua_Unsigned)1 << ((53))))))
    return ((f) <= (((lua_Number)((i))))); /* compare them as floats */
  else {                                   /* f <= i <=> ceil(f) <= i */
    lua_Integer fi;
    if (luaV_flttointeger(f, &fi, 2)) /* fi = ceil(f) */
      return fi <= i;                 /* compare them as integers */
    else            /* 'f' is either greater or less than all integers */
      return f < 0; /* less? */
  }
}

/*
** Return 'l < r', for numbers.
*/
static int LTnum(const TValue *l, const TValue *r) {
  ((void)0);
  if (((((l))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
    lua_Integer li = (((l)->value_).i);
    if (((((r))->tt_) == ((3 | (2 << 4)) /* integer numbers */)))
      return li < (((r)->value_).i); /* both are integers */
    else                             /* 'l' is int and 'r' is float */
      return LTintfloat(li, (((r)->value_).n)); /* l < r ? */
  } else {
    lua_Number lf = (((l)->value_).n); /* 'l' must be float */
    if (((((r))->tt_) == ((3 | (1 << 4)) /* float numbers */)))
      return ((lf) < ((((r)->value_).n))); /* both are float */
    else                                   /* 'l' is float and 'r' is int */
      return LTfloatint(lf, (((r)->value_).i));
  }
}

/*
** Return 'l <= r', for numbers.
*/
static int LEnum(const TValue *l, const TValue *r) {
  ((void)0);
  if (((((l))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
    lua_Integer li = (((l)->value_).i);
    if (((((r))->tt_) == ((3 | (2 << 4)) /* integer numbers */)))
      return li <= (((r)->value_).i); /* both are integers */
    else                              /* 'l' is int and 'r' is float */
      return LEintfloat(li, (((r)->value_).n)); /* l <= r ? */
  } else {
    lua_Number lf = (((l)->value_).n); /* 'l' must be float */
    if (((((r))->tt_) == ((3 | (1 << 4)) /* float numbers */)))
      return ((lf) <= ((((r)->value_).n))); /* both are float */
    else                                    /* 'l' is float and 'r' is int */
      return LEfloatint(lf, (((r)->value_).i));
  }
}

/*
** return 'l < r' for non-numbers.
*/
static int lessthanothers(lua_State *L, const TValue *l, const TValue *r) {
  ((void)0);
  if ((((((((l))->tt_)) & 0x0F)) == (4)) &&
      (((((((r))->tt_)) & 0x0F)) == (4))) /* both are strings? */
    return l_strcmp(((&((((union GCUnion *)((((l)->value_).gc))))->ts))),
                    ((&((((union GCUnion *)((((r)->value_).gc))))->ts)))) < 0;
  else
    return luaT_callorderTM(L, l, r, TM_LT);
}

/*
** Main operation less than; return 'l < r'.
*/
int luaV_lessthan(lua_State *L, const TValue *l, const TValue *r) {
  if ((((((((l))->tt_)) & 0x0F)) == (3)) &&
      (((((((r))->tt_)) & 0x0F)) == (3))) /* both operands are numbers? */
    return LTnum(l, r);
  else
    return lessthanothers(L, l, r);
}

/*
** return 'l <= r' for non-numbers.
** If it needs a metamethod and there is no '__le', try '__lt', based
** on l <= r iff !(r < l) (assuming a total order). If the metamethod
** yields during this substitution, the continuation has to know about
** it (to negate the result of r<l); bit CIST_LEQ in the call status
** keeps that information.
*/
static int lessequalothers(lua_State *L, const TValue *l, const TValue *r) {
  ((void)0);
  if ((((((((l))->tt_)) & 0x0F)) == (4)) &&
      (((((((r))->tt_)) & 0x0F)) == (4))) /* both are strings? */
    return l_strcmp(((&((((union GCUnion *)((((l)->value_).gc))))->ts))),
                    ((&((((union GCUnion *)((((r)->value_).gc))))->ts)))) <= 0;
  else
    return luaT_callorderTM(L, l, r, TM_LE);
}

/*
** Main operation less than or equal to; return 'l <= r'.
*/
int luaV_lessequal(lua_State *L, const TValue *l, const TValue *r) {
  if ((((((((l))->tt_)) & 0x0F)) == (3)) &&
      (((((((r))->tt_)) & 0x0F)) == (3))) /* both operands are numbers? */
    return LEnum(l, r);
  else
    return lessequalothers(L, l, r);
}

/*
** Main operation for equality of Lua values; return 't1 == t2'.
** L == NULL means raw equality (no metamethods)
*/
int luaV_equalobj(lua_State *L, const TValue *t1, const TValue *t2) {
  const TValue *tm;
  if (((((t1)->tt_)) & 0x3F) !=
      ((((t2)->tt_)) & 0x3F)) { /* not the same variant? */
    if ((((((t1)->tt_)) & 0x0F)) != (((((t2)->tt_)) & 0x0F)) ||
        (((((t1)->tt_)) & 0x0F)) != 3)
      return 0; /* only numbers can be equal with different variants */
    else {      /* two numbers with different variants */
      lua_Integer i1, i2; /* compare them as integers */
      return ((((((t1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                   ? (*(&i1) = (((t1)->value_).i), 1)
                   : luaV_tointegerns(t1, &i1, 0)) &&
              (((((t2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                   ? (*(&i2) = (((t2)->value_).i), 1)
                   : luaV_tointegerns(t2, &i2, 0)) &&
              i1 == i2);
    }
  }
  /* values have same type and same variant */
  switch (((((t1)->tt_)) & 0x3F)) {
  case 0:
    return 1;
  case (3 | (2 << 4)) /* integer numbers */:
    return ((((t1)->value_).i) == (((t2)->value_).i));
  case (3 | (1 << 4)) /* float numbers */:
    return (((((t1)->value_).n)) == ((((t2)->value_).n)));
  case 1:
    return (((t1)->value_).b) == (((t2)->value_).b); /* true must be 1! */
  case 2:
    return (((t1)->value_).p) == (((t2)->value_).p);
  case (6 | (2 << 4)) /* light C function */:
    return (((t1)->value_).f) == (((t2)->value_).f);
  case (4 | (1 << 4)) /* short strings */:
    return ((((&((((union GCUnion *)((((t1)->value_).gc))))->ts)))) ==
            (((&((((union GCUnion *)((((t2)->value_).gc))))->ts)))));
  case (4 | (2 << 4)) /* long strings */:
    return luaS_eqlngstr(((&((((union GCUnion *)((((t1)->value_).gc))))->ts))),
                         ((&((((union GCUnion *)((((t2)->value_).gc))))->ts))));
  case 7: {
    if (((&((((union GCUnion *)((((t1)->value_).gc))))->u))) ==
        ((&((((union GCUnion *)((((t2)->value_).gc))))->u))))
      return 1;
    else if (L == ((void *)0))
      return 0;
    tm = ((((&((((union GCUnion *)((((t1)->value_).gc))))->u)))->metatable) ==
                  ((void *)0)
              ? ((void *)0)
              : ((((&((((union GCUnion *)((((t1)->value_).gc))))->u)))
                      ->metatable)
                     ->flags &
                 (1u << (TM_EQ)))
                    ? ((void *)0)
                    : luaT_gettm(
                          ((&((((union GCUnion *)((((t1)->value_).gc))))->u)))
                              ->metatable,
                          TM_EQ, ((L->l_G))->tmname[TM_EQ]));
    if (tm == ((void *)0))
      tm = ((((&((((union GCUnion *)((((t2)->value_).gc))))->u)))->metatable) ==
                    ((void *)0)
                ? ((void *)0)
                : ((((&((((union GCUnion *)((((t2)->value_).gc))))->u)))
                        ->metatable)
                       ->flags &
                   (1u << (TM_EQ)))
                      ? ((void *)0)
                      : luaT_gettm(
                            ((&((((union GCUnion *)((((t2)->value_).gc))))->u)))
                                ->metatable,
                            TM_EQ, ((L->l_G))->tmname[TM_EQ]));
    break; /* will try TM */
  }
  case 5: {
    if (((&((((union GCUnion *)((((t1)->value_).gc))))->h))) ==
        ((&((((union GCUnion *)((((t2)->value_).gc))))->h))))
      return 1;
    else if (L == ((void *)0))
      return 0;
    tm = ((((&((((union GCUnion *)((((t1)->value_).gc))))->h)))->metatable) ==
                  ((void *)0)
              ? ((void *)0)
              : ((((&((((union GCUnion *)((((t1)->value_).gc))))->h)))
                      ->metatable)
                     ->flags &
                 (1u << (TM_EQ)))
                    ? ((void *)0)
                    : luaT_gettm(
                          ((&((((union GCUnion *)((((t1)->value_).gc))))->h)))
                              ->metatable,
                          TM_EQ, ((L->l_G))->tmname[TM_EQ]));
    if (tm == ((void *)0))
      tm = ((((&((((union GCUnion *)((((t2)->value_).gc))))->h)))->metatable) ==
                    ((void *)0)
                ? ((void *)0)
                : ((((&((((union GCUnion *)((((t2)->value_).gc))))->h)))
                        ->metatable)
                       ->flags &
                   (1u << (TM_EQ)))
                      ? ((void *)0)
                      : luaT_gettm(
                            ((&((((union GCUnion *)((((t2)->value_).gc))))->h)))
                                ->metatable,
                            TM_EQ, ((L->l_G))->tmname[TM_EQ]));
    break; /* will try TM */
  }
  default:
    return (((t1)->value_).gc) == (((t2)->value_).gc);
  }
  if (tm == ((void *)0))                 /* no TM? */
    return 0;                            /* objects are different */
  luaT_callTMres(L, tm, t1, t2, L->top); /* call TM */
  return !(((((((((&(L->top)->val)))->tt_)) & 0x0F)) == (0)) ||
           ((((((&(L->top)->val)))->tt_) == (1)) &&
            ((((&(L->top)->val))->value_).b) == 0));
}

/* macro used by 'luaV_concat' to ensure that element at 'o' is a string */

/* copy strings in stack from top - n up to top - 1 to buffer */
static void copy2buff(StkId top, int n, char *buff) {
  size_t tl = 0; /* size already copied */
  do {
    size_t l =
        ((((&((((union GCUnion *)(((((&(top - n)->val))->value_).gc))))->ts))))
                     ->tt == (4 | (1 << 4)) /* short strings */
             ? (((&((((union GCUnion *)(((((&(top - n)->val))->value_).gc))))
                        ->ts))))
                   ->shrlen
             : (((&((((union GCUnion *)(((((&(top - n)->val))->value_).gc))))
                        ->ts))))
                   ->u.lnglen); /* length of string being copied */
    memcpy(buff + tl,
           (((char *)((
                (((&((((union GCUnion *)(((((&(top - n)->val))->value_).gc))))
                         ->ts))))))) +
            sizeof(TString)),
           l * sizeof(char));
    tl += l;
  } while (--n > 0);
}

/*
** Main operation for concatenation: concat 'total' values in the stack,
** from 'L->top - total' up to 'L->top - 1'.
*/
void luaV_concat(lua_State *L, int total) {
  ((void)0);
  do {
    StkId top = L->top;
    int n = 2; /* number of elements handled in this pass (at least 2) */
    if (!(((((((((&(top - 2)->val)))->tt_)) & 0x0F)) == (4)) ||
          ((((((((&(top - 2)->val)))->tt_)) & 0x0F)) == (3))) ||
        !(((((((((&(top - 1)->val)))->tt_)) & 0x0F)) == (4)) ||
          (((((((((&(top - 1)->val)))->tt_)) & 0x0F)) == (3)) &&
           (luaO_tostring(L, (&(top - 1)->val)), 1))))
      luaT_trybinTM(L, (&(top - 2)->val), (&(top - 1)->val), top - 2,
                    TM_CONCAT);
    else if (((((((&(top - 1)->val)))->tt_) ==
               ((((4 | (1 << 4)) /* short strings */) | (1 << 6)))) &&
              ((&((((union GCUnion *)(((((&(top - 1)->val))->value_).gc))))
                      ->ts)))
                      ->shrlen == 0)) /* second operand is empty? */
      ((void)(((((((((((&(top - 2)->val)))->tt_)) & 0x0F)) == (4)) ||
                (((((((((&(top - 2)->val)))->tt_)) & 0x0F)) == (3)) &&
                 (luaO_tostring(L, (&(top - 2)->val)),
                  1)))))); /* result is first operand */
    else if (((((((&(top - 2)->val)))->tt_) ==
               ((((4 | (1 << 4)) /* short strings */) | (1 << 6)))) &&
              ((&((((union GCUnion *)(((((&(top - 2)->val))->value_).gc))))
                      ->ts)))
                      ->shrlen == 0)) { /* first operand is empty string? */
      {
        TValue *io1 = ((&(top - 2)->val));
        const TValue *io2 = ((&(top - 1)->val));
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      }; /* result is second op. */
    } else {
      /* at least two non-empty string values; get as many as possible */
      size_t tl =
          ((((&((((union GCUnion *)(((((&(top - 1)->val))->value_).gc))))
                    ->ts))))
                       ->tt == (4 | (1 << 4)) /* short strings */
               ? (((&((((union GCUnion *)(((((&(top - 1)->val))->value_).gc))))
                          ->ts))))
                     ->shrlen
               : (((&((((union GCUnion *)(((((&(top - 1)->val))->value_).gc))))
                          ->ts))))
                     ->u.lnglen);
      TString *ts;
      /* collect total length and number of strings */
      for (n = 1; n < total &&
                  (((((((((&(top - n - 1)->val)))->tt_)) & 0x0F)) == (4)) ||
                   (((((((((&(top - n - 1)->val)))->tt_)) & 0x0F)) == (3)) &&
                    (luaO_tostring(L, (&(top - n - 1)->val)), 1)));
           n++) {
        size_t l =
            ((((&((((union GCUnion *)(((((&(top - n - 1)->val))->value_).gc))))
                      ->ts))))
                         ->tt == (4 | (1 << 4)) /* short strings */
                 ? (((&((((union GCUnion *)((
                             (((&(top - n - 1)->val))->value_).gc))))
                            ->ts))))
                       ->shrlen
                 : (((&((((union GCUnion *)((
                             (((&(top - n - 1)->val))->value_).gc))))
                            ->ts))))
                       ->u.lnglen);
        if ((__builtin_expect(((l >= ((sizeof(size_t) < sizeof(lua_Integer)
                                           ? ((size_t)(~(size_t)0))
                                           : (size_t)(0x7fffffffffffffffLL)) /
                                      sizeof(char)) -
                                         tl) != 0),
                              0)))
          luaG_runerror(L, "string length overflow");
        tl += l;
      }
      if (tl <= 40) { /* is result a short string? */
        char buff[40];
        copy2buff(top, n, buff); /* copy strings to buffer */
        ts = luaS_newlstr(L, buff, tl);
      } else { /* long string; copy strings directly to final result */
        ts = luaS_createlngstrobj(L, tl);
        copy2buff(top, n, (((char *)(((ts)))) + sizeof(TString)));
      }
      {
        TValue *io = ((&(top - n)->val));
        TString *x_ = (ts);
        ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
        ((io)->tt_ = (((x_->tt) | (1 << 6))));
        ((void)0);
      }; /* create result */
    }
    total -= n - 1;    /* got 'n' strings to create 1 new */
    L->top -= n - 1;   /* popped 'n' strings and pushed one */
  } while (total > 1); /* repeat until only 1 result left */
}

/*
** Main operation 'ra = #rb'.
*/
void luaV_objlen(lua_State *L, StkId ra, const TValue *rb) {
  const TValue *tm;
  switch (((((rb)->tt_)) & 0x3F)) {
  case 5: {
    Table *h = ((&((((union GCUnion *)((((rb)->value_).gc))))->h)));
    tm = ((h->metatable) == ((void *)0)
              ? ((void *)0)
              : ((h->metatable)->flags & (1u << (TM_LEN)))
                    ? ((void *)0)
                    : luaT_gettm(h->metatable, TM_LEN,
                                 ((L->l_G))->tmname[TM_LEN]));
    if (tm)
      break; /* metamethod? break switch to call it */
    {
      TValue *io = ((&(ra)->val));
      ((io)->value_).i = (luaH_getn(h));
      ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
    }; /* else primitive len */
    return;
  }
  case (4 | (1 << 4)) /* short strings */: {
    {
      TValue *io = ((&(ra)->val));
      ((io)->value_).i =
          (((&((((union GCUnion *)((((rb)->value_).gc))))->ts)))->shrlen);
      ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
    };
    return;
  }
  case (4 | (2 << 4)) /* long strings */: {
    {
      TValue *io = ((&(ra)->val));
      ((io)->value_).i =
          (((&((((union GCUnion *)((((rb)->value_).gc))))->ts)))->u.lnglen);
      ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
    };
    return;
  }
  default: { /* try metamethod */
    tm = luaT_gettmbyobj(L, rb, TM_LEN);
    if ((__builtin_expect((((((((((tm))->tt_)) & 0x0F)) == (0))) != 0),
                          0))) /* no metamethod? */
      luaG_typeerror(L, rb, "get length of");
    break;
  }
  }
  luaT_callTMres(L, tm, rb, rb, ra);
}

/*
** Integer division; return 'm // n', that is, floor(m/n).
** C division truncates its result (rounds towards zero).
** 'floor(q) == trunc(q)' when 'q >= 0' or when 'q' is integer,
** otherwise 'floor(q) == trunc(q) - 1'.
*/
lua_Integer luaV_idiv(lua_State *L, lua_Integer m, lua_Integer n) {
  if ((__builtin_expect(((((lua_Unsigned)(n)) + 1u <= 1u) != 0),
                        0))) { /* special cases: -1 or 0 */
    if (n == 0)
      luaG_runerror(L, "attempt to divide by zero");
    return ((lua_Integer)(
        ((lua_Unsigned)(0)) -
        ((lua_Unsigned)(m)))); /* n==-1; avoid overflow with 0x80000...//-1 */
  } else {
    lua_Integer q = m / n;         /* perform C division */
    if ((m ^ n) < 0 && m % n != 0) /* 'm/n' would be negative non-integer? */
      q -= 1;                      /* correct result for different rounding */
    return q;
  }
}

/*
** Integer modulus; return 'm % n'. (Assume that C '%' with
** negative operands follows C99 behavior. See previous comment
** about luaV_idiv.)
*/
lua_Integer luaV_mod(lua_State *L, lua_Integer m, lua_Integer n) {
  if ((__builtin_expect(((((lua_Unsigned)(n)) + 1u <= 1u) != 0),
                        0))) { /* special cases: -1 or 0 */
    if (n == 0)
      luaG_runerror(L, "attempt to perform 'n%%0'");
    return 0; /* m % -1 == 0; avoid overflow with 0x80000...%-1 */
  } else {
    lua_Integer r = m % n;
    if (r != 0 && (r ^ n) < 0) /* 'm/n' would be non-integer negative? */
      r += n;                  /* correct result for different rounding */
    return r;
  }
}

/*
** Float modulus
*/
lua_Number luaV_modf(lua_State *L, lua_Number m, lua_Number n) {
  lua_Number r;
  {
    (void)L;
    (r) = fmod(m, n);
    if (((r) > 0) ? (n) < 0 : ((r) < 0 && (n) > 0))
      (r) += (n);
  };
  return r;
}

/* number of bits in an integer */

/*
** Shift left operation. (Shift right just negates 'y'.)
*/
lua_Integer luaV_shiftl(lua_Integer x, lua_Integer y) {
  if (y < 0) { /* shift right? */
    if (y <= -((int)((sizeof(lua_Integer) * 8))))
      return 0;
    else
      return ((lua_Integer)(((lua_Unsigned)(x)) >> ((lua_Unsigned)(-y))));
  } else { /* shift left */
    if (y >= ((int)((sizeof(lua_Integer) * 8))))
      return 0;
    else
      return ((lua_Integer)(((lua_Unsigned)(x)) << ((lua_Unsigned)(y))));
  }
}

/*
** create a new Lua closure, push it in the stack, and initialize
** its upvalues.
*/
static void pushclosure(lua_State *L, Proto *p, UpVal **encup, StkId base,
                        StkId ra) {
  int nup = p->sizeupvalues;
  Upvaldesc *uv = p->upvalues;
  int i;
  LClosure *ncl = luaF_newLclosure(L, nup);
  ncl->p = p;
  {
    TValue *io = ((&(ra)->val));
    LClosure *x_ = (ncl);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = ((((6 | (1 << 4)) /* Lua closure */) | (1 << 6))));
    ((void)0);
  };                          /* anchor new closure in stack */
  for (i = 0; i < nup; i++) { /* fill in its upvalues */
    if (uv[i].instack)        /* upvalue refers to local variable? */
      ncl->upvals[i] = luaF_findupval(L, base + uv[i].idx);
    else /* get upvalue from enclosing function */
      ncl->upvals[i] = encup[uv[i].idx];
    (((((ncl)->marked) & ((1 << (5 /* object is black */)))) &&
      (((ncl->upvals[i])->marked) &
       (((1 << (3 /* object is white (type 0) */)) |
         (1 << (4 /* object is white (type 1) */))))))
         ? luaC_barrier_(L, (&(((union GCUnion *)((ncl)))->gc)),
                         (&(((union GCUnion *)((ncl->upvals[i])))->gc)))
         : ((void)((0))));
  }
}

/*
** finish execution of an opcode interrupted by a yield
*/
void luaV_finishOp(lua_State *L) {
  CallInfo *ci = L->ci;
  StkId base = ci->func + 1;
  Instruction inst = *(ci->u.l.savedpc - 1); /* interrupted instruction */
  OpCode op =
      (((OpCode)(((inst) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))));
  switch (op) { /* finish its execution */
  case OP_ADDI:
  case OP_SUBI:
  case OP_MULI:
  case OP_DIVI:
  case OP_IDIVI:
  case OP_MODI:
  case OP_POWI:
  case OP_ADD:
  case OP_SUB:
  case OP_MUL:
  case OP_DIV:
  case OP_IDIV:
  case OP_BANDK:
  case OP_BORK:
  case OP_BXORK:
  case OP_BAND:
  case OP_BOR:
  case OP_BXOR:
  case OP_SHRI:
  case OP_SHL:
  case OP_SHR:
  case OP_MOD:
  case OP_POW:
  case OP_UNM:
  case OP_BNOT:
  case OP_LEN:
  case OP_GETTABUP:
  case OP_GETTABLE:
  case OP_GETI:
  case OP_GETFIELD:
  case OP_SELF: {
    {
      TValue *io1 =
          ((&(base + (((int)((((inst) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8))) << (0)))))))
                 ->val));
      const TValue *io2 = ((&(--L->top)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    break;
  }
  case OP_LT:
  case OP_LE:
  case OP_LTI:
  case OP_LEI:
  case OP_GTI:
  case OP_GEI:
  case OP_EQ: { /* note that 'OP_EQI'/'OP_EQK' cannot yield */
    int res = !(((((((((&(L->top - 1)->val)))->tt_)) & 0x0F)) == (0)) ||
                ((((((&(L->top - 1)->val)))->tt_) == (1)) &&
                 ((((&(L->top - 1)->val))->value_).b) == 0));
    L->top--;

    ((void)0);
    if (res != ((((int)((((inst) >> (((0 + 7) + 8))) &
                         ((~((~(Instruction)0) << (1)))
                          << (0)))))))) /* condition failed? */
      ci->u.l.savedpc++;                /* skip jump instruction */
    break;
  }
  case OP_CONCAT: {
    StkId top = L->top - 1; /* top when 'luaT_trybinTM' was called */
    int a = (((int)((((inst) >> ((0 + 7))) &
                     ((~((~(Instruction)0) << (8)))
                      << (0)))))); /* first element to concatenate */
    int total = ((int)((top - 1 - (base + a)))); /* yet to concatenate */
    {
      TValue *io1 = ((&(top - 2)->val));
      const TValue *io2 = ((&(top)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };                       /* put TM result in proper position */
    if (total > 1) {         /* are there elements to concat? */
      L->top = top - 1;      /* top is one after last element (at top-2) */
      luaV_concat(L, total); /* concat them (may yield again) */
    }
    break;
  }
  default: {
    /* only these other opcodes can yield */
    ((void)0)

        ;
    break;
  }
  }
}

/*
** {==================================================================
** Macros for arithmetic/bitwise/comparison opcodes in 'luaV_execute'
** ===================================================================
*/
/*
** Auxiliary macro for arithmetic operations over floats and others
** with immediate operand. 'fop' is the float operation; 'tm' is the
** corresponding metamethod; 'flip' is true if operands were flipped.
*/
/*
** Arithmetic operations over floats and others with immediate operand.
*/

/*
** Arithmetic operations with immediate operands. 'iop' is the integer
** operation.
*/
/*
** Auxiliary function for arithmetic operations over floats and others
** with two register operands.
*/
/*
** Arithmetic operations over floats and others with register operands.
*/

/*
** Arithmetic operations with register operands.
*/
/*
** Arithmetic operations with K operands.
*/
/*
** Arithmetic operations with K operands for floats.
*/
/*
** Bitwise operations with constant operand.
*/
/*
** Bitwise operations with register operands.
*/
/*
** Order operations with register operands.
*/
/*
** Order operations with immediate operand.
*/
/* }================================================================== */

/*
** {==================================================================
** Function 'luaV_execute': main interpreter loop
** ===================================================================
*/

/*
** some macros for common tasks in 'luaV_execute'
*/
/*
** Execute a jump instruction. The 'updatetrap' allows signals to stop
** tight loops. (Without it, the local copy of 'trap' could never change.)
*/

/* for test instructions, execute the jump instruction that follows it */

/*
** do a conditional jump: skip next instruction if 'cond' is not what
** was expected (parameter 'k'), else do next instruction, which must
** be a jump.
*/

/*
** Correct global 'pc'.
*/

/*
** Whenever code can raise errors, the global 'pc' and the global
** 'top' must be correct to report occasional errors.
*/

/*
** Protect code that, in general, can raise errors, reallocate the
** stack, and change the hooks.
*/

/* special version that does not change the top */

/*
** Protect code that will finish the loop (returns) or can only raise
** errors. (That is, it will not return to the interpreter main loop
** after changing the stack or hooks.)
*/
/* fetch an instruction and prepare its execution */
void luaV_execute(lua_State *L, CallInfo *ci) {
  LClosure *cl;
  TValue *k;
  StkId base;
  const Instruction *pc;
  int trap;

  /*
  ** $Id: ljumptab.h $
  ** Jump Table for the Lua interpreter
  ** See Copyright Notice in lua.h
  */
  static void *disptab[((int)(OP_EXTRAARG) + 1)] = {&&L_OP_MOVE,
                                                    &&L_OP_LOADI,
                                                    &&L_OP_LOADF,
                                                    &&L_OP_LOADK,
                                                    &&L_OP_LOADKX,
                                                    &&L_OP_LOADBOOL,
                                                    &&L_OP_LOADNIL,
                                                    &&L_OP_GETUPVAL,
                                                    &&L_OP_SETUPVAL,
                                                    &&L_OP_GETTABUP,
                                                    &&L_OP_GETTABLE,
                                                    &&L_OP_GETI,
                                                    &&L_OP_GETFIELD,
                                                    &&L_OP_SETTABUP,
                                                    &&L_OP_SETTABLE,
                                                    &&L_OP_SETI,
                                                    &&L_OP_SETFIELD,
                                                    &&L_OP_NEWTABLE,
                                                    &&L_OP_SELF,
                                                    &&L_OP_ADDI,
                                                    &&L_OP_SUBI,
                                                    &&L_OP_MULI,
                                                    &&L_OP_MODI,
                                                    &&L_OP_POWI,
                                                    &&L_OP_DIVI,
                                                    &&L_OP_IDIVI,
                                                    &&L_OP_ADDK,
                                                    &&L_OP_SUBK,
                                                    &&L_OP_MULK,
                                                    &&L_OP_MODK,
                                                    &&L_OP_POWK,
                                                    &&L_OP_DIVK,
                                                    &&L_OP_IDIVK,
                                                    &&L_OP_BANDK,
                                                    &&L_OP_BORK,
                                                    &&L_OP_BXORK,
                                                    &&L_OP_SHRI,
                                                    &&L_OP_SHLI,
                                                    &&L_OP_ADD,
                                                    &&L_OP_SUB,
                                                    &&L_OP_MUL,
                                                    &&L_OP_MOD,
                                                    &&L_OP_POW,
                                                    &&L_OP_DIV,
                                                    &&L_OP_IDIV,
                                                    &&L_OP_BAND,
                                                    &&L_OP_BOR,
                                                    &&L_OP_BXOR,
                                                    &&L_OP_SHL,
                                                    &&L_OP_SHR,
                                                    &&L_OP_UNM,
                                                    &&L_OP_BNOT,
                                                    &&L_OP_NOT,
                                                    &&L_OP_LEN,
                                                    &&L_OP_CONCAT,
                                                    &&L_OP_CLOSE,
                                                    &&L_OP_TBC,
                                                    &&L_OP_JMP,
                                                    &&L_OP_EQ,
                                                    &&L_OP_LT,
                                                    &&L_OP_LE,
                                                    &&L_OP_EQK,
                                                    &&L_OP_EQI,
                                                    &&L_OP_LTI,
                                                    &&L_OP_LEI,
                                                    &&L_OP_GTI,
                                                    &&L_OP_GEI,
                                                    &&L_OP_TEST,
                                                    &&L_OP_TESTSET,
                                                    &&L_OP_CALL,
                                                    &&L_OP_TAILCALL,
                                                    &&L_OP_RETURN,
                                                    &&L_OP_RETURN0,
                                                    &&L_OP_RETURN1,
                                                    &&L_OP_FORLOOP,
                                                    &&L_OP_FORPREP,
                                                    &&L_OP_TFORPREP,
                                                    &&L_OP_TFORCALL,
                                                    &&L_OP_TFORLOOP,
                                                    &&L_OP_SETLIST,
                                                    &&L_OP_CLOSURE,
                                                    &&L_OP_VARARG,
                                                    &&L_OP_VARARGPREP,
                                                    &&L_OP_EXTRAARG

  };

tailcall:
  trap = L->hookmask;
  cl = ((&((((union GCUnion *)(((((&(ci->func)->val))->value_).gc))))->cl.l)));
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  if (trap) {
    if (cl->p->is_vararg)
      trap = 0; /* hooks will start after VARARGPREP instruction */
    else if (pc == cl->p->code) /* first instruction (not resuming)? */
      luaD_hookcall(L, ci);
    ci->u.l.trap = 1; /* there may be other hooks */
  }
  base = ci->func + 1;
  /* main loop of interpreter */
  for (;;) {
    Instruction i; /* instruction being executed */
    StkId ra;      /* instruction's A register */
    {
      if (trap) {                     /* stack reallocation or hooks? */
        trap = luaG_traceexec(L, pc); /* handle hooks */
        (base = ci->func + 1);        /* correct stack */
      }
      i = *(pc++);
      ra = (base + (((int)((((i) >> ((0 + 7))) &
                            ((~((~(Instruction)0) << (8)))
                             << (0))))))); /* WARNING: any stack reallocation
                                              invalidates 'ra' */
    };
    ((void)0);
    ((void)0);
    ((void)0);
    goto *disptab[(
        ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
    {
    L_OP_MOVE : {
      {
        TValue *io1 = ((&(ra)->val));
        const TValue *io2 =
            ((&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                  ((~((~(Instruction)0) << (8))) << (0)))))))))
                   ->val));
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_LOADK : {
      TValue *rb =
          k + ((((int)((((i) >> (((0 + 7) + 8))) &
                        ((~((~(Instruction)0) << ((8 + 8 + 1)))) << (0)))))));
      {
        TValue *io1 = ((&(ra)->val));
        const TValue *io2 = (rb);
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_LOADI : {
      lua_Integer b =
          ((((int)((((i) >> (((0 + 7) + 8))) &
                    ((~((~(Instruction)0) << ((8 + 8 + 1)))) << (0)))))) -
           (((1 << (8 + 8 + 1)) - 1) >> 1) /* 'sBx' is signed */);
      {
        TValue *io = ((&(ra)->val));
        ((io)->value_).i = (b);
        ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_LOADF : {
      int b = ((((int)((((i) >> (((0 + 7) + 8))) &
                        ((~((~(Instruction)0) << ((8 + 8 + 1)))) << (0)))))) -
               (((1 << (8 + 8 + 1)) - 1) >> 1) /* 'sBx' is signed */);
      {
        TValue *io = ((&(ra)->val));
        ((io)->value_).n = (((lua_Number)((b))));
        ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_LOADKX : {
      TValue *rb;
      rb =
          k +
          ((((int)((((*pc) >> ((0 + 7))) &
                    ((~((~(Instruction)0) << (((8 + 8 + 1) + 8)))) << (0)))))));
      pc++;
      {
        TValue *io1 = ((&(ra)->val));
        const TValue *io2 = (rb);
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_LOADBOOL : {
      {
        TValue *io = ((&(ra)->val));
        ((io)->value_).b =
            (((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                       ((~((~(Instruction)0) << (8))) << (0))))))));
        ((io)->tt_ = (1));
      };
      if (((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                    ((~((~(Instruction)0) << (8))) << (0))))))))
        pc++; /* skip next instruction (if C) */
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_LOADNIL : {
      int b = ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                        ((~((~(Instruction)0) << (8))) << (0)))))));
      do {
        (((&(ra++)->val))->tt_ = (0));
      } while (b--);
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_GETUPVAL : {
      int b = ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                        ((~((~(Instruction)0) << (8))) << (0)))))));
      {
        TValue *io1 = ((&(ra)->val));
        const TValue *io2 = (cl->upvals[b]->v);
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SETUPVAL : {
      UpVal *uv =
          cl->upvals[((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))];
      {
        TValue *io1 = (uv->v);
        const TValue *io2 = ((&(ra)->val));
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      ((((((&(ra)->val))->tt_) & (1 << 6)) &&
        (((uv)->marked) & ((1 << (5 /* object is black */)))) &&
        (((((((&(ra)->val))->value_).gc))->marked) &
         (((1 << (3 /* object is white (type 0) */)) |
           (1 << (4 /* object is white (type 1) */))))))
           ? luaC_barrier_(L, (&(((union GCUnion *)((uv)))->gc)),
                           ((((&(ra)->val))->value_).gc))
           : ((void)((0))));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_GETTABUP : {
      const TValue *slot;
      TValue *upval =
          cl->upvals[((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))]
              ->v;
      TValue *rc = (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                  ((~((~(Instruction)0) << (8))) << (0))))))));
      TString *key = ((&((((union GCUnion *)((((rc)->value_).gc))))
                             ->ts))); /* key must be a string */
      if ((!((((upval))->tt_) == (((5) | (1 << 6))))
               ? (slot = ((void *)0),
                  0) /* not a table; 'slot' is NULL and result is 0 */
               : (slot = luaH_getshortstr(
                      ((&((((union GCUnion *)((((upval)->value_).gc))))->h))),
                      key),
                  /* else, do raw access */ !(((((((slot))->tt_)) & 0x0F)) ==
                                              (0)))) /* result not empty? */) {
        {
          TValue *io1 = ((&(ra)->val));
          const TValue *io2 = (slot);
          io1->value_ = io2->value_;
          io1->tt_ = io2->tt_;
          (void)L;
          ((void)0);
          ((void)0);
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaV_finishget(L, upval, rc, ra, slot)), (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_GETTABLE : {
      const TValue *slot;
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      TValue *rc =
          (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      lua_Unsigned n;
      if (((((rc))->tt_) ==
           ((3 |
             (2 << 4)) /* integer numbers */)) /* fast track for integers? */
              ? (n = (((rc)->value_).i),
                 (!((((rb))->tt_) == (((5) | (1 << 6))))
                      ? (slot = ((void *)0),
                         0) /* not a table; 'slot' is NULL and result is 0 */
                      : (slot = (((lua_Unsigned)(n)) - 1u <
                                 ((&((((union GCUnion *)((((rb)->value_).gc))))
                                         ->h)))
                                     ->alimit)
                                    ? &((&((((union GCUnion *)((
                                                ((rb)->value_).gc))))
                                               ->h)))
                                           ->array[n - 1]
                                    : luaH_getint(((&((((union GCUnion *)((
                                                           ((rb)->value_).gc))))
                                                          ->h))),
                                                  n),
                         !(((((((slot))->tt_)) & 0x0F)) ==
                           (0)))) /* result not empty? */)
              : (!((((rb))->tt_) == (((5) | (1 << 6))))
                     ? (slot = ((void *)0),
                        0) /* not a table; 'slot' is NULL and result is 0 */
                     : (slot = luaH_get(
                            ((&((((union GCUnion *)((((rb)->value_).gc))))
                                    ->h))),
                            rc),
                        /* else, do raw access */ !(
                            ((((((slot))->tt_)) & 0x0F)) ==
                            (0)))) /* result not empty? */) {
        {
          TValue *io1 = ((&(ra)->val));
          const TValue *io2 = (slot);
          io1->value_ = io2->value_;
          io1->tt_ = io2->tt_;
          (void)L;
          ((void)0);
          ((void)0);
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaV_finishget(L, rb, rc, ra, slot)), (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_GETI : {
      const TValue *slot;
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      int c = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                        ((~((~(Instruction)0) << (8))) << (0)))))));
      if ((!((((rb))->tt_) == (((5) | (1 << 6))))
               ? (slot = ((void *)0),
                  0) /* not a table; 'slot' is NULL and result is 0 */
               : (slot =
                      (((lua_Unsigned)(c)) - 1u <
                       ((&((((union GCUnion *)((((rb)->value_).gc))))->h)))
                           ->alimit)
                          ? &((&((((union GCUnion *)((((rb)->value_).gc))))
                                     ->h)))
                                 ->array[c - 1]
                          : luaH_getint(
                                ((&((((union GCUnion *)((((rb)->value_).gc))))
                                        ->h))),
                                c),
                  !(((((((slot))->tt_)) & 0x0F)) ==
                    (0)))) /* result not empty? */) {
        {
          TValue *io1 = ((&(ra)->val));
          const TValue *io2 = (slot);
          io1->value_ = io2->value_;
          io1->tt_ = io2->tt_;
          (void)L;
          ((void)0);
          ((void)0);
        };
      } else {
        TValue key;
        {
          TValue *io = (&key);
          ((io)->value_).i = (c);
          ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
        };
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaV_finishget(L, rb, &key, ra, slot)), (trap = ci->u.l.trap));
      }
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_GETFIELD : {
      const TValue *slot;
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      TValue *rc = (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                  ((~((~(Instruction)0) << (8))) << (0))))))));
      TString *key = ((&((((union GCUnion *)((((rc)->value_).gc))))
                             ->ts))); /* key must be a string */
      if ((!((((rb))->tt_) == (((5) | (1 << 6))))
               ? (slot = ((void *)0),
                  0) /* not a table; 'slot' is NULL and result is 0 */
               : (slot = luaH_getshortstr(
                      ((&((((union GCUnion *)((((rb)->value_).gc))))->h))),
                      key),
                  /* else, do raw access */ !(((((((slot))->tt_)) & 0x0F)) ==
                                              (0)))) /* result not empty? */) {
        {
          TValue *io1 = ((&(ra)->val));
          const TValue *io2 = (slot);
          io1->value_ = io2->value_;
          io1->tt_ = io2->tt_;
          (void)L;
          ((void)0);
          ((void)0);
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaV_finishget(L, rb, rc, ra, slot)), (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SETTABUP : {
      const TValue *slot;
      TValue *upval =
          cl->upvals[(((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8))) << (0))))))]
              ->v;
      TValue *rb = (k + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                  ((~((~(Instruction)0) << (8))) << (0))))))));
      TValue *rc =
          (((((int)((((i) & (1u << ((0 + 7) + 8))))))))
               ? k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))
               : (&(base +
                    ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                              ((~((~(Instruction)0) << (8))) << (0))))))))
                       ->val));
      TString *key = ((&((((union GCUnion *)((((rb)->value_).gc))))
                             ->ts))); /* key must be a string */
      if ((!((((upval))->tt_) == (((5) | (1 << 6))))
               ? (slot = ((void *)0),
                  0) /* not a table; 'slot' is NULL and result is 0 */
               : (slot = luaH_getshortstr(
                      ((&((((union GCUnion *)((((upval)->value_).gc))))->h))),
                      key),
                  /* else, do raw access */ !(((((((slot))->tt_)) & 0x0F)) ==
                                              (0)))) /* result not empty? */) {
        {
          {
            TValue *io1 = (((TValue *)(slot)));
            const TValue *io2 = (rc);
            io1->value_ = io2->value_;
            io1->tt_ = io2->tt_;
            (void)L;
            ((void)0);
            ((void)0);
          };
          (((((rc)->tt_) & (1 << 6)) &&
            ((((((upval)->value_).gc))->marked) &
             ((1 << (5 /* object is black */)))) &&
            ((((((rc)->value_).gc))->marked) &
             (((1 << (3 /* object is white (type 0) */)) |
               (1 << (4 /* object is white (type 1) */))))))
               ? luaC_barrierback_(L, (((upval)->value_).gc))
               : ((void)((0))));
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaV_finishset(L, upval, rb, rc, slot)), (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SETTABLE : {
      const TValue *slot;
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val); /* key (table is in 'ra') */
      TValue *rc =
          (((((int)((((i) & (1u << ((0 + 7) + 8))))))))
               ? k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))
               : (&(base +
                    ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                              ((~((~(Instruction)0) << (8))) << (0))))))))
                       ->val)); /* value */
      lua_Unsigned n;
      if (((((rb))->tt_) ==
           ((3 |
             (2 << 4)) /* integer numbers */)) /* fast track for integers? */
              ? (n = (((rb)->value_).i),
                 (!(((((&(ra)->val)))->tt_) == (((5) | (1 << 6))))
                      ? (slot = ((void *)0),
                         0) /* not a table; 'slot' is NULL and result is 0 */
                      : (slot =
                             (((lua_Unsigned)(n)) - 1u <
                              ((&((((union GCUnion *)((
                                       (((&(ra)->val))->value_).gc))))
                                      ->h)))
                                  ->alimit)
                                 ? &((&((((union GCUnion *)((
                                             (((&(ra)->val))->value_).gc))))
                                            ->h)))
                                        ->array[n - 1]
                                 : luaH_getint(
                                       ((&((((union GCUnion *)((
                                                (((&(ra)->val))->value_).gc))))
                                               ->h))),
                                       n),
                         !(((((((slot))->tt_)) & 0x0F)) ==
                           (0)))) /* result not empty? */)
              : (!(((((&(ra)->val)))->tt_) == (((5) | (1 << 6))))
                     ? (slot = ((void *)0),
                        0) /* not a table; 'slot' is NULL and result is 0 */
                     : (slot = luaH_get(((&((((union GCUnion *)((
                                                 (((&(ra)->val))->value_).gc))))
                                                ->h))),
                                        rb),
                        /* else, do raw access */ !(
                            ((((((slot))->tt_)) & 0x0F)) ==
                            (0)))) /* result not empty? */) {
        {
          {
            TValue *io1 = (((TValue *)(slot)));
            const TValue *io2 = (rc);
            io1->value_ = io2->value_;
            io1->tt_ = io2->tt_;
            (void)L;
            ((void)0);
            ((void)0);
          };
          (((((rc)->tt_) & (1 << 6)) &&
            (((((((&(ra)->val))->value_).gc))->marked) &
             ((1 << (5 /* object is black */)))) &&
            ((((((rc)->value_).gc))->marked) &
             (((1 << (3 /* object is white (type 0) */)) |
               (1 << (4 /* object is white (type 1) */))))))
               ? luaC_barrierback_(L, ((((&(ra)->val))->value_).gc))
               : ((void)((0))));
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaV_finishset(L, (&(ra)->val), rb, rc, slot)),
         (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SETI : {
      const TValue *slot;
      int c = ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                        ((~((~(Instruction)0) << (8))) << (0)))))));
      TValue *rc =
          (((((int)((((i) & (1u << ((0 + 7) + 8))))))))
               ? k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))
               : (&(base +
                    ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                              ((~((~(Instruction)0) << (8))) << (0))))))))
                       ->val));
      if ((!(((((&(ra)->val)))->tt_) == (((5) | (1 << 6))))
               ? (slot = ((void *)0),
                  0) /* not a table; 'slot' is NULL and result is 0 */
               : (slot =
                      (((lua_Unsigned)(c)) - 1u <
                       ((&((((union GCUnion *)(((((&(ra)->val))->value_).gc))))
                               ->h)))
                           ->alimit)
                          ? &((&((((union GCUnion *)((
                                      (((&(ra)->val))->value_).gc))))
                                     ->h)))
                                 ->array[c - 1]
                          : luaH_getint(((&((((union GCUnion *)((
                                                 (((&(ra)->val))->value_).gc))))
                                                ->h))),
                                        c),
                  !(((((((slot))->tt_)) & 0x0F)) ==
                    (0)))) /* result not empty? */) {
        {
          {
            TValue *io1 = (((TValue *)(slot)));
            const TValue *io2 = (rc);
            io1->value_ = io2->value_;
            io1->tt_ = io2->tt_;
            (void)L;
            ((void)0);
            ((void)0);
          };
          (((((rc)->tt_) & (1 << 6)) &&
            (((((((&(ra)->val))->value_).gc))->marked) &
             ((1 << (5 /* object is black */)))) &&
            ((((((rc)->value_).gc))->marked) &
             (((1 << (3 /* object is white (type 0) */)) |
               (1 << (4 /* object is white (type 1) */))))))
               ? luaC_barrierback_(L, ((((&(ra)->val))->value_).gc))
               : ((void)((0))));
        };
      } else {
        TValue key;
        {
          TValue *io = (&key);
          ((io)->value_).i = (c);
          ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
        };
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaV_finishset(L, (&(ra)->val), &key, rc, slot)),
         (trap = ci->u.l.trap));
      }
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SETFIELD : {
      const TValue *slot;
      TValue *rb = (k + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                  ((~((~(Instruction)0) << (8))) << (0))))))));
      TValue *rc =
          (((((int)((((i) & (1u << ((0 + 7) + 8))))))))
               ? k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))
               : (&(base +
                    ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                              ((~((~(Instruction)0) << (8))) << (0))))))))
                       ->val));
      TString *key = ((&((((union GCUnion *)((((rb)->value_).gc))))
                             ->ts))); /* key must be a string */
      if ((!(((((&(ra)->val)))->tt_) == (((5) | (1 << 6))))
               ? (slot = ((void *)0),
                  0) /* not a table; 'slot' is NULL and result is 0 */
               : (slot = luaH_getshortstr(
                      ((&((((union GCUnion *)(((((&(ra)->val))->value_).gc))))
                              ->h))),
                      key),
                  /* else, do raw access */ !(((((((slot))->tt_)) & 0x0F)) ==
                                              (0)))) /* result not empty? */) {
        {
          {
            TValue *io1 = (((TValue *)(slot)));
            const TValue *io2 = (rc);
            io1->value_ = io2->value_;
            io1->tt_ = io2->tt_;
            (void)L;
            ((void)0);
            ((void)0);
          };
          (((((rc)->tt_) & (1 << 6)) &&
            (((((((&(ra)->val))->value_).gc))->marked) &
             ((1 << (5 /* object is black */)))) &&
            ((((((rc)->value_).gc))->marked) &
             (((1 << (3 /* object is white (type 0) */)) |
               (1 << (4 /* object is white (type 1) */))))))
               ? luaC_barrierback_(L, ((((&(ra)->val))->value_).gc))
               : ((void)((0))));
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaV_finishset(L, (&(ra)->val), rb, rc, slot)),
         (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_NEWTABLE : {
      int b = ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                        ((~((~(Instruction)0) << (8))) << (0)))))));
      int c = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                        ((~((~(Instruction)0) << (8))) << (0)))))));
      Table *t;
      L->top = ci->top; /* correct top in case of GC */
      t = luaH_new(L);  /* memory allocation */
      {
        TValue *io = ((&(ra)->val));
        Table *x_ = (t);
        ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
        ((io)->tt_ = (((5) | (1 << 6))));
        ((void)0);
      };
      if (b != 0 || c != 0)
        luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c)); /* idem */
      {
        {
          if ((L->l_G)->GCdebt > 0) {
            L->top = (ra + 1);
            luaC_step(L); /* limit of live values */
            (trap = ci->u.l.trap);
          };
          ((void)0);
        };
        {
          ((void)0);
          ((void)0);
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SELF : {
      const TValue *slot;
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      TValue *rc =
          (((((int)((((i) & (1u << ((0 + 7) + 8))))))))
               ? k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))
               : (&(base +
                    ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                              ((~((~(Instruction)0) << (8))) << (0))))))))
                       ->val));
      TString *key = ((&((((union GCUnion *)((((rc)->value_).gc))))
                             ->ts))); /* key must be a string */
      {
        TValue *io1 = ((&(ra + 1)->val));
        const TValue *io2 = (rb);
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      if ((!((((rb))->tt_) == (((5) | (1 << 6))))
               ? (slot = ((void *)0),
                  0) /* not a table; 'slot' is NULL and result is 0 */
               : (slot = luaH_getstr(
                      ((&((((union GCUnion *)((((rb)->value_).gc))))->h))),
                      key),
                  /* else, do raw access */ !(((((((slot))->tt_)) & 0x0F)) ==
                                              (0)))) /* result not empty? */) {
        {
          TValue *io1 = ((&(ra)->val));
          const TValue *io2 = (slot);
          io1->value_ = io2->value_;
          io1->tt_ = io2->tt_;
          (void)L;
          ((void)0);
          ((void)0);
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaV_finishget(L, rb, rc, ra, slot)), (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_ADDI : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        int imm = (((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                             ((~((~(Instruction)0) << (8))) << (0))))))) -
                   (((1 << 8) - 1) >> 1));
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i = (((lua_Integer)(
                ((lua_Unsigned)((((v1)->value_).i))) + ((lua_Unsigned)(imm)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number nb;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((nb) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((nb) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((nb) + (((lua_Number)((imm))))));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybiniTM(
                 L, v1, imm,
                 ((((int)((((i) >> (((0 + 7) + 8))) &
                           ((~((~(Instruction)0) << (1))) << (0))))))),
                 ra, TM_ADD)),
             (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SUBI : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        int imm = (((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                             ((~((~(Instruction)0) << (8))) << (0))))))) -
                   (((1 << 8) - 1) >> 1));
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i = (((lua_Integer)(
                ((lua_Unsigned)((((v1)->value_).i))) - ((lua_Unsigned)(imm)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number nb;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((nb) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((nb) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((nb) - (((lua_Number)((imm))))));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybiniTM(L, v1, imm, 0, ra, TM_SUB)),
             (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_MULI : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        int imm = (((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                             ((~((~(Instruction)0) << (8))) << (0))))))) -
                   (((1 << 8) - 1) >> 1));
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i = (((lua_Integer)(
                ((lua_Unsigned)((((v1)->value_).i))) * ((lua_Unsigned)(imm)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number nb;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((nb) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((nb) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((nb) * (((lua_Number)((imm))))));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybiniTM(
                 L, v1, imm,
                 ((((int)((((i) >> (((0 + 7) + 8))) &
                           ((~((~(Instruction)0) << (1))) << (0))))))),
                 ra, TM_MUL)),
             (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_MODI : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        int imm = (((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                             ((~((~(Instruction)0) << (8))) << (0))))))) -
                   (((1 << 8) - 1) >> 1));
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i = (luaV_mod(L, (((v1)->value_).i), imm));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number nb;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((nb) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((nb) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (luaV_modf(L, nb, ((lua_Number)((imm)))));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybiniTM(L, v1, imm, 0, ra, TM_MOD)),
             (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_POWI : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        int imm = (((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                             ((~((~(Instruction)0) << (8))) << (0))))))) -
                   (((1 << 8) - 1) >> 1));
        {
          lua_Number nb;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((nb) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((nb) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((void)L, pow(nb, ((lua_Number)((imm))))));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybiniTM(L, v1, imm, 0, ra, TM_POW)),
             (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_DIVI : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        int imm = (((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                             ((~((~(Instruction)0) << (8))) << (0))))))) -
                   (((1 << 8) - 1) >> 1));
        {
          lua_Number nb;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((nb) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((nb) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((nb) / (((lua_Number)((imm))))));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybiniTM(L, v1, imm, 0, ra, TM_DIV)),
             (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_IDIVI : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        int imm = (((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                             ((~((~(Instruction)0) << (8))) << (0))))))) -
                   (((1 << 8) - 1) >> 1));
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i = (luaV_idiv(L, (((v1)->value_).i), imm));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number nb;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((nb) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((nb) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n =
                  (((void)L, (floor(((nb) / (((lua_Number)((imm)))))))));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybiniTM(L, v1, imm, 0, ra, TM_IDIV)),
             (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_ADDK : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                           ((~((~(Instruction)0) << (8))) << (0))))))));
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          lua_Integer i1 = (((v1)->value_).i);
          lua_Integer i2 = (((v2)->value_).i);
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) + ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((n1) + (n2)));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinassocTM(
                 L, v1, v2, ra,
                 ((((int)((((i) >> (((0 + 7) + 8))) &
                           ((~((~(Instruction)0) << (1))) << (0))))))),
                 TM_ADD)),
             (trap = ci->u.l.trap));
        }
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SUBK : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                           ((~((~(Instruction)0) << (8))) << (0))))))));
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          lua_Integer i1 = (((v1)->value_).i);
          lua_Integer i2 = (((v2)->value_).i);
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) - ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((n1) - (n2)));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinassocTM(L, v1, v2, ra, 0, TM_SUB)),
             (trap = ci->u.l.trap));
        }
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_MULK : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                           ((~((~(Instruction)0) << (8))) << (0))))))));
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          lua_Integer i1 = (((v1)->value_).i);
          lua_Integer i2 = (((v2)->value_).i);
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) * ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((n1) * (n2)));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinassocTM(
                 L, v1, v2, ra,
                 ((((int)((((i) >> (((0 + 7) + 8))) &
                           ((~((~(Instruction)0) << (1))) << (0))))))),
                 TM_MUL)),
             (trap = ci->u.l.trap));
        }
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_MODK : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                           ((~((~(Instruction)0) << (8))) << (0))))))));
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          lua_Integer i1 = (((v1)->value_).i);
          lua_Integer i2 = (((v2)->value_).i);
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i = (luaV_mod(L, i1, i2));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (luaV_modf(L, n1, n2));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinassocTM(L, v1, v2, ra, 0, TM_MOD)),
             (trap = ci->u.l.trap));
        }
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_POWK : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                           ((~((~(Instruction)0) << (8))) << (0))))))));
        lua_Number n1;
        lua_Number n2;
        if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                 ? ((n1) = (((v1)->value_).n), 1)
                 : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                        ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                        : 0)) &&
            (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                 ? ((n2) = (((v2)->value_).n), 1)
                 : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                        ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                        : 0))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).n = (((void)L, pow(n1, n2)));
            ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
          };
        } else
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (luaT_trybinTM(L, v1, v2, ra, TM_POW)), (trap = ci->u.l.trap));
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_DIVK : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                           ((~((~(Instruction)0) << (8))) << (0))))))));
        lua_Number n1;
        lua_Number n2;
        if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                 ? ((n1) = (((v1)->value_).n), 1)
                 : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                        ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                        : 0)) &&
            (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                 ? ((n2) = (((v2)->value_).n), 1)
                 : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                        ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                        : 0))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).n = (((n1) / (n2)));
            ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
          };
        } else
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (luaT_trybinTM(L, v1, v2, ra, TM_DIV)), (trap = ci->u.l.trap));
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_IDIVK : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                           ((~((~(Instruction)0) << (8))) << (0))))))));
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          lua_Integer i1 = (((v1)->value_).i);
          lua_Integer i2 = (((v2)->value_).i);
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i = (luaV_idiv(L, i1, i2));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((void)L, (floor(((n1) / (n2))))));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinassocTM(L, v1, v2, ra, 0, TM_IDIV)),
             (trap = ci->u.l.trap));
        }
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_ADD : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          lua_Integer i1 = (((v1)->value_).i);
          lua_Integer i2 = (((v2)->value_).i);
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) + ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((n1) + (n2)));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinTM(L, v1, v2, ra, TM_ADD)), (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SUB : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          lua_Integer i1 = (((v1)->value_).i);
          lua_Integer i2 = (((v2)->value_).i);
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) - ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((n1) - (n2)));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinTM(L, v1, v2, ra, TM_SUB)), (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_MUL : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          lua_Integer i1 = (((v1)->value_).i);
          lua_Integer i2 = (((v2)->value_).i);
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) * ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((n1) * (n2)));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinTM(L, v1, v2, ra, TM_MUL)), (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_MOD : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          lua_Integer i1 = (((v1)->value_).i);
          lua_Integer i2 = (((v2)->value_).i);
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i = (luaV_mod(L, i1, i2));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (luaV_modf(L, n1, n2));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinTM(L, v1, v2, ra, TM_MOD)), (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_POW : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((void)L, pow(n1, n2)));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinTM(L, v1, v2, ra, TM_POW)), (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_DIV : { /* float division (always with floats) */
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((n1) / (n2)));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinTM(L, v1, v2, ra, TM_DIV)), (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_IDIV : { /* floor division */
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        if (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
          lua_Integer i1 = (((v1)->value_).i);
          lua_Integer i2 = (((v2)->value_).i);
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i = (luaV_idiv(L, i1, i2));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else {
          lua_Number n1;
          lua_Number n2;
          if ((((((v1))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n1) = (((v1)->value_).n), 1)
                   : (((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n1) = ((lua_Number)(((((v1)->value_).i)))), 1)
                          : 0)) &&
              (((((v2))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? ((n2) = (((v2)->value_).n), 1)
                   : (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                          ? ((n2) = ((lua_Number)(((((v2)->value_).i)))), 1)
                          : 0))) {
            {
              TValue *io = ((&(ra)->val));
              ((io)->value_).n = (((void)L, (floor(((n1) / (n2))))));
              ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
            };
          } else
            (((ci->u.l.savedpc = pc), L->top = ci->top),
             (luaT_trybinTM(L, v1, v2, ra, TM_IDIV)), (trap = ci->u.l.trap));
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_BANDK : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                           ((~((~(Instruction)0) << (8))) << (0))))))));
        lua_Integer i1;
        lua_Integer i2 = (((v2)->value_).i);
        if ((((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                 ? (*(&i1) = (((v1)->value_).i), 1)
                 : luaV_tointegerns(v1, &i1, 0))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) & ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (luaT_trybiniTM(L, v1, i2,
                           (((int)((((i) & (1u << ((0 + 7) + 8))))))), ra,
                           TM_BAND)),
           (trap = ci->u.l.trap));
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_BORK : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                           ((~((~(Instruction)0) << (8))) << (0))))))));
        lua_Integer i1;
        lua_Integer i2 = (((v2)->value_).i);
        if ((((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                 ? (*(&i1) = (((v1)->value_).i), 1)
                 : luaV_tointegerns(v1, &i1, 0))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) | ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (luaT_trybiniTM(L, v1, i2,
                           (((int)((((i) & (1u << ((0 + 7) + 8))))))), ra,
                           TM_BOR)),
           (trap = ci->u.l.trap));
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_BXORK : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (k + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                           ((~((~(Instruction)0) << (8))) << (0))))))));
        lua_Integer i1;
        lua_Integer i2 = (((v2)->value_).i);
        if ((((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                 ? (*(&i1) = (((v1)->value_).i), 1)
                 : luaV_tointegerns(v1, &i1, 0))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) ^ ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (luaT_trybiniTM(L, v1, i2,
                           (((int)((((i) & (1u << ((0 + 7) + 8))))))), ra,
                           TM_BXOR)),
           (trap = ci->u.l.trap));
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_BAND : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        lua_Integer i1;
        lua_Integer i2;
        if ((((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                 ? (*(&i1) = (((v1)->value_).i), 1)
                 : luaV_tointegerns(v1, &i1, 0)) &&
            (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                 ? (*(&i2) = (((v2)->value_).i), 1)
                 : luaV_tointegerns(v2, &i2, 0))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) & ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (luaT_trybinTM(L, v1, v2, ra, TM_BAND)), (trap = ci->u.l.trap));
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_BOR : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        lua_Integer i1;
        lua_Integer i2;
        if ((((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                 ? (*(&i1) = (((v1)->value_).i), 1)
                 : luaV_tointegerns(v1, &i1, 0)) &&
            (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                 ? (*(&i2) = (((v2)->value_).i), 1)
                 : luaV_tointegerns(v2, &i2, 0))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) | ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (luaT_trybinTM(L, v1, v2, ra, TM_BOR)), (trap = ci->u.l.trap));
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_BXOR : {
      {
        TValue *v1 =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        TValue *v2 =
            (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        lua_Integer i1;
        lua_Integer i2;
        if ((((((v1))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                 ? (*(&i1) = (((v1)->value_).i), 1)
                 : luaV_tointegerns(v1, &i1, 0)) &&
            (((((v2))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                 ? (*(&i2) = (((v2)->value_).i), 1)
                 : luaV_tointegerns(v2, &i2, 0))) {
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).i =
                (((lua_Integer)(((lua_Unsigned)(i1)) ^ ((lua_Unsigned)(i2)))));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        } else
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (luaT_trybinTM(L, v1, v2, ra, TM_BXOR)), (trap = ci->u.l.trap));
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SHRI : {
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      int ic = (((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                          ((~((~(Instruction)0) << (8))) << (0))))))) -
                (((1 << 8) - 1) >> 1));
      lua_Integer ib;
      if ((((((rb))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
               ? (*(&ib) = (((rb)->value_).i), 1)
               : luaV_tointegerns(rb, &ib, 0))) {
        {
          TValue *io = ((&(ra)->val));
          ((io)->value_).i = (luaV_shiftl(ib, -ic));
          ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
        };
      } else {
        TMS ev = TM_SHR;
        if ((((int)((((i) & (1u << ((0 + 7) + 8)))))))) {
          ic = -ic;
          ev = TM_SHL;
        }
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaT_trybiniTM(L, rb, ic, 0, ra, ev)), (trap = ci->u.l.trap));
      }
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SHLI : {
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      int ic = (((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                          ((~((~(Instruction)0) << (8))) << (0))))))) -
                (((1 << 8) - 1) >> 1));
      lua_Integer ib;
      if ((((((rb))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
               ? (*(&ib) = (((rb)->value_).i), 1)
               : luaV_tointegerns(rb, &ib, 0))) {
        {
          TValue *io = ((&(ra)->val));
          ((io)->value_).i = (luaV_shiftl(ic, ib));
          ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaT_trybiniTM(L, rb, ic, 1, ra, TM_SHL)), (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SHR : {
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      TValue *rc =
          (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      lua_Integer ib;
      lua_Integer ic;
      if ((((((rb))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
               ? (*(&ib) = (((rb)->value_).i), 1)
               : luaV_tointegerns(rb, &ib, 0)) &&
          (((((rc))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
               ? (*(&ic) = (((rc)->value_).i), 1)
               : luaV_tointegerns(rc, &ic, 0))) {
        {
          TValue *io = ((&(ra)->val));
          ((io)->value_).i = (luaV_shiftl(ib, -ic));
          ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaT_trybinTM(L, rb, rc, ra, TM_SHR)), (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SHL : {
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      TValue *rc =
          (&((base + ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      lua_Integer ib;
      lua_Integer ic;
      if ((((((rb))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
               ? (*(&ib) = (((rb)->value_).i), 1)
               : luaV_tointegerns(rb, &ib, 0)) &&
          (((((rc))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
               ? (*(&ic) = (((rc)->value_).i), 1)
               : luaV_tointegerns(rc, &ic, 0))) {
        {
          TValue *io = ((&(ra)->val));
          ((io)->value_).i = (luaV_shiftl(ib, ic));
          ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaT_trybinTM(L, rb, rc, ra, TM_SHL)), (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_UNM : {
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      lua_Number nb;
      if (((((rb))->tt_) == ((3 | (2 << 4)) /* integer numbers */))) {
        lua_Integer ib = (((rb)->value_).i);
        {
          TValue *io = ((&(ra)->val));
          ((io)->value_).i =
              (((lua_Integer)(((lua_Unsigned)(0)) - ((lua_Unsigned)(ib)))));
          ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
        };
      } else if ((((((rb))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                      ? ((nb) = (((rb)->value_).n), 1)
                      : (((((rb))->tt_) ==
                          ((3 | (2 << 4)) /* integer numbers */))
                             ? ((nb) = ((lua_Number)(((((rb)->value_).i)))), 1)
                             : 0))) {
        {
          TValue *io = ((&(ra)->val));
          ((io)->value_).n = ((-(nb)));
          ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaT_trybinTM(L, rb, rb, ra, TM_UNM)), (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_BNOT : {
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      lua_Integer ib;
      if ((((((rb))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
               ? (*(&ib) = (((rb)->value_).i), 1)
               : luaV_tointegerns(rb, &ib, 0))) {
        {
          TValue *io = ((&(ra)->val));
          ((io)->value_).i = (((lua_Integer)(
              ((lua_Unsigned)(~((lua_Unsigned)(0)))) ^ ((lua_Unsigned)(ib)))));
          ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
        };
      } else
        (((ci->u.l.savedpc = pc), L->top = ci->top),
         (luaT_trybinTM(L, rb, rb, ra, TM_BNOT)), (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_NOT : {
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      int nrb = ((((((((rb))->tt_)) & 0x0F)) == (0)) ||
                 (((((rb))->tt_) == (1)) &&
                  (((rb)->value_).b) ==
                      0)); /* next assignment may change this value */
      {
        TValue *io = ((&(ra)->val));
        ((io)->value_).b = (nrb);
        ((io)->tt_ = (1));
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_LEN : {
      (((ci->u.l.savedpc = pc), L->top = ci->top),
       (luaV_objlen(
           L, ra,
           (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                ((~((~(Instruction)0) << (8))) << (0)))))))))
                 ->val))),
       (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_CONCAT : {
      int n = ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                        ((~((~(Instruction)0) << (8)))
                         << (0))))))); /* number of elements to concatenate */
      L->top = ra + n;                 /* mark the end of concat operands */
      ((ci->u.l.savedpc = pc), (luaV_concat(L, n)), (trap = ci->u.l.trap));
      {
        {
          if ((L->l_G)->GCdebt > 0) {
            L->top = (L->top);
            luaC_step(L); /* limit of live values */
            (trap = ci->u.l.trap);
          };
          ((void)0);
        };
        {
          ((void)0);
          ((void)0);
        };
      }; /* 'luaV_concat' ensures correct top */
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_CLOSE : {
      L->top = ra + 1; /* everything is free after this slot */
      (((ci->u.l.savedpc = pc), L->top = ci->top), (luaF_close(L, ra, 0)),
       (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_TBC : {
      /* create new to-be-closed upvalue */
      ((ci->u.l.savedpc = pc), (luaF_newtbcupval(L, ra)));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_JMP : {
      {
        pc += ((((int)((
                   ((i) >> ((0 + 7))) &
                   ((~((~(Instruction)0) << (((8 + 8 + 1) + 8)))) << (0)))))) -
               (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
              0;
        (trap = ci->u.l.trap);
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_EQ : {
      int cond;
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      (((ci->u.l.savedpc = pc), L->top = ci->top),
       (cond = luaV_equalobj(L, (&(ra)->val), rb)), (trap = ci->u.l.trap));
      if (cond != ((((int)((((i) >> (((0 + 7) + 8))) &
                            ((~((~(Instruction)0) << (1))) << (0))))))))
        pc++;
      else {
        i = *pc;
        {
          pc += ((((int)((((i) >> ((0 + 7))) &
                          ((~((~(Instruction)0) << (((8 + 8 + 1) + 8))))
                           << (0)))))) -
                 (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
                1;
          (trap = ci->u.l.trap);
        };
      };
      ;
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_LT : {
      {
        int cond;
        TValue *rb =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        if ((((((&(ra)->val)))->tt_) ==
             ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((rb))->tt_) == ((3 | (2 << 4)) /* integer numbers */)))
          cond = (((((&(ra)->val))->value_).i) < (((rb)->value_).i));
        else if (((((((((&(ra)->val)))->tt_)) & 0x0F)) == (3)) &&
                 (((((((rb))->tt_)) & 0x0F)) == (3)))
          cond = LTnum((&(ra)->val), rb);
        else
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (cond = lessthanothers(L, (&(ra)->val), rb)), (trap = ci->u.l.trap));
        if (cond != ((((int)((((i) >> (((0 + 7) + 8))) &
                              ((~((~(Instruction)0) << (1))) << (0))))))))
          pc++;
        else {
          i = *pc;
          {
            pc += ((((int)((((i) >> ((0 + 7))) &
                            ((~((~(Instruction)0) << (((8 + 8 + 1) + 8))))
                             << (0)))))) -
                   (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
                  1;
            (trap = ci->u.l.trap);
          };
        };
        ;
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_LE : {
      {
        int cond;
        TValue *rb =
            (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))))))
                  ->val);
        if ((((((&(ra)->val)))->tt_) ==
             ((3 | (2 << 4)) /* integer numbers */)) &&
            ((((rb))->tt_) == ((3 | (2 << 4)) /* integer numbers */)))
          cond = (((((&(ra)->val))->value_).i) <= (((rb)->value_).i));
        else if (((((((((&(ra)->val)))->tt_)) & 0x0F)) == (3)) &&
                 (((((((rb))->tt_)) & 0x0F)) == (3)))
          cond = LEnum((&(ra)->val), rb);
        else
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (cond = lessequalothers(L, (&(ra)->val), rb)),
           (trap = ci->u.l.trap));
        if (cond != ((((int)((((i) >> (((0 + 7) + 8))) &
                              ((~((~(Instruction)0) << (1))) << (0))))))))
          pc++;
        else {
          i = *pc;
          {
            pc += ((((int)((((i) >> ((0 + 7))) &
                            ((~((~(Instruction)0) << (((8 + 8 + 1) + 8))))
                             << (0)))))) -
                   (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
                  1;
            (trap = ci->u.l.trap);
          };
        };
        ;
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_EQK : {
      TValue *rb = (k + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                                  ((~((~(Instruction)0) << (8))) << (0))))))));
      /* basic types do not use '__eq'; we can use raw equality */
      int cond = luaV_equalobj(((void *)0), (&(ra)->val), rb);
      if (cond != ((((int)((((i) >> (((0 + 7) + 8))) &
                            ((~((~(Instruction)0) << (1))) << (0))))))))
        pc++;
      else {
        i = *pc;
        {
          pc += ((((int)((((i) >> ((0 + 7))) &
                          ((~((~(Instruction)0) << (((8 + 8 + 1) + 8))))
                           << (0)))))) -
                 (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
                1;
          (trap = ci->u.l.trap);
        };
      };
      ;
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_EQI : {
      int cond;
      int im = (((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                          ((~((~(Instruction)0) << (8))) << (0))))))) -
                (((1 << 8) - 1) >> 1));
      if ((((((&(ra)->val)))->tt_) == ((3 | (2 << 4)) /* integer numbers */)))
        cond = (((((&(ra)->val))->value_).i) == im);
      else if ((((((&(ra)->val)))->tt_) ==
                ((3 | (1 << 4)) /* float numbers */)))
        cond = ((((((&(ra)->val))->value_).n)) == (((lua_Number)((im)))));
      else
        cond = 0; /* other types cannot be equal to a number */
      if (cond != ((((int)((((i) >> (((0 + 7) + 8))) &
                            ((~((~(Instruction)0) << (1))) << (0))))))))
        pc++;
      else {
        i = *pc;
        {
          pc += ((((int)((((i) >> ((0 + 7))) &
                          ((~((~(Instruction)0) << (((8 + 8 + 1) + 8))))
                           << (0)))))) -
                 (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
                1;
          (trap = ci->u.l.trap);
        };
      };
      ;
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_LTI : {
      {
        int cond;
        int im = (((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                            ((~((~(Instruction)0) << (8))) << (0))))))) -
                  (((1 << 8) - 1) >> 1));
        if ((((((&(ra)->val)))->tt_) == ((3 | (2 << 4)) /* integer numbers */)))
          cond = (((((&(ra)->val))->value_).i) < im);
        else if ((((((&(ra)->val)))->tt_) ==
                  ((3 | (1 << 4)) /* float numbers */)))
          cond = ((((((&(ra)->val))->value_).n)) < (((lua_Number)((im)))));
        else {
          int isf = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                              ((~((~(Instruction)0) << (8))) << (0)))))));
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (cond = luaT_callorderiTM(L, (&(ra)->val), im, 0, isf, TM_LT)),
           (trap = ci->u.l.trap));
        }
        if (cond != ((((int)((((i) >> (((0 + 7) + 8))) &
                              ((~((~(Instruction)0) << (1))) << (0))))))))
          pc++;
        else {
          i = *pc;
          {
            pc += ((((int)((((i) >> ((0 + 7))) &
                            ((~((~(Instruction)0) << (((8 + 8 + 1) + 8))))
                             << (0)))))) -
                   (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
                  1;
            (trap = ci->u.l.trap);
          };
        };
        ;
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_LEI : {
      {
        int cond;
        int im = (((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                            ((~((~(Instruction)0) << (8))) << (0))))))) -
                  (((1 << 8) - 1) >> 1));
        if ((((((&(ra)->val)))->tt_) == ((3 | (2 << 4)) /* integer numbers */)))
          cond = (((((&(ra)->val))->value_).i) <= im);
        else if ((((((&(ra)->val)))->tt_) ==
                  ((3 | (1 << 4)) /* float numbers */)))
          cond = ((((((&(ra)->val))->value_).n)) <= (((lua_Number)((im)))));
        else {
          int isf = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                              ((~((~(Instruction)0) << (8))) << (0)))))));
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (cond = luaT_callorderiTM(L, (&(ra)->val), im, 0, isf, TM_LE)),
           (trap = ci->u.l.trap));
        }
        if (cond != ((((int)((((i) >> (((0 + 7) + 8))) &
                              ((~((~(Instruction)0) << (1))) << (0))))))))
          pc++;
        else {
          i = *pc;
          {
            pc += ((((int)((((i) >> ((0 + 7))) &
                            ((~((~(Instruction)0) << (((8 + 8 + 1) + 8))))
                             << (0)))))) -
                   (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
                  1;
            (trap = ci->u.l.trap);
          };
        };
        ;
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_GTI : {
      {
        int cond;
        int im = (((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                            ((~((~(Instruction)0) << (8))) << (0))))))) -
                  (((1 << 8) - 1) >> 1));
        if ((((((&(ra)->val)))->tt_) == ((3 | (2 << 4)) /* integer numbers */)))
          cond = (((((&(ra)->val))->value_).i) > im);
        else if ((((((&(ra)->val)))->tt_) ==
                  ((3 | (1 << 4)) /* float numbers */)))
          cond = ((((((&(ra)->val))->value_).n)) > (((lua_Number)((im)))));
        else {
          int isf = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                              ((~((~(Instruction)0) << (8))) << (0)))))));
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (cond = luaT_callorderiTM(L, (&(ra)->val), im, 1, isf, TM_LT)),
           (trap = ci->u.l.trap));
        }
        if (cond != ((((int)((((i) >> (((0 + 7) + 8))) &
                              ((~((~(Instruction)0) << (1))) << (0))))))))
          pc++;
        else {
          i = *pc;
          {
            pc += ((((int)((((i) >> ((0 + 7))) &
                            ((~((~(Instruction)0) << (((8 + 8 + 1) + 8))))
                             << (0)))))) -
                   (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
                  1;
            (trap = ci->u.l.trap);
          };
        };
        ;
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_GEI : {
      {
        int cond;
        int im = (((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                            ((~((~(Instruction)0) << (8))) << (0))))))) -
                  (((1 << 8) - 1) >> 1));
        if ((((((&(ra)->val)))->tt_) == ((3 | (2 << 4)) /* integer numbers */)))
          cond = (((((&(ra)->val))->value_).i) >= im);
        else if ((((((&(ra)->val)))->tt_) ==
                  ((3 | (1 << 4)) /* float numbers */)))
          cond = ((((((&(ra)->val))->value_).n)) >= (((lua_Number)((im)))));
        else {
          int isf = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                              ((~((~(Instruction)0) << (8))) << (0)))))));
          (((ci->u.l.savedpc = pc), L->top = ci->top),
           (cond = luaT_callorderiTM(L, (&(ra)->val), im, 1, isf, TM_LE)),
           (trap = ci->u.l.trap));
        }
        if (cond != ((((int)((((i) >> (((0 + 7) + 8))) &
                              ((~((~(Instruction)0) << (1))) << (0))))))))
          pc++;
        else {
          i = *pc;
          {
            pc += ((((int)((((i) >> ((0 + 7))) &
                            ((~((~(Instruction)0) << (((8 + 8 + 1) + 8))))
                             << (0)))))) -
                   (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
                  1;
            (trap = ci->u.l.trap);
          };
        };
        ;
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_TEST : {
      int cond = !(((((((((&(ra)->val)))->tt_)) & 0x0F)) == (0)) ||
                   ((((((&(ra)->val)))->tt_) == (1)) &&
                    ((((&(ra)->val))->value_).b) == 0));
      if (cond != ((((int)((((i) >> (((0 + 7) + 8))) &
                            ((~((~(Instruction)0) << (1))) << (0))))))))
        pc++;
      else {
        i = *pc;
        {
          pc += ((((int)((((i) >> ((0 + 7))) &
                          ((~((~(Instruction)0) << (((8 + 8 + 1) + 8))))
                           << (0)))))) -
                 (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
                1;
          (trap = ci->u.l.trap);
        };
      };
      ;
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_TESTSET : {
      TValue *rb =
          (&((base + ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                               ((~((~(Instruction)0) << (8))) << (0)))))))))
                ->val);
      if (((((((((rb))->tt_)) & 0x0F)) == (0)) ||
           (((((rb))->tt_) == (1)) && (((rb)->value_).b) == 0)) ==
          ((((int)((((i) >> (((0 + 7) + 8))) &
                    ((~((~(Instruction)0) << (1))) << (0))))))))
        pc++;
      else {
        {
          TValue *io1 = ((&(ra)->val));
          const TValue *io2 = (rb);
          io1->value_ = io2->value_;
          io1->tt_ = io2->tt_;
          (void)L;
          ((void)0);
          ((void)0);
        };
        {
          i = *pc;
          {
            pc += ((((int)((((i) >> ((0 + 7))) &
                            ((~((~(Instruction)0) << (((8 + 8 + 1) + 8))))
                             << (0)))))) -
                   (((1 << ((8 + 8 + 1) + 8)) - 1) >> 1)) +
                  1;
            (trap = ci->u.l.trap);
          };
        };
      }
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_CALL : {
      int b = ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                        ((~((~(Instruction)0) << (8))) << (0)))))));
      int nresults = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                               ((~((~(Instruction)0) << (8))) << (0))))))) -
                     1;
      if (b != 0)        /* fixed number of arguments? */
        L->top = ra + b; /* top signals number of arguments */
      /* else previous instruction set top */
      ((ci->u.l.savedpc = pc), (luaD_call(L, ra, nresults)),
       (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_TAILCALL : {
      int b = ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                        ((~((~(Instruction)0) << (8)))
                         << (0))))))); /* number of arguments + 1 (function) */
      int delta = 0; /* virtual 'func' - real 'func' (vararg functions) */
      if (b != 0)
        L->top = ra + b;
      else /* previous instruction set top */
        b = ((int)((L->top - ra)));
      (ci->u.l.savedpc = pc); /* some calls here can raise errors */
      if ((((int)((((i) & (1u << ((0 + 7) + 8)))))))) {
        int nparams1 = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))));
        if (nparams1) /* vararg function? */
          delta = ci->u.l.nextraargs + nparams1;
        /* close upvalues from current call; the compiler ensures
           that there are no to-be-closed variables here */
        luaF_close(L, base, (-1));
      }
      if (!(((((((&(ra)->val))->tt_)) & 0x0F)) == (6))) { /* not a function? */
        luaD_tryfuncTM(L, ra); /* try '__call' metamethod */
        b++;                   /* there is now one extra argument */
      }
      if (!(((((&(ra)->val)))->tt_) == ((((6 | (1 << 4)) /* Lua closure */) |
                                         (1 << 6))))) { /* C function? */
        luaD_call(L, ra, (-1));                         /* call it */
        (trap = ci->u.l.trap);
        {
          if (trap) {
            (base = ci->func + 1);
            ra = (base + (((int)((((i) >> ((0 + 7))) &
                                  ((~((~(Instruction)0) << (8))) << (0)))))));
          }
        }; /* stack may have been relocated */
        ci->func -= delta;
        luaD_poscall(L, ci, ((int)((L->top - ra))));
        return;
      } else { /* Lua tail call */
        ci->func -= delta;
        luaD_pretailcall(L, ci, ra, b); /* prepare call frame */
        goto tailcall;
      }
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_RETURN : {
      int n = ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                        ((~((~(Instruction)0) << (8))) << (0))))))) -
              1;                    /* number of results */
      if (n < 0)                    /* not fixed? */
        n = ((int)((L->top - ra))); /* get what is available */
      else
        L->top = ra + n; /* set call for 'luaD_poscall' */
      (ci->u.l.savedpc = pc);
      if ((((int)((((i) & (1u << ((0 + 7) + 8)))))))) {
        int nparams1 = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                                 ((~((~(Instruction)0) << (8))) << (0)))))));
        if (nparams1) /* vararg function? */
          ci->func -= ci->u.l.nextraargs + nparams1;
        luaF_close(L, base, 0); /* there may be open upvalues */
      }
      luaD_poscall(L, ci, n);
      return;
    }
    L_OP_RETURN0 : {
      if (L->hookmask) {
        L->top = ra;
        ((ci->u.l.savedpc = pc), (luaD_poscall(L, ci, 0))); /* no hurry... */
      } else { /* do the 'poscall' here */
        int nres = ci->nresults;
        L->ci = ci->previous; /* back to caller */
        L->top = base - 1;
        while (nres-- > 0)
          (((&(L->top++)->val))->tt_ = (0)); /* all results are nil */
      }
      return;
    }
    L_OP_RETURN1 : {
      if (L->hookmask) {
        L->top = ra + 1;
        ((ci->u.l.savedpc = pc), (luaD_poscall(L, ci, 1))); /* no hurry... */
      } else { /* do the 'poscall' here */
        int nres = ci->nresults;
        L->ci = ci->previous; /* back to caller */
        if (nres == 0)
          L->top = base - 1; /* asked for no results */
        else {
          {
            TValue *io1 = ((&(base - 1)->val));
            const TValue *io2 = ((&(ra)->val));
            io1->value_ = io2->value_;
            io1->tt_ = io2->tt_;
            (void)L;
            ((void)0);
            ((void)0);
          }; /* at least this result */
          L->top = base;
          while (--nres > 0) /* complete missing results */
            (((&(L->top++)->val))->tt_ = (0));
        }
      }
      return;
    }
    L_OP_FORLOOP : {
      if ((((((&(ra + 2)->val)))->tt_) ==
           ((3 | (2 << 4)) /* integer numbers */))) { /* integer loop? */
        lua_Unsigned count = ((lua_Unsigned)(((((&(ra + 1)->val))->value_).i)));
        if (count > 0) { /* still more iterations? */
          lua_Integer step = ((((&(ra + 2)->val))->value_).i);
          lua_Integer idx = ((((&(ra)->val))->value_).i); /* internal index */
          {
            TValue *io = ((&(ra + 1)->val));
            ((void)0);
            ((io)->value_).i = (count - 1);
          }; /* update counter */
          idx = ((lua_Integer)(((lua_Unsigned)(idx)) +
                               ((lua_Unsigned)(step)))); /* add step to index */
          {
            TValue *io = ((&(ra)->val));
            ((void)0);
            ((io)->value_).i = (idx);
          }; /* update internal index */
          {
            TValue *io = ((&(ra + 3)->val));
            ((io)->value_).i = (idx);
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          }; /* and control variable */
          pc -= ((((int)((((i) >> (((0 + 7) + 8))) &
                          ((~((~(Instruction)0) << ((8 + 8 + 1))))
                           << (0))))))); /* jump back */
        }
      } else { /* floating loop */
        lua_Number step = ((((&(ra + 2)->val))->value_).n);
        lua_Number limit = ((((&(ra + 1)->val))->value_).n);
        lua_Number idx = ((((&(ra)->val))->value_).n);
        idx = ((idx) + (step)); /* increment index */
        if (((0) < (step)) ? ((idx) <= (limit)) : ((limit) <= (idx))) {
          {
            TValue *io = ((&(ra)->val));
            ((void)0);
            ((io)->value_).n = (idx);
          }; /* update internal index */
          {
            TValue *io = ((&(ra + 3)->val));
            ((io)->value_).n = (idx);
            ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
          }; /* and control variable */
          pc -= ((((int)((((i) >> (((0 + 7) + 8))) &
                          ((~((~(Instruction)0) << ((8 + 8 + 1))))
                           << (0))))))); /* jump back */
        }
      }
      (trap = ci->u.l.trap); /* allows a signal to break the loop */
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_FORPREP : {
      TValue *pinit = (&(ra)->val);
      TValue *plimit = (&(ra + 1)->val);
      TValue *pstep = (&(ra + 2)->val);
      ((ci->u.l.savedpc = pc), L->top = ci->top); /* in case of errors */
      if (((((pinit))->tt_) == ((3 | (2 << 4)) /* integer numbers */)) &&
          ((((pstep))->tt_) ==
           ((3 | (2 << 4)) /* integer numbers */))) { /* integer loop? */
        lua_Integer init = (((pinit)->value_).i);
        lua_Integer step = (((pstep)->value_).i);
        lua_Integer limit;
        if (step == 0)
          luaG_runerror(L, "'for' step is zero");
        {
          TValue *io = ((&(ra + 3)->val));
          ((io)->value_).i = (init);
          ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
        }; /* control variable */
        if (forlimit(L, init, plimit, &limit, step))
          pc +=
              ((((int)((((i) >> (((0 + 7) + 8))) &
                        ((~((~(Instruction)0) << ((8 + 8 + 1)))) << (0))))))) +
              1; /* skip the loop */
        else {   /* prepare loop counter */
          lua_Unsigned count;
          if (step > 0) { /* ascending loop? */
            count = ((lua_Unsigned)(limit)) - ((lua_Unsigned)(init));
            if (step != 1) /* avoid division in the too common case */
              count /= ((lua_Unsigned)(step));
          } else { /* step < 0; descending loop */
            count = ((lua_Unsigned)(init)) - ((lua_Unsigned)(limit));
            /* 'step+1' avoids negating 'mininteger' */
            count /= ((lua_Unsigned)(-(step + 1))) + 1u;
          }
          /* store the counter in place of the limit (which won't be
             needed anymore */
          {
            TValue *io = (plimit);
            ((io)->value_).i = (((lua_Integer)(count)));
            ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
          };
        }
      } else { /* try making all values floats */
        lua_Number init;
        lua_Number limit;
        lua_Number step;
        if ((__builtin_expect(
                ((!(((((plimit))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                        ? (*(&limit) = (((plimit)->value_).n), 1)
                        : luaV_tonumber_(plimit, &limit))) != 0),
                0)))
          luaG_forerror(L, plimit, "limit");
        if ((__builtin_expect(
                ((!(((((pstep))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                        ? (*(&step) = (((pstep)->value_).n), 1)
                        : luaV_tonumber_(pstep, &step))) != 0),
                0)))
          luaG_forerror(L, pstep, "step");
        if ((__builtin_expect(
                ((!(((((pinit))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                        ? (*(&init) = (((pinit)->value_).n), 1)
                        : luaV_tonumber_(pinit, &init))) != 0),
                0)))
          luaG_forerror(L, pinit, "initial value");
        if (step == 0)
          luaG_runerror(L, "'for' step is zero");
        if (((0) < (step)) ? ((limit) < (init)) : ((init) < (limit)))
          pc +=
              ((((int)((((i) >> (((0 + 7) + 8))) &
                        ((~((~(Instruction)0) << ((8 + 8 + 1)))) << (0))))))) +
              1; /* skip the loop */
        else {
          /* make sure internal values are all float */
          {
            TValue *io = (plimit);
            ((io)->value_).n = (limit);
            ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
          };
          {
            TValue *io = (pstep);
            ((io)->value_).n = (step);
            ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
          };
          {
            TValue *io = ((&(ra)->val));
            ((io)->value_).n = (init);
            ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
          }; /* internal index */
          {
            TValue *io = ((&(ra + 3)->val));
            ((io)->value_).n = (init);
            ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
          }; /* control variable */
        }
      }
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_TFORPREP : {
      if (!((((((((&(ra + 3)->val)))->tt_)) & 0x0F)) ==
            (0))) { /* is 'toclose' not nil? */
        /* create to-be-closed upvalue for it */
        ((ci->u.l.savedpc = pc), (luaF_newtbcupval(L, ra + 3)));
      }
      pc += ((((int)((((i) >> (((0 + 7) + 8))) &
                      ((~((~(Instruction)0) << ((8 + 8 + 1)))) << (0)))))));
      i = *(pc++); /* go to next instruction */
      ((void)0);
      goto l_tforcall;
    }
    L_OP_TFORCALL : {
    l_tforcall:
      /* 'ra' has the iterator function, 'ra + 1' has the state,
         'ra + 2' has the control variable, and 'ra + 3' has the
         to-be-closed variable. The call will use the stack after
         these values (starting at 'ra + 4')
      */
      /* push function, state, and control variable */
      memcpy(ra + 4, ra, 3 * sizeof(*ra));
      L->top = ra + 4 + 3;
      (((ci->u.l.savedpc = pc), L->top = ci->top),
       (luaD_call(L, ra + 4,
                  ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                            ((~((~(Instruction)0) << (8))) << (0))))))))),
       (trap = ci->u.l.trap)); /* do the call */
      {
        if (trap) {
          (base = ci->func + 1);
          ra = (base + (((int)((((i) >> ((0 + 7))) &
                                ((~((~(Instruction)0) << (8))) << (0)))))));
        }
      };           /* stack may have changed */
      i = *(pc++); /* go to next instruction */
      ra += 2;     /* adjust for next instruction */
      ((void)0);
      goto l_tforloop;
    }
    L_OP_TFORLOOP : {
    l_tforloop:
      if (!((((((((&(ra + 2)->val)))->tt_)) & 0x0F)) ==
            (0))) { /* continue loop? */
        {
          TValue *io1 = ((&(ra)->val));
          const TValue *io2 = ((&(ra + 2)->val));
          io1->value_ = io2->value_;
          io1->tt_ = io2->tt_;
          (void)L;
          ((void)0);
          ((void)0);
        }; /* save control variable */
        pc -= ((((int)((((i) >> (((0 + 7) + 8))) &
                        ((~((~(Instruction)0) << ((8 + 8 + 1))))
                         << (0))))))); /* jump back */
      }
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_SETLIST : {
      int n = ((((int)((((i) >> ((((0 + 7) + 8) + 1))) &
                        ((~((~(Instruction)0) << (8))) << (0)))))));
      int c = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                        ((~((~(Instruction)0) << (8))) << (0)))))));
      unsigned int last;
      Table *h;
      if (n == 0)
        n = ((int)((L->top - ra))) - 1;
      else
        L->top = ci->top; /* correct top in case of GC */
      if (c == 0) {
        c = ((
            ((int)((((*pc) >> ((0 + 7))) &
                    ((~((~(Instruction)0) << (((8 + 8 + 1) + 8)))) << (0)))))));
        pc++;
      }
      h = ((&((((union GCUnion *)(((((&(ra)->val))->value_).gc))))->h)));
      last = ((c - 1) * 50) + n;
      if (last > luaH_realasize(h))   /* needs more space? */
        luaH_resizearray(L, h, last); /* preallocate it at once */
      for (; n > 0; n--) {
        TValue *val = (&(ra + n)->val);
        {
          TValue *io1 = (&h->array[last - 1]);
          const TValue *io2 = (val);
          io1->value_ = io2->value_;
          io1->tt_ = io2->tt_;
          (void)L;
          ((void)0);
          ((void)0);
        };
        last--;
        (((((val)->tt_) & (1 << 6)) &&
          ((((&(((union GCUnion *)((h)))->gc)))->marked) &
           ((1 << (5 /* object is black */)))) &&
          ((((((val)->value_).gc))->marked) &
           (((1 << (3 /* object is white (type 0) */)) |
             (1 << (4 /* object is white (type 1) */))))))
             ? luaC_barrierback_(L, (&(((union GCUnion *)((h)))->gc)))
             : ((void)((0))));
      }
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_CLOSURE : {
      Proto *p = cl->p->p[(
          (((int)((((i) >> (((0 + 7) + 8))) &
                   ((~((~(Instruction)0) << ((8 + 8 + 1)))) << (0)))))))];
      ((ci->u.l.savedpc = pc), (pushclosure(L, p, cl->upvals, base, ra)));
      {
        {
          if ((L->l_G)->GCdebt > 0) {
            L->top = (ra + 1);
            luaC_step(L); /* limit of live values */
            (trap = ci->u.l.trap);
          };
          ((void)0);
        };
        {
          ((void)0);
          ((void)0);
        };
      };
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_VARARG : {
      int n = ((((int)((((i) >> (((((0 + 7) + 8) + 1) + 8))) &
                        ((~((~(Instruction)0) << (8))) << (0))))))) -
              1; /* required results */
      (((ci->u.l.savedpc = pc), L->top = ci->top),
       (luaT_getvarargs(L, ci, ra, n)), (trap = ci->u.l.trap));
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_VARARGPREP : {
      luaT_adjustvarargs(L,
                         (((int)((((i) >> ((0 + 7))) &
                                  ((~((~(Instruction)0) << (8))) << (0)))))),
                         ci, cl->p);
      (trap = ci->u.l.trap);
      if (trap) {
        luaD_hookcall(L, ci);
        L->oldpc = pc + 1; /* next opcode will be seen as a "new" line */
      }
      (base = ci->func + 1); /* function has new base after adjustment */
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    L_OP_EXTRAARG : {
      ((void)0);
      {
        if (trap) {                     /* stack reallocation or hooks? */
          trap = luaG_traceexec(L, pc); /* handle hooks */
          (base = ci->func + 1);        /* correct stack */
        }
        i = *(pc++);
        ra = (base + (((int)((((i) >> ((0 + 7))) &
                              ((~((~(Instruction)0) << (8)))
                               << (0))))))); /* WARNING: any stack reallocation
                                                invalidates 'ra' */
      };
      goto *disptab[(
          ((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << (7))) << (0)))))];
      ;
      ;
    }
    }
  }
}

/* }================================================================== */
/*
** $Id: lapi.c $
** Lua API
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lapi.h $
** Auxiliary functions from Lua API
** See Copyright Notice in lua.h
*/
/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/
/*
** $Id: ldo.h $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/
/*
** $Id: lfunc.h $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/
/*
** $Id: lgc.h $
** Garbage Collector
** See Copyright Notice in lua.h
*/
/*
** $Id: lmem.h $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/
/*
** $Id: lobject.h $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/
/*
** $Id: lstate.h $
** Global State
** See Copyright Notice in lua.h
*/
/*
** $Id: lstring.h $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltable.h $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/
/*
** $Id: ltm.h $
** Tag methods
** See Copyright Notice in lua.h
*/
/*
** $Id: lundump.h $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/
/*
** $Id: lvm.h $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

const char lua_ident[] = "$LuaVersion: "
                         "Lua "
                         "5"
                         "."
                         "4"
                         "."
                         "0"
                         "  Copyright (C) 1994-2019 Lua.org, PUC-Rio"
                         " $"
                         "$LuaAuthors: "
                         "R. Ierusalimschy, L. H. de Figueiredo, W. Celes"
                         " $";

/*
** Test for a valid index.
** '!ttisnil(o)' implies 'o != &G(L)->nilvalue', so it is not needed.
** However, it covers the most common cases in a faster way.
*/

/* test for pseudo index */

/* test for upvalue */

static TValue *index2value(lua_State *L, int idx) {
  CallInfo *ci = L->ci;
  if (idx > 0) {
    StkId o = ci->func + idx;
    ((void)0);
    if (o >= L->top)
      return &(L->l_G)->nilvalue;
    else
      return (&(o)->val);
  } else if (!((idx) <= (-1000000 - 1000))) { /* negative index */
    ((void)0);
    return (&(L->top + idx)->val);
  } else if (idx == (-1000000 - 1000))
    return &(L->l_G)->l_registry;
  else { /* upvalues */
    idx = (-1000000 - 1000) - idx;
    ((void)0);
    if ((((((&(ci->func)->val)))->tt_) ==
         ((6 | (2 << 4)) /* light C function */))) /* light C function? */
      return &(L->l_G)->nilvalue;                  /* it has no upvalues */
    else {
      CClosure *func = ((
          &((((union GCUnion *)(((((&(ci->func)->val))->value_).gc))))->cl.c)));
      return (idx <= func->nupvalues) ? &func->upvalue[idx - 1]
                                      : &(L->l_G)->nilvalue;
    }
  }
}

static StkId index2stack(lua_State *L, int idx) {
  CallInfo *ci = L->ci;
  if (idx > 0) {
    StkId o = ci->func + idx;
    ((void)0);
    return o;
  } else { /* non-positive index */
    ((void)0);
    ((void)0);
    return L->top + idx;
  }
}

extern int lua_checkstack(lua_State *L, int n) {
  int res;
  CallInfo *ci = L->ci;
  ((void)0);
  ((void)0);
  if (L->stack_last - L->top > n) /* stack large enough? */
    res = 1;                      /* yes; check is OK */
  else {                          /* no; need to grow stack */
    int inuse = ((int)((L->top - L->stack))) + 5;
    if (inuse > 1000000 - n) /* can grow without overflow? */
      res = 0;               /* no */
    else                     /* try to grow stack */
      res = luaD_growstack(L, n, 0);
  }
  if (res && ci->top < L->top + n)
    ci->top = L->top + n; /* adjust frame top */
  ((void)0);
  return res;
}

extern void lua_xmove(lua_State *from, lua_State *to, int n) {
  int i;
  if (from == to)
    return;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  from->top -= n;
  for (i = 0; i < n; i++) {
    {
      TValue *io1 = ((&(to->top)->val));
      const TValue *io2 = ((&(from->top + i)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)to;
      ((void)0);
      ((void)0);
    };
    to->top++; /* stack already checked by previous 'api_check' */
  }
  ((void)0);
}

extern lua_CFunction lua_atpanic(lua_State *L, lua_CFunction panicf) {
  lua_CFunction old;
  ((void)0);
  old = (L->l_G)->panic;
  (L->l_G)->panic = panicf;
  ((void)0);
  return old;
}

extern lua_Number lua_version(lua_State *L) {
  ((void)(L));
  return 504;
}

/*
** basic stack manipulation
*/

/*
** convert an acceptable stack index into an absolute index
*/
extern int lua_absindex(lua_State *L, int idx) {
  return (idx > 0 || ((idx) <= (-1000000 - 1000)))
             ? idx
             : ((int)((L->top - L->ci->func))) + idx;
}

extern int lua_gettop(lua_State *L) {
  return ((int)((L->top - (L->ci->func + 1))));
}

extern void lua_settop(lua_State *L, int idx) {
  StkId func = L->ci->func;
  ((void)0);
  if (idx >= 0) {
    StkId newtop = (func + 1) + idx;
    ((void)0);
    while (L->top < newtop)
      (((&(L->top++)->val))->tt_ = (0));
    L->top = newtop;
  } else {
    ((void)0);
    L->top += idx + 1; /* 'subtract' index (index is negative) */
  }
  luaF_close(L, L->top, 0);
  ((void)0);
}

/*
** Reverse the stack segment from 'from' to 'to'
** (auxiliary to 'lua_rotate')
** Note that we move(copy) only the value inside the stack.
** (We do not move additional fields that may exist.)
*/
static void reverse(lua_State *L, StkId from, StkId to) {
  for (; from < to; from++, to--) {
    TValue temp;
    {
      TValue *io1 = (&temp);
      const TValue *io2 = ((&(from)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    {
      TValue *io1 = ((&(from)->val));
      const TValue *io2 = ((&(to)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    {
      TValue *io1 = ((&(to)->val));
      const TValue *io2 = (&temp);
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
  }
}

/*
** Let x = AB, where A is a prefix of length 'n'. Then,
** rotate x n == BA. But BA == (A^r . B^r)^r.
*/
extern void lua_rotate(lua_State *L, int idx, int n) {
  StkId p, t, m;
  ((void)0);
  t = L->top - 1;          /* end of stack segment being rotated */
  p = index2stack(L, idx); /* start of segment */
  ((void)0);
  m = (n >= 0 ? t - n : p - n - 1); /* end of prefix */
  reverse(L, p, m);                 /* reverse the prefix with length 'n' */
  reverse(L, m + 1, t);             /* reverse the suffix */
  reverse(L, p, t);                 /* reverse the entire segment */
  ((void)0);
}

extern void lua_copy(lua_State *L, int fromidx, int toidx) {
  TValue *fr, *to;
  ((void)0);
  fr = index2value(L, fromidx);
  to = index2value(L, toidx);
  ((void)0);
  {
    TValue *io1 = (to);
    const TValue *io2 = (fr);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
  if (((toidx) < (-1000000 - 1000))) /* function upvalue? */
    (((((fr)->tt_) & (1 << 6)) &&
      (((((&((((union GCUnion *)(((((&(L->ci->func)->val))->value_).gc))))
                 ->cl.c))))
            ->marked) &
       ((1 << (5 /* object is black */)))) &&
      ((((((fr)->value_).gc))->marked) &
       (((1 << (3 /* object is white (type 0) */)) |
         (1 << (4 /* object is white (type 1) */))))))
         ? luaC_barrier_(L,
                         (&(((union GCUnion *)((((
                                 &((((union GCUnion *)((
                                        (((&(L->ci->func)->val))->value_).gc))))
                                       ->cl.c))))))
                                ->gc)),
                         (((fr)->value_).gc))
         : ((void)((0))));
  /* LUA_REGISTRYINDEX does not need gc barrier
     (collector revisits it before finishing collection) */
  ((void)0);
}

extern void lua_pushvalue(lua_State *L, int idx) {
  ((void)0);
  {
    TValue *io1 = ((&(L->top)->val));
    const TValue *io2 = (index2value(L, idx));
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
}

/*
** access functions (stack -> C)
*/

extern int lua_type(lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return ((!(((((((o))->tt_)) & 0x0F)) == (0)) || o != &(L->l_G)->nilvalue)
              ? (((((o)->tt_)) & 0x0F))
              : (-1));
}

extern const char *lua_typename(lua_State *L, int t) {
  ((void)(L));
  ((void)0);
  return luaT_typenames_[(t) + 1];
}

extern int lua_iscfunction(lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return (((((o))->tt_) == ((6 | (2 << 4)) /* light C function */)) ||
          (((((o))->tt_) == ((((6 | (3 << 4)) /* C closure */) | (1 << 6))))));
}

extern int lua_isinteger(lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return ((((o))->tt_) == ((3 | (2 << 4)) /* integer numbers */));
}

extern int lua_isnumber(lua_State *L, int idx) {
  lua_Number n;
  const TValue *o = index2value(L, idx);
  return (((((o))->tt_) == ((3 | (1 << 4)) /* float numbers */))
              ? (*(&n) = (((o)->value_).n), 1)
              : luaV_tonumber_(o, &n));
}

extern int lua_isstring(lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return ((((((((o))->tt_)) & 0x0F)) == (4)) ||
          (((((((o))->tt_)) & 0x0F)) == (3)));
}

extern int lua_isuserdata(lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return ((((((((o))->tt_)) & 0x0F)) == (7)) || ((((o))->tt_) == (2)));
}

extern int lua_rawequal(lua_State *L, int index1, int index2) {
  const TValue *o1 = index2value(L, index1);
  const TValue *o2 = index2value(L, index2);
  return ((!(((((((o1))->tt_)) & 0x0F)) == (0)) || o1 != &(L->l_G)->nilvalue) &&
          (!(((((((o2))->tt_)) & 0x0F)) == (0)) || o2 != &(L->l_G)->nilvalue))
             ? luaV_equalobj(((void *)0), o1, o2)
             : 0;
}

extern void lua_arith(lua_State *L, int op) {
  ((void)0);
  if (op != 12 && op != 13)
    ((void)0); /* all other operations expect two operands */
  else {       /* for unary operations, add fake 2nd operand */
    ((void)0);
    {
      TValue *io1 = ((&(L->top)->val));
      const TValue *io2 = ((&(L->top - 1)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    {
      L->top++;
      ((void)0);
    };
  }
  /* first operand at top - 2, second at top - 1; result go to top - 2 */
  luaO_arith(L, op, (&(L->top - 2)->val), (&(L->top - 1)->val), L->top - 2);
  L->top--; /* remove second operand */
  ((void)0);
}

extern int lua_compare(lua_State *L, int index1, int index2, int op) {
  const TValue *o1;
  const TValue *o2;
  int i = 0;
  ((void)0); /* may call tag method */
  o1 = index2value(L, index1);
  o2 = index2value(L, index2);
  if ((!(((((((o1))->tt_)) & 0x0F)) == (0)) || o1 != &(L->l_G)->nilvalue) &&
      (!(((((((o2))->tt_)) & 0x0F)) == (0)) || o2 != &(L->l_G)->nilvalue)) {
    switch (op) {
    case 0:
      i = luaV_equalobj(L, o1, o2);
      break;
    case 1:
      i = luaV_lessthan(L, o1, o2);
      break;
    case 2:
      i = luaV_lessequal(L, o1, o2);
      break;
    default:
      ((void)0);
    }
  }
  ((void)0);
  return i;
}

extern size_t lua_stringtonumber(lua_State *L, const char *s) {
  size_t sz = luaO_str2num(s, (&(L->top)->val));
  if (sz != 0) {
    L->top++;
    ((void)0);
  };
  return sz;
}

extern lua_Number lua_tonumberx(lua_State *L, int idx, int *pisnum) {
  lua_Number n;
  const TValue *o = index2value(L, idx);
  int isnum = (((((o))->tt_) == ((3 | (1 << 4)) /* float numbers */))
                   ? (*(&n) = (((o)->value_).n), 1)
                   : luaV_tonumber_(o, &n));
  if (!isnum)
    n = 0; /* call to 'tonumber' may change 'n' even if it fails */
  if (pisnum)
    *pisnum = isnum;
  return n;
}

extern lua_Integer lua_tointegerx(lua_State *L, int idx, int *pisnum) {
  lua_Integer res;
  const TValue *o = index2value(L, idx);
  int isnum = (((((o))->tt_) == ((3 | (2 << 4)) /* integer numbers */))
                   ? (*(&res) = (((o)->value_).i), 1)
                   : luaV_tointeger(o, &res, 0));
  if (!isnum)
    res = 0; /* call to 'tointeger' may change 'n' even if it fails */
  if (pisnum)
    *pisnum = isnum;
  return res;
}

extern int lua_toboolean(lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return !((((((((o))->tt_)) & 0x0F)) == (0)) ||
           (((((o))->tt_) == (1)) && (((o)->value_).b) == 0));
}

extern const char *lua_tolstring(lua_State *L, int idx, size_t *len) {
  TValue *o = index2value(L, idx);
  if (!(((((((o))->tt_)) & 0x0F)) == (4))) {
    if (!(((((((o))->tt_)) & 0x0F)) == (3))) { /* not convertible? */
      if (len != ((void *)0))
        *len = 0;
      return ((void *)0);
    }
    ((void)0); /* 'luaO_tostring' may create a new string */
    luaO_tostring(L, o);
    {
      if ((L->l_G)->GCdebt > 0) {
        (void)0;
        luaC_step(L);
        (void)0;
      };
      ((void)0);
    };
    o = index2value(L, idx); /* previous call may reallocate the stack */
    ((void)0);
  }
  if (len != ((void *)0))
    *len = ((((&((((union GCUnion *)((((o)->value_).gc))))->ts))))->tt ==
                    (4 | (1 << 4)) /* short strings */
                ? (((&((((union GCUnion *)((((o)->value_).gc))))->ts))))->shrlen
                : (((&((((union GCUnion *)((((o)->value_).gc))))->ts))))
                      ->u.lnglen);
  return (((char *)(((((&((((union GCUnion *)((((o)->value_).gc))))->ts))))))) +
          sizeof(TString));
}

extern lua_Unsigned lua_rawlen(lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  switch (((((o)->tt_)) & 0x3F)) {
  case (4 | (1 << 4)) /* short strings */:
    return ((&((((union GCUnion *)((((o)->value_).gc))))->ts)))->shrlen;
  case (4 | (2 << 4)) /* long strings */:
    return ((&((((union GCUnion *)((((o)->value_).gc))))->ts)))->u.lnglen;
  case 7:
    return ((&((((union GCUnion *)((((o)->value_).gc))))->u)))->len;
  case 5:
    return luaH_getn(((&((((union GCUnion *)((((o)->value_).gc))))->h))));
  default:
    return 0;
  }
}

extern lua_CFunction lua_tocfunction(lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  if (((((o))->tt_) == ((6 | (2 << 4)) /* light C function */)))
    return (((o)->value_).f);
  else if (((((o))->tt_) == ((((6 | (3 << 4)) /* C closure */) | (1 << 6)))))
    return ((&((((union GCUnion *)((((o)->value_).gc))))->cl.c)))->f;
  else
    return ((void *)0); /* not a C function */
}

static void *touserdata(const TValue *o) {
  switch ((((((o)->tt_)) & 0x0F))) {
  case 7:
    return (
        ((char *)((((&((((union GCUnion *)((((o)->value_).gc))))->u)))))) +
        (((((&((((union GCUnion *)((((o)->value_).gc))))->u))))->nuvalue) == 0
             ? __builtin_offsetof(Udata0, bindata)
             : __builtin_offsetof(Udata, uv) +
                   (sizeof(UValue) *
                    ((((&((((union GCUnion *)((((o)->value_).gc))))->u))))
                         ->nuvalue))));
  case 2:
    return (((o)->value_).p);
  default:
    return ((void *)0);
  }
}

extern void *lua_touserdata(lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return touserdata(o);
}

extern lua_State *lua_tothread(lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  return (!((((o))->tt_) == (((8) | (1 << 6)))))
             ? ((void *)0)
             : ((&((((union GCUnion *)((((o)->value_).gc))))->th)));
}

/*
** Returns a pointer to the internal representation of an object.
** Note that ANSI C does not allow the conversion of a pointer to
** function to a 'void*', so the conversion here goes through
** a 'size_t'. (As the returned pointer is only informative, this
** conversion should not be a problem.)
*/
extern const void *lua_topointer(lua_State *L, int idx) {
  const TValue *o = index2value(L, idx);
  switch (((((o)->tt_)) & 0x3F)) {
  case (6 | (2 << 4)) /* light C function */:
    return ((void *)((((size_t)(((((o)->value_).f)))))));
  case 7:
  case 2:
    return touserdata(o);
  default: {
    if ((((o)->tt_) & (1 << 6)))
      return (((o)->value_).gc);
    else
      return ((void *)0);
  }
  }
}

/*
** push functions (C -> stack)
*/

extern void lua_pushnil(lua_State *L) {
  ((void)0);
  (((&(L->top)->val))->tt_ = (0));
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
}

extern void lua_pushnumber(lua_State *L, lua_Number n) {
  ((void)0);
  {
    TValue *io = ((&(L->top)->val));
    ((io)->value_).n = (n);
    ((io)->tt_ = ((3 | (1 << 4)) /* float numbers */));
  };
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
}

extern void lua_pushinteger(lua_State *L, lua_Integer n) {
  ((void)0);
  {
    TValue *io = ((&(L->top)->val));
    ((io)->value_).i = (n);
    ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
  };
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
}

/*
** Pushes on the stack a string with given length. Avoid using 's' when
** 'len' == 0 (as 's' can be NULL in that case), due to later use of
** 'memcmp' and 'memcpy'.
*/
extern const char *lua_pushlstring(lua_State *L, const char *s, size_t len) {
  TString *ts;
  ((void)0);
  ts = (len == 0) ? luaS_new(L, "") : luaS_newlstr(L, s, len);
  {
    TValue *io = ((&(L->top)->val));
    TString *x_ = (ts);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((x_->tt) | (1 << 6))));
    ((void)0);
  };
  {
    L->top++;
    ((void)0);
  };
  {
    if ((L->l_G)->GCdebt > 0) {
      (void)0;
      luaC_step(L);
      (void)0;
    };
    ((void)0);
  };
  ((void)0);
  return (((char *)(((ts)))) + sizeof(TString));
}

extern const char *lua_pushstring(lua_State *L, const char *s) {
  ((void)0);
  if (s == ((void *)0))
    (((&(L->top)->val))->tt_ = (0));
  else {
    TString *ts;
    ts = luaS_new(L, s);
    {
      TValue *io = ((&(L->top)->val));
      TString *x_ = (ts);
      ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
      ((io)->tt_ = (((x_->tt) | (1 << 6))));
      ((void)0);
    };
    s = (((char *)(((ts)))) + sizeof(TString)); /* internal copy's address */
  }
  {
    L->top++;
    ((void)0);
  };
  {
    if ((L->l_G)->GCdebt > 0) {
      (void)0;
      luaC_step(L);
      (void)0;
    };
    ((void)0);
  };
  ((void)0);
  return s;
}

extern const char *lua_pushvfstring(lua_State *L, const char *fmt,
                                    va_list argp) {
  const char *ret;
  ((void)0);
  ret = luaO_pushvfstring(L, fmt, argp);
  {
    if ((L->l_G)->GCdebt > 0) {
      (void)0;
      luaC_step(L);
      (void)0;
    };
    ((void)0);
  };
  ((void)0);
  return ret;
}

extern const char *lua_pushfstring(lua_State *L, const char *fmt, ...) {
  const char *ret;
  va_list argp;
  ((void)0);

  __builtin_va_start(argp, fmt);
  ret = luaO_pushvfstring(L, fmt, argp);

  __builtin_va_end(argp);
  {
    if ((L->l_G)->GCdebt > 0) {
      (void)0;
      luaC_step(L);
      (void)0;
    };
    ((void)0);
  };
  ((void)0);
  return ret;
}

extern void lua_pushcclosure(lua_State *L, lua_CFunction fn, int n) {
  ((void)0);
  if (n == 0) {
    {
      TValue *io = ((&(L->top)->val));
      ((io)->value_).f = (fn);
      ((io)->tt_ = ((6 | (2 << 4)) /* light C function */));
    };
    {
      L->top++;
      ((void)0);
    };
  } else {
    CClosure *cl;
    ((void)0);
    ((void)0);
    cl = luaF_newCclosure(L, n);
    cl->f = fn;
    L->top -= n;
    while (n--) {
      {
        TValue *io1 = (&cl->upvalue[n]);
        const TValue *io2 = ((&(L->top + n)->val));
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      /* does not need barrier because closure is white */
    }
    {
      TValue *io = ((&(L->top)->val));
      CClosure *x_ = (cl);
      ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
      ((io)->tt_ = ((((6 | (3 << 4)) /* C closure */) | (1 << 6))));
      ((void)0);
    };
    {
      L->top++;
      ((void)0);
    };
    {
      if ((L->l_G)->GCdebt > 0) {
        (void)0;
        luaC_step(L);
        (void)0;
      };
      ((void)0);
    };
  }
  ((void)0);
}

extern void lua_pushboolean(lua_State *L, int b) {
  ((void)0);
  {
    TValue *io = ((&(L->top)->val));
    ((io)->value_).b = ((b != 0));
    ((io)->tt_ = (1));
  }; /* ensure that true is 1 */
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
}

extern void lua_pushlightuserdata(lua_State *L, void *p) {
  ((void)0);
  {
    TValue *io = ((&(L->top)->val));
    ((io)->value_).p = (p);
    ((io)->tt_ = (2));
  };
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
}

extern int lua_pushthread(lua_State *L) {
  ((void)0);
  {
    TValue *io = ((&(L->top)->val));
    lua_State *x_ = (L);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((8) | (1 << 6))));
    ((void)0);
  };
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
  return ((L->l_G)->mainthread == L);
}

/*
** get functions (Lua -> stack)
*/

static int auxgetstr(lua_State *L, const TValue *t, const char *k) {
  const TValue *slot;
  TString *str = luaS_new(L, k);
  if ((!((((t))->tt_) == (((5) | (1 << 6))))
           ? (slot = ((void *)0),
              0) /* not a table; 'slot' is NULL and result is 0 */
           : (slot = luaH_getstr(
                  ((&((((union GCUnion *)((((t)->value_).gc))))->h))), str),
              /* else, do raw access */ !(((((((slot))->tt_)) & 0x0F)) ==
                                          (0)))) /* result not empty? */) {
    {
      TValue *io1 = ((&(L->top)->val));
      const TValue *io2 = (slot);
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    {
      L->top++;
      ((void)0);
    };
  } else {
    {
      TValue *io = ((&(L->top)->val));
      TString *x_ = (str);
      ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
      ((io)->tt_ = (((x_->tt) | (1 << 6))));
      ((void)0);
    };
    {
      L->top++;
      ((void)0);
    };
    luaV_finishget(L, t, (&(L->top - 1)->val), L->top - 1, slot);
  }
  ((void)0);
  return ((((((&(L->top - 1)->val))->tt_)) & 0x0F));
}

extern int lua_getglobal(lua_State *L, const char *name) {
  Table *reg =
      ((&((((union GCUnion *)((((&(L->l_G)->l_registry)->value_).gc))))->h)));
  ((void)0);
  return auxgetstr(L, luaH_getint(reg, 2), name);
}

extern int lua_gettable(lua_State *L, int idx) {
  const TValue *slot;
  TValue *t;
  ((void)0);
  t = index2value(L, idx);
  if ((!((((t))->tt_) == (((5) | (1 << 6))))
           ? (slot = ((void *)0),
              0) /* not a table; 'slot' is NULL and result is 0 */
           : (slot =
                  luaH_get(((&((((union GCUnion *)((((t)->value_).gc))))->h))),
                           (&(L->top - 1)->val)),
              /* else, do raw access */ !(((((((slot))->tt_)) & 0x0F)) ==
                                          (0)))) /* result not empty? */) {
    {
      TValue *io1 = ((&(L->top - 1)->val));
      const TValue *io2 = (slot);
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
  } else
    luaV_finishget(L, t, (&(L->top - 1)->val), L->top - 1, slot);
  ((void)0);
  return ((((((&(L->top - 1)->val))->tt_)) & 0x0F));
}

extern int lua_getfield(lua_State *L, int idx, const char *k) {
  ((void)0);
  return auxgetstr(L, index2value(L, idx), k);
}

extern int lua_geti(lua_State *L, int idx, lua_Integer n) {
  TValue *t;
  const TValue *slot;
  ((void)0);
  t = index2value(L, idx);
  if ((!((((t))->tt_) == (((5) | (1 << 6))))
           ? (slot = ((void *)0),
              0) /* not a table; 'slot' is NULL and result is 0 */
           : (slot =
                  (((lua_Unsigned)(n)) - 1u <
                   ((&((((union GCUnion *)((((t)->value_).gc))))->h)))->alimit)
                      ? &((&((((union GCUnion *)((((t)->value_).gc))))->h)))
                             ->array[n - 1]
                      : luaH_getint(
                            ((&((((union GCUnion *)((((t)->value_).gc))))->h))),
                            n),
              !(((((((slot))->tt_)) & 0x0F)) ==
                (0)))) /* result not empty? */) {
    {
      TValue *io1 = ((&(L->top)->val));
      const TValue *io2 = (slot);
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
  } else {
    TValue aux;
    {
      TValue *io = (&aux);
      ((io)->value_).i = (n);
      ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
    };
    luaV_finishget(L, t, &aux, L->top, slot);
  }
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
  return ((((((&(L->top - 1)->val))->tt_)) & 0x0F));
}

static int finishrawget(lua_State *L, const TValue *val) {
  if ((((((((val))->tt_)) & 0x0F)) ==
       (0))) /* avoid copying empty items to the stack */
    (((&(L->top)->val))->tt_ = (0));
  else {
    TValue *io1 = ((&(L->top)->val));
    const TValue *io2 = (val);
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
  return ((((((&(L->top - 1)->val))->tt_)) & 0x0F));
}

static Table *gettable(lua_State *L, int idx) {
  TValue *t = index2value(L, idx);
  ((void)0);
  return ((&((((union GCUnion *)((((t)->value_).gc))))->h)));
}

extern int lua_rawget(lua_State *L, int idx) {
  Table *t;
  const TValue *val;
  ((void)0);
  ((void)0);
  t = gettable(L, idx);
  val = luaH_get(t, (&(L->top - 1)->val));
  L->top--; /* remove key */
  return finishrawget(L, val);
}

extern int lua_rawgeti(lua_State *L, int idx, lua_Integer n) {
  Table *t;
  ((void)0);
  t = gettable(L, idx);
  return finishrawget(L, luaH_getint(t, n));
}

extern int lua_rawgetp(lua_State *L, int idx, const void *p) {
  Table *t;
  TValue k;
  ((void)0);
  t = gettable(L, idx);
  {
    TValue *io = (&k);
    ((io)->value_).p = (((void *)((p))));
    ((io)->tt_ = (2));
  };
  return finishrawget(L, luaH_get(t, &k));
}

extern void lua_createtable(lua_State *L, int narray, int nrec) {
  Table *t;
  ((void)0);
  t = luaH_new(L);
  {
    TValue *io = ((&(L->top)->val));
    Table *x_ = (t);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((5) | (1 << 6))));
    ((void)0);
  };
  {
    L->top++;
    ((void)0);
  };
  if (narray > 0 || nrec > 0)
    luaH_resize(L, t, narray, nrec);
  {
    if ((L->l_G)->GCdebt > 0) {
      (void)0;
      luaC_step(L);
      (void)0;
    };
    ((void)0);
  };
  ((void)0);
}

extern int lua_getmetatable(lua_State *L, int objindex) {
  const TValue *obj;
  Table *mt;
  int res = 0;
  ((void)0);
  obj = index2value(L, objindex);
  switch ((((((obj)->tt_)) & 0x0F))) {
  case 5:
    mt = ((&((((union GCUnion *)((((obj)->value_).gc))))->h)))->metatable;
    break;
  case 7:
    mt = ((&((((union GCUnion *)((((obj)->value_).gc))))->u)))->metatable;
    break;
  default:
    mt = (L->l_G)->mt[(((((obj)->tt_)) & 0x0F))];
    break;
  }
  if (mt != ((void *)0)) {
    {
      TValue *io = ((&(L->top)->val));
      Table *x_ = (mt);
      ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
      ((io)->tt_ = (((5) | (1 << 6))));
      ((void)0);
    };
    {
      L->top++;
      ((void)0);
    };
    res = 1;
  }
  ((void)0);
  return res;
}

extern int lua_getiuservalue(lua_State *L, int idx, int n) {
  TValue *o;
  int t;
  ((void)0);
  o = index2value(L, idx);
  ((void)0);
  if (n <= 0 ||
      n > ((&((((union GCUnion *)((((o)->value_).gc))))->u)))->nuvalue) {
    (((&(L->top)->val))->tt_ = (0));
    t = (-1);
  } else {
    {
      TValue *io1 = ((&(L->top)->val));
      const TValue *io2 =
          (&((&((((union GCUnion *)((((o)->value_).gc))))->u)))->uv[n - 1].uv);
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    t = ((((((&(L->top)->val))->tt_)) & 0x0F));
  }
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
  return t;
}

/*
** set functions (stack -> Lua)
*/

/*
** t[k] = value at the top of the stack (where 'k' is a string)
*/
static void auxsetstr(lua_State *L, const TValue *t, const char *k) {
  const TValue *slot;
  TString *str = luaS_new(L, k);
  ((void)0);
  if ((!((((t))->tt_) == (((5) | (1 << 6))))
           ? (slot = ((void *)0),
              0) /* not a table; 'slot' is NULL and result is 0 */
           : (slot = luaH_getstr(
                  ((&((((union GCUnion *)((((t)->value_).gc))))->h))), str),
              /* else, do raw access */ !(((((((slot))->tt_)) & 0x0F)) ==
                                          (0)))) /* result not empty? */) {
    {
      {
        TValue *io1 = (((TValue *)(slot)));
        const TValue *io2 = ((&(L->top - 1)->val));
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      ((((((&(L->top - 1)->val))->tt_) & (1 << 6)) &&
        ((((((t)->value_).gc))->marked) & ((1 << (5 /* object is black */)))) &&
        (((((((&(L->top - 1)->val))->value_).gc))->marked) &
         (((1 << (3 /* object is white (type 0) */)) |
           (1 << (4 /* object is white (type 1) */))))))
           ? luaC_barrierback_(L, (((t)->value_).gc))
           : ((void)((0))));
    };
    L->top--; /* pop value */
  } else {
    {
      TValue *io = ((&(L->top)->val));
      TString *x_ = (str);
      ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
      ((io)->tt_ = (((x_->tt) | (1 << 6))));
      ((void)0);
    }; /* push 'str' (to make it a TValue) */
    {
      L->top++;
      ((void)0);
    };
    luaV_finishset(L, t, (&(L->top - 1)->val), (&(L->top - 2)->val), slot);
    L->top -= 2; /* pop value and key */
  }
  ((void)0); /* lock done by caller */
}

extern void lua_setglobal(lua_State *L, const char *name) {
  Table *reg =
      ((&((((union GCUnion *)((((&(L->l_G)->l_registry)->value_).gc))))->h)));
  ((void)0); /* unlock done in 'auxsetstr' */
  auxsetstr(L, luaH_getint(reg, 2), name);
}

extern void lua_settable(lua_State *L, int idx) {
  TValue *t;
  const TValue *slot;
  ((void)0);
  ((void)0);
  t = index2value(L, idx);
  if ((!((((t))->tt_) == (((5) | (1 << 6))))
           ? (slot = ((void *)0),
              0) /* not a table; 'slot' is NULL and result is 0 */
           : (slot =
                  luaH_get(((&((((union GCUnion *)((((t)->value_).gc))))->h))),
                           (&(L->top - 2)->val)),
              /* else, do raw access */ !(((((((slot))->tt_)) & 0x0F)) ==
                                          (0)))) /* result not empty? */) {
    {
      {
        TValue *io1 = (((TValue *)(slot)));
        const TValue *io2 = ((&(L->top - 1)->val));
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      ((((((&(L->top - 1)->val))->tt_) & (1 << 6)) &&
        ((((((t)->value_).gc))->marked) & ((1 << (5 /* object is black */)))) &&
        (((((((&(L->top - 1)->val))->value_).gc))->marked) &
         (((1 << (3 /* object is white (type 0) */)) |
           (1 << (4 /* object is white (type 1) */))))))
           ? luaC_barrierback_(L, (((t)->value_).gc))
           : ((void)((0))));
    };
  } else
    luaV_finishset(L, t, (&(L->top - 2)->val), (&(L->top - 1)->val), slot);
  L->top -= 2; /* pop index and value */
  ((void)0);
}

extern void lua_setfield(lua_State *L, int idx, const char *k) {
  ((void)0); /* unlock done in 'auxsetstr' */
  auxsetstr(L, index2value(L, idx), k);
}

extern void lua_seti(lua_State *L, int idx, lua_Integer n) {
  TValue *t;
  const TValue *slot;
  ((void)0);
  ((void)0);
  t = index2value(L, idx);
  if ((!((((t))->tt_) == (((5) | (1 << 6))))
           ? (slot = ((void *)0),
              0) /* not a table; 'slot' is NULL and result is 0 */
           : (slot =
                  (((lua_Unsigned)(n)) - 1u <
                   ((&((((union GCUnion *)((((t)->value_).gc))))->h)))->alimit)
                      ? &((&((((union GCUnion *)((((t)->value_).gc))))->h)))
                             ->array[n - 1]
                      : luaH_getint(
                            ((&((((union GCUnion *)((((t)->value_).gc))))->h))),
                            n),
              !(((((((slot))->tt_)) & 0x0F)) ==
                (0)))) /* result not empty? */) {
    {
      {
        TValue *io1 = (((TValue *)(slot)));
        const TValue *io2 = ((&(L->top - 1)->val));
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      ((((((&(L->top - 1)->val))->tt_) & (1 << 6)) &&
        ((((((t)->value_).gc))->marked) & ((1 << (5 /* object is black */)))) &&
        (((((((&(L->top - 1)->val))->value_).gc))->marked) &
         (((1 << (3 /* object is white (type 0) */)) |
           (1 << (4 /* object is white (type 1) */))))))
           ? luaC_barrierback_(L, (((t)->value_).gc))
           : ((void)((0))));
    };
  } else {
    TValue aux;
    {
      TValue *io = (&aux);
      ((io)->value_).i = (n);
      ((io)->tt_ = ((3 | (2 << 4)) /* integer numbers */));
    };
    luaV_finishset(L, t, &aux, (&(L->top - 1)->val), slot);
  }
  L->top--; /* pop value */
  ((void)0);
}

extern void lua_rawset(lua_State *L, int idx) {
  Table *t;
  TValue *slot;
  ((void)0);
  ((void)0);
  t = gettable(L, idx);
  slot = luaH_set(L, t, (&(L->top - 2)->val));
  {
    TValue *io1 = (slot);
    const TValue *io2 = ((&(L->top - 1)->val));
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
  ((t)->flags = 0);
  ((((((&(L->top - 1)->val))->tt_) & (1 << 6)) &&
    ((((&(((union GCUnion *)((t)))->gc)))->marked) &
     ((1 << (5 /* object is black */)))) &&
    (((((((&(L->top - 1)->val))->value_).gc))->marked) &
     (((1 << (3 /* object is white (type 0) */)) |
       (1 << (4 /* object is white (type 1) */))))))
       ? luaC_barrierback_(L, (&(((union GCUnion *)((t)))->gc)))
       : ((void)((0))));
  L->top -= 2;
  ((void)0);
}

extern void lua_rawseti(lua_State *L, int idx, lua_Integer n) {
  Table *t;
  ((void)0);
  ((void)0);
  t = gettable(L, idx);
  luaH_setint(L, t, n, (&(L->top - 1)->val));
  ((((((&(L->top - 1)->val))->tt_) & (1 << 6)) &&
    ((((&(((union GCUnion *)((t)))->gc)))->marked) &
     ((1 << (5 /* object is black */)))) &&
    (((((((&(L->top - 1)->val))->value_).gc))->marked) &
     (((1 << (3 /* object is white (type 0) */)) |
       (1 << (4 /* object is white (type 1) */))))))
       ? luaC_barrierback_(L, (&(((union GCUnion *)((t)))->gc)))
       : ((void)((0))));
  L->top--;
  ((void)0);
}

extern void lua_rawsetp(lua_State *L, int idx, const void *p) {
  Table *t;
  TValue k, *slot;
  ((void)0);
  ((void)0);
  t = gettable(L, idx);
  {
    TValue *io = (&k);
    ((io)->value_).p = (((void *)((p))));
    ((io)->tt_ = (2));
  };
  slot = luaH_set(L, t, &k);
  {
    TValue *io1 = (slot);
    const TValue *io2 = ((&(L->top - 1)->val));
    io1->value_ = io2->value_;
    io1->tt_ = io2->tt_;
    (void)L;
    ((void)0);
    ((void)0);
  };
  ((((((&(L->top - 1)->val))->tt_) & (1 << 6)) &&
    ((((&(((union GCUnion *)((t)))->gc)))->marked) &
     ((1 << (5 /* object is black */)))) &&
    (((((((&(L->top - 1)->val))->value_).gc))->marked) &
     (((1 << (3 /* object is white (type 0) */)) |
       (1 << (4 /* object is white (type 1) */))))))
       ? luaC_barrierback_(L, (&(((union GCUnion *)((t)))->gc)))
       : ((void)((0))));
  L->top--;
  ((void)0);
}

extern int lua_setmetatable(lua_State *L, int objindex) {
  TValue *obj;
  Table *mt;
  ((void)0);
  ((void)0);
  obj = index2value(L, objindex);
  if (((((((((&(L->top - 1)->val)))->tt_)) & 0x0F)) == (0)))
    mt = ((void *)0);
  else {
    ((void)0);
    mt = ((&((((union GCUnion *)(((((&(L->top - 1)->val))->value_).gc))))->h)));
  }
  switch ((((((obj)->tt_)) & 0x0F))) {
  case 5: {
    ((&((((union GCUnion *)((((obj)->value_).gc))))->h)))->metatable = mt;
    if (mt) {
      ((((((((obj)->value_).gc))->marked) &
         ((1 << (5 /* object is black */)))) &&
        (((mt)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                            (1 << (4 /* object is white (type 1) */))))))
           ? luaC_barrier_(L,
                           (&(((union GCUnion *)(((((obj)->value_).gc))))->gc)),
                           (&(((union GCUnion *)((mt)))->gc)))
           : ((void)((0))));
      luaC_checkfinalizer(L, (((obj)->value_).gc), mt);
    }
    break;
  }
  case 7: {
    ((&((((union GCUnion *)((((obj)->value_).gc))))->u)))->metatable = mt;
    if (mt) {
      (((((((&((((union GCUnion *)((((obj)->value_).gc))))->u))))->marked) &
         ((1 << (5 /* object is black */)))) &&
        (((mt)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                            (1 << (4 /* object is white (type 1) */))))))
           ? luaC_barrier_(
                 L,
                 (&(((union GCUnion *)(((
                         (&((((union GCUnion *)((((obj)->value_).gc))))->u))))))
                        ->gc)),
                 (&(((union GCUnion *)((mt)))->gc)))
           : ((void)((0))));
      luaC_checkfinalizer(L, (((obj)->value_).gc), mt);
    }
    break;
  }
  default: {
    (L->l_G)->mt[(((((obj)->tt_)) & 0x0F))] = mt;
    break;
  }
  }
  L->top--;
  ((void)0);
  return 1;
}

extern int lua_setiuservalue(lua_State *L, int idx, int n) {
  TValue *o;
  int res;
  ((void)0);
  ((void)0);
  o = index2value(L, idx);
  ((void)0);
  if (!(((unsigned int)((n))) - 1u <
        ((unsigned int)((
            ((&((((union GCUnion *)((((o)->value_).gc))))->u)))->nuvalue)))))
    res = 0; /* 'n' not in [1, uvalue(o)->nuvalue] */
  else {
    {
      TValue *io1 =
          (&((&((((union GCUnion *)((((o)->value_).gc))))->u)))->uv[n - 1].uv);
      const TValue *io2 = ((&(L->top - 1)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    ((((((&(L->top - 1)->val))->tt_) & (1 << 6)) &&
      ((((((o)->value_).gc))->marked) & ((1 << (5 /* object is black */)))) &&
      (((((((&(L->top - 1)->val))->value_).gc))->marked) &
       (((1 << (3 /* object is white (type 0) */)) |
         (1 << (4 /* object is white (type 1) */))))))
         ? luaC_barrierback_(L, (((o)->value_).gc))
         : ((void)((0))));
    res = 1;
  }
  L->top--;
  ((void)0);
  return res;
}

/*
** 'load' and 'call' functions (run Lua code)
*/

extern void lua_callk(lua_State *L, int nargs, int nresults, lua_KContext ctx,
                      lua_KFunction k) {
  StkId func;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  func = L->top - (nargs + 1);
  if (k != ((void *)0) &&
      (((L)->nCcalls & 0xffff0000) == 0)) { /* need to prepare continuation? */
    L->ci->u.c.k = k;                       /* save continuation */
    L->ci->u.c.ctx = ctx;                   /* save context */
    luaD_call(L, func, nresults);           /* do the call */
  } else                                 /* no continuation or no yieldable */
    luaD_callnoyield(L, func, nresults); /* just do the call */
  {
    if ((nresults) <= (-1) && L->ci->top < L->top)
      L->ci->top = L->top;
  };
  ((void)0);
}

/*
** Execute a protected call.
*/
struct CallS { /* data to 'f_call' */
  StkId func;
  int nresults;
};

static void f_call(lua_State *L, void *ud) {
  struct CallS *c = ((struct CallS *)(ud));
  luaD_callnoyield(L, c->func, c->nresults);
}

extern int lua_pcallk(lua_State *L, int nargs, int nresults, int errfunc,
                      lua_KContext ctx, lua_KFunction k) {
  struct CallS c;
  int status;
  ptrdiff_t func;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if (errfunc == 0)
    func = 0;
  else {
    StkId o = index2stack(L, errfunc);
    ((void)0);
    func = ((char *)(o) - (char *)L->stack);
  }
  c.func = L->top - (nargs + 1); /* function to be called */
  if (k == ((void *)0) || !(((L)->nCcalls & 0xffff0000) ==
                            0)) { /* no continuation or no yieldable? */
    c.nresults = nresults;        /* do a 'conventional' protected call */
    status =
        luaD_pcall(L, f_call, &c, ((char *)(c.func) - (char *)L->stack), func);
  } else { /* prepare continuation (call is already protected by 'resume') */
    CallInfo *ci = L->ci;
    ci->u.c.k = k;     /* save continuation */
    ci->u.c.ctx = ctx; /* save context */
    /* save information for error recovery */
    ci->u2.funcidx = ((int)((((char *)(c.func) - (char *)L->stack))));
    ci->u.c.old_errfunc = L->errfunc;
    L->errfunc = func;
    ((ci->callstatus) =
         ((ci->callstatus) & ~(1 << 0) /* original value of 'allowhook' */) |
         (L->allowhook)); /* save value of 'allowhook' */
    ci->callstatus |=
        (1 << 3) /* call is a yieldable protected call */; /* function can do
                                                              error recovery */
    luaD_call(L, c.func, nresults);                        /* do the call */
    ci->callstatus &= ~(1 << 3) /* call is a yieldable protected call */;
    L->errfunc = ci->u.c.old_errfunc;
    status = 0; /* if it is here, there were no errors */
  }
  {
    if ((nresults) <= (-1) && L->ci->top < L->top)
      L->ci->top = L->top;
  };
  ((void)0);
  return status;
}

extern int lua_load(lua_State *L, lua_Reader reader, void *data,
                    const char *chunkname, const char *mode) {
  ZIO z;
  int status;
  ((void)0);
  if (!chunkname)
    chunkname = "?";
  luaZ_init(L, &z, reader, data);
  status = luaD_protectedparser(L, &z, chunkname, mode);
  if (status == 0) { /* no errors? */
    LClosure *f =
        ((&((((union GCUnion *)(((((&(L->top - 1)->val))->value_).gc))))
                ->cl.l)));   /* get newly created function */
    if (f->nupvalues >= 1) { /* does it have an upvalue? */
      /* get global table from registry */
      Table *reg = ((
          &((((union GCUnion *)((((&(L->l_G)->l_registry)->value_).gc))))->h)));
      const TValue *gt = luaH_getint(reg, 2);
      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */
      {
        TValue *io1 = (f->upvals[0]->v);
        const TValue *io2 = (gt);
        io1->value_ = io2->value_;
        io1->tt_ = io2->tt_;
        (void)L;
        ((void)0);
        ((void)0);
      };
      (((((gt)->tt_) & (1 << 6)) &&
        (((f->upvals[0])->marked) & ((1 << (5 /* object is black */)))) &&
        ((((((gt)->value_).gc))->marked) &
         (((1 << (3 /* object is white (type 0) */)) |
           (1 << (4 /* object is white (type 1) */))))))
           ? luaC_barrier_(L, (&(((union GCUnion *)((f->upvals[0])))->gc)),
                           (((gt)->value_).gc))
           : ((void)((0))));
    }
  }
  ((void)0);
  return status;
}

extern int lua_dump(lua_State *L, lua_Writer writer, void *data, int strip) {
  int status;
  TValue *o;
  ((void)0);
  ((void)0);
  o = (&(L->top - 1)->val);
  if (((((o))->tt_) == ((((6 | (1 << 4)) /* Lua closure */) | (1 << 6)))))
    status = luaU_dump(
        L, (((&((((union GCUnion *)((((o)->value_).gc))))->cl.l)))->p), writer,
        data, strip);
  else
    status = 1;
  ((void)0);
  return status;
}

extern int lua_status(lua_State *L) { return L->status; }

/*
** Garbage-collection function
*/
extern int lua_gc(lua_State *L, int what, ...) {
  va_list argp;
  int res = 0;
  global_State *g = (L->l_G);
  ((void)0);

  __builtin_va_start(argp, what);
  switch (what) {
  case 0: {
    g->gcrunning = 0;
    break;
  }
  case 1: {
    luaE_setdebt(g, 0);
    g->gcrunning = 1;
    break;
  }
  case 2: {
    luaC_fullgc(L, 0);
    break;
  }
  case 3: {
    /* GC values are expressed in Kbytes: #bytes/2^10 */
    res = ((int)((((lu_mem)((g)->totalbytes + (g)->GCdebt)) >> 10)));
    break;
  }
  case 4: {
    res = ((int)((((lu_mem)((g)->totalbytes + (g)->GCdebt)) & 0x3ff)));
    break;
  }
  case 5: {
    int data = __builtin_va_arg(argp, int);
    l_mem debt = 1; /* =1 to signal that it did an actual step */
    lu_byte oldrunning = g->gcrunning;
    g->gcrunning = 1; /* allow GC to run */
    if (data == 0) {
      luaE_setdebt(g, 0); /* do a basic step */
      luaC_step(L);
    } else { /* add 'data' to total debt */
      debt = ((l_mem)(data)) * 1024 + g->GCdebt;
      luaE_setdebt(g, debt);
      {
        if ((L->l_G)->GCdebt > 0) {
          (void)0;
          luaC_step(L);
          (void)0;
        };
        ((void)0);
      };
    }
    g->gcrunning = oldrunning;       /* restore previous state */
    if (debt > 0 && g->gcstate == 8) /* end of cycle? */
      res = 1;                       /* signal it */
    break;
  }
  case 6: {
    int data = __builtin_va_arg(argp, int);
    res = ((g->gcpause) * 4);
    ((g->gcpause) = (data) / 4);
    break;
  }
  case 7: {
    int data = __builtin_va_arg(argp, int);
    res = ((g->gcstepmul) * 4);
    ((g->gcstepmul) = (data) / 4);
    break;
  }
  case 9: {
    res = g->gcrunning;
    break;
  }
  case 10: {
    int minormul = __builtin_va_arg(argp, int);
    int majormul = __builtin_va_arg(argp, int);
    res =
        (g->gckind == 1 /* generational gc */ || g->lastatomic != 0) ? 10 : 11;
    if (minormul != 0)
      g->genminormul = minormul;
    if (majormul != 0)
      ((g->genmajormul) = (majormul) / 4);
    luaC_changemode(L, 1 /* generational gc */);
    break;
  }
  case 11: {
    int pause = __builtin_va_arg(argp, int);
    int stepmul = __builtin_va_arg(argp, int);
    int stepsize = __builtin_va_arg(argp, int);
    res =
        (g->gckind == 1 /* generational gc */ || g->lastatomic != 0) ? 10 : 11;
    if (pause != 0)
      ((g->gcpause) = (pause) / 4);
    if (stepmul != 0)
      ((g->gcstepmul) = (stepmul) / 4);
    if (stepsize != 0)
      g->gcstepsize = stepsize;
    luaC_changemode(L, 0 /* incremental gc */);
    break;
  }
  default:
    res = -1; /* invalid option */
  }

  __builtin_va_end(argp);
  ((void)0);
  return res;
}

/*
** miscellaneous functions
*/

extern int lua_error(lua_State *L) {
  ((void)0);
  ((void)0);
  luaG_errormsg(L);
  /* code unreachable; will unlock when control actually leaves the kernel */
  return 0; /* to avoid warnings */
}

extern int lua_next(lua_State *L, int idx) {
  Table *t;
  int more;
  ((void)0);
  ((void)0);
  t = gettable(L, idx);
  more = luaH_next(L, t, L->top - 1);
  if (more) {
    {
      L->top++;
      ((void)0);
    };
  } else         /* no more elements */
    L->top -= 1; /* remove key */
  ((void)0);
  return more;
}

extern void lua_toclose(lua_State *L, int idx) {
  int nresults;
  StkId o;
  ((void)0);
  o = index2stack(L, idx);
  nresults = L->ci->nresults;
  ((void)0);
  luaF_newtbcupval(L, o);              /* create new to-be-closed upvalue */
  if (!((nresults) < (-1)))            /* function not marked yet? */
    L->ci->nresults = (-(nresults)-3); /* mark it */
  ((void)0);
  ((void)0);
}

extern void lua_concat(lua_State *L, int n) {
  ((void)0);
  ((void)0);
  if (n >= 2) {
    luaV_concat(L, n);
  } else if (n == 0) { /* push empty string */
    {
      TValue *io = ((&(L->top)->val));
      TString *x_ = (luaS_newlstr(L, "", 0));
      ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
      ((io)->tt_ = (((x_->tt) | (1 << 6))));
      ((void)0);
    };
    {
      L->top++;
      ((void)0);
    };
  }
  /* else n == 1; nothing to do */
  {
    if ((L->l_G)->GCdebt > 0) {
      (void)0;
      luaC_step(L);
      (void)0;
    };
    ((void)0);
  };
  ((void)0);
}

extern void lua_len(lua_State *L, int idx) {
  TValue *t;
  ((void)0);
  t = index2value(L, idx);
  luaV_objlen(L, L->top, t);
  {
    L->top++;
    ((void)0);
  };
  ((void)0);
}

extern lua_Alloc lua_getallocf(lua_State *L, void **ud) {
  lua_Alloc f;
  ((void)0);
  if (ud)
    *ud = (L->l_G)->ud;
  f = (L->l_G)->frealloc;
  ((void)0);
  return f;
}

extern void lua_setallocf(lua_State *L, lua_Alloc f, void *ud) {
  ((void)0);
  (L->l_G)->ud = ud;
  (L->l_G)->frealloc = f;
  ((void)0);
}

void lua_setwarnf(lua_State *L, lua_WarnFunction f, void *ud) {
  ((void)0);
  (L->l_G)->ud_warn = ud;
  (L->l_G)->warnf = f;
  ((void)0);
}

void lua_warning(lua_State *L, const char *msg, int tocont) {
  ((void)0);
  luaE_warning(L, msg, tocont);
  ((void)0);
}

extern void *lua_newuserdatauv(lua_State *L, size_t size, int nuvalue) {
  Udata *u;
  ((void)0);
  ((void)0);
  u = luaS_newudata(L, size, nuvalue);
  {
    TValue *io = ((&(L->top)->val));
    Udata *x_ = (u);
    ((io)->value_).gc = (&(((union GCUnion *)((x_)))->gc));
    ((io)->tt_ = (((7) | (1 << 6))));
    ((void)0);
  };
  {
    L->top++;
    ((void)0);
  };
  {
    if ((L->l_G)->GCdebt > 0) {
      (void)0;
      luaC_step(L);
      (void)0;
    };
    ((void)0);
  };
  ((void)0);
  return (((char *)((u))) + (((u)->nuvalue) == 0
                                 ? __builtin_offsetof(Udata0, bindata)
                                 : __builtin_offsetof(Udata, uv) +
                                       (sizeof(UValue) * ((u)->nuvalue))));
}

static const char *aux_upvalue(TValue *fi, int n, TValue **val,
                               GCObject **owner) {
  switch (((((fi)->tt_)) & 0x3F)) {
  case (6 | (3 << 4)) /* C closure */: { /* C closure */
    CClosure *f = ((&((((union GCUnion *)((((fi)->value_).gc))))->cl.c)));
    if (!(((unsigned int)((n))) - 1u < ((unsigned int)((f->nupvalues)))))
      return ((void *)0); /* 'n' not in [1, f->nupvalues] */
    *val = &f->upvalue[n - 1];
    if (owner)
      *owner = (&(((union GCUnion *)((f)))->gc));
    return "";
  }
  case (6 | (1 << 4)) /* Lua closure */: { /* Lua closure */
    LClosure *f = ((&((((union GCUnion *)((((fi)->value_).gc))))->cl.l)));
    TString *name;
    Proto *p = f->p;
    if (!(((unsigned int)((n))) - 1u < ((unsigned int)((p->sizeupvalues)))))
      return ((void *)0); /* 'n' not in [1, p->sizeupvalues] */
    *val = f->upvals[n - 1]->v;
    if (owner)
      *owner = (&(((union GCUnion *)((f->upvals[n - 1])))->gc));
    name = p->upvalues[n - 1].name;
    return (name == ((void *)0)) ? "(no name)"
                                 : (((char *)(((name)))) + sizeof(TString));
  }
  default:
    return ((void *)0); /* not a closure */
  }
}

extern const char *lua_getupvalue(lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val = ((void *)0); /* to avoid warnings */
  ((void)0);
  name = aux_upvalue(index2value(L, funcindex), n, &val, ((void *)0));
  if (name) {
    {
      TValue *io1 = ((&(L->top)->val));
      const TValue *io2 = (val);
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    {
      L->top++;
      ((void)0);
    };
  }
  ((void)0);
  return name;
}

extern const char *lua_setupvalue(lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val = ((void *)0);     /* to avoid warnings */
  GCObject *owner = ((void *)0); /* to avoid warnings */
  TValue *fi;
  ((void)0);
  fi = index2value(L, funcindex);
  ((void)0);
  name = aux_upvalue(fi, n, &val, &owner);
  if (name) {
    L->top--;
    {
      TValue *io1 = (val);
      const TValue *io2 = ((&(L->top)->val));
      io1->value_ = io2->value_;
      io1->tt_ = io2->tt_;
      (void)L;
      ((void)0);
      ((void)0);
    };
    (((((val)->tt_) & (1 << 6)) &&
      (((owner)->marked) & ((1 << (5 /* object is black */)))) &&
      ((((((val)->value_).gc))->marked) &
       (((1 << (3 /* object is white (type 0) */)) |
         (1 << (4 /* object is white (type 1) */))))))
         ? luaC_barrier_(L, (&(((union GCUnion *)((owner)))->gc)),
                         (((val)->value_).gc))
         : ((void)((0))));
  }
  ((void)0);
  return name;
}

static UpVal **getupvalref(lua_State *L, int fidx, int n, LClosure **pf) {
  LClosure *f;
  TValue *fi = index2value(L, fidx);
  ((void)0);
  f = ((&((((union GCUnion *)((((fi)->value_).gc))))->cl.l)));
  ((void)0);
  if (pf)
    *pf = f;
  return &f->upvals[n - 1]; /* get its upvalue pointer */
}

extern void *lua_upvalueid(lua_State *L, int fidx, int n) {
  TValue *fi = index2value(L, fidx);
  switch (((((fi)->tt_)) & 0x3F)) {
  case (6 | (1 << 4)) /* Lua closure */: { /* lua closure */
    return *getupvalref(L, fidx, n, ((void *)0));
  }
  case (6 | (3 << 4)) /* C closure */: { /* C closure */
    CClosure *f = ((&((((union GCUnion *)((((fi)->value_).gc))))->cl.c)));
    ((void)0);
    return &f->upvalue[n - 1];
  }
  default: {
    ((void)0);
    return ((void *)0);
  }
  }
}

extern void lua_upvaluejoin(lua_State *L, int fidx1, int n1, int fidx2,
                            int n2) {
  LClosure *f1;
  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);
  UpVal **up2 = getupvalref(L, fidx2, n2, ((void *)0));
  *up1 = *up2;
  (((((f1)->marked) & ((1 << (5 /* object is black */)))) &&
    (((*up1)->marked) & (((1 << (3 /* object is white (type 0) */)) |
                          (1 << (4 /* object is white (type 1) */))))))
       ? luaC_barrier_(L, (&(((union GCUnion *)((f1)))->gc)),
                       (&(((union GCUnion *)((*up1)))->gc)))
       : ((void)((0))));
}

/* auxiliary library -- used by all */
/*
** $Id: lauxlib.c $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** This file uses only the official API of Lua.
** Any function declared here could be written as an application function.
*/

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/* global table */

/* extra error code for 'luaL_loadfilex' */

/* key, in the registry, for table of loaded modules */

/* key, in the registry, for table of preloaded loaders */

typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;

extern void(luaL_checkversion_)(lua_State *L, lua_Number ver, size_t sz);

extern int(luaL_getmetafield)(lua_State *L, int obj, const char *e);
extern int(luaL_callmeta)(lua_State *L, int obj, const char *e);
extern const char *(luaL_tolstring)(lua_State *L, int idx, size_t *len);
extern int(luaL_argerror)(lua_State *L, int arg, const char *extramsg);
extern int(luaL_typeerror)(lua_State *L, int arg, const char *tname);
extern const char *(luaL_checklstring)(lua_State *L, int arg, size_t *l);
extern const char *(luaL_optlstring)(lua_State *L, int arg, const char *def,
                                     size_t *l);
extern lua_Number(luaL_checknumber)(lua_State *L, int arg);
extern lua_Number(luaL_optnumber)(lua_State *L, int arg, lua_Number def);

extern lua_Integer(luaL_checkinteger)(lua_State *L, int arg);
extern lua_Integer(luaL_optinteger)(lua_State *L, int arg, lua_Integer def);

extern void(luaL_checkstack)(lua_State *L, int sz, const char *msg);
extern void(luaL_checktype)(lua_State *L, int arg, int t);
extern void(luaL_checkany)(lua_State *L, int arg);

extern int(luaL_newmetatable)(lua_State *L, const char *tname);
extern void(luaL_setmetatable)(lua_State *L, const char *tname);
extern void *(luaL_testudata)(lua_State *L, int ud, const char *tname);
extern void *(luaL_checkudata)(lua_State *L, int ud, const char *tname);

extern void(luaL_where)(lua_State *L, int lvl);
extern int(luaL_error)(lua_State *L, const char *fmt, ...);

extern int(luaL_checkoption)(lua_State *L, int arg, const char *def,
                             const char *const lst[]);

extern int(luaL_fileresult)(lua_State *L, int stat, const char *fname);
extern int(luaL_execresult)(lua_State *L, int stat);

/* predefined references */

extern int(luaL_ref)(lua_State *L, int t);
extern void(luaL_unref)(lua_State *L, int t, int ref);

extern int(luaL_loadfilex)(lua_State *L, const char *filename,
                           const char *mode);

extern int(luaL_loadbufferx)(lua_State *L, const char *buff, size_t sz,
                             const char *name, const char *mode);
extern int(luaL_loadstring)(lua_State *L, const char *s);

extern lua_State *(luaL_newstate)(void);

extern lua_Integer(luaL_len)(lua_State *L, int idx);

extern const char *(luaL_gsub)(lua_State *L, const char *s, const char *p,
                               const char *r);

extern void(luaL_setfuncs)(lua_State *L, const luaL_Reg *l, int nup);

extern int(luaL_getsubtable)(lua_State *L, int idx, const char *fname);

extern void(luaL_traceback)(lua_State *L, lua_State *L1, const char *msg,
                            int level);

extern void(luaL_requiref)(lua_State *L, const char *modname,
                           lua_CFunction openf, int glb);

/*
** ===============================================================
** some useful macros
** ===============================================================
*/
/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/

typedef struct luaL_Buffer {
  char *b;     /* buffer address */
  size_t size; /* buffer size */
  size_t n;    /* number of characters in buffer */
  lua_State *L;
  union {
    lua_Number n;
    double u;
    void *s;
    lua_Integer i;
    long l; /* ensure maximum alignment for buffer */
    char b[(
        (int)(16 * sizeof(void *) * sizeof(lua_Number)))]; /* initial buffer */
  } init;
} luaL_Buffer;
extern void(luaL_buffinit)(lua_State *L, luaL_Buffer *B);
extern char *(luaL_prepbuffsize)(luaL_Buffer *B, size_t sz);
extern void(luaL_addlstring)(luaL_Buffer *B, const char *s, size_t l);
extern void(luaL_addstring)(luaL_Buffer *B, const char *s);
extern void(luaL_addvalue)(luaL_Buffer *B);
extern void(luaL_pushresult)(luaL_Buffer *B);
extern void(luaL_pushresultsize)(luaL_Buffer *B, size_t sz);
extern char *(luaL_buffinitsize)(lua_State *L, luaL_Buffer *B, size_t sz);

/* }====================================================== */

/*
** {======================================================
** File handles for IO library
** =======================================================
*/

/*
** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and
** initial structure 'luaL_Stream' (it may contain other fields
** after that initial structure).
*/

typedef struct luaL_Stream {
  FILE *f;              /* stream (NULL for incompletely created streams) */
  lua_CFunction closef; /* to close stream (NULL for closed streams) */
} luaL_Stream;

/* }====================================================== */

/*
** {==================================================================
** "Abstraction Layer" for basic report of messages and errors
** ===================================================================
*/

/* print a string */

/* print a newline and flush the output */

/* print an error message */

/* }================================================================== */

/*
** {============================================================
** Compatibility with deprecated conversions
** =============================================================
*/
/* }============================================================ */
/*
** {======================================================
** Traceback
** =======================================================
*/

/*
** search for 'objidx' in table at index -1.
** return 1 + string at top if find a good name.
*/
static int findfield(lua_State *L, int objidx, int level) {
  if (level == 0 || !(lua_type(L, (-1)) == 5))
    return 0;                            /* not found */
  lua_pushnil(L);                        /* start 'next' loop */
  while (lua_next(L, -2)) {              /* for each pair in table */
    if (lua_type(L, -2) == 4) {          /* ignore non-string keys */
      if (lua_rawequal(L, objidx, -1)) { /* found object? */
        lua_settop(L, -(1) - 1);         /* remove value (but keep name) */
        return 1;
      } else if (findfield(L, objidx, level - 1)) { /* try recursively */
        (lua_rotate(L, (-2), -1),
         lua_settop(L, -(1) - 1)); /* remove table (but keep name) */
        lua_pushstring(L, ""
                          ".");
        lua_rotate(L, (-2), 1); /* place '.' between the two names */
        lua_concat(L, 3);
        return 1;
      }
    }
    lua_settop(L, -(1) - 1); /* remove value */
  }
  return 0; /* not found */
}

/*
** Search for a name for a function in all loaded modules
*/
static int pushglobalfuncname(lua_State *L, lua_Debug *ar) {
  int top = lua_gettop(L);
  lua_getinfo(L, "f", ar); /* push function */
  lua_getfield(L, (-1000000 - 1000), "_LOADED");
  if (findfield(L, top + 1, 2)) {
    const char *name = lua_tolstring(L, (-1), ((void *)0));
    if (strncmp(name,
                "_G"
                ".",
                3) == 0) {         /* name start with '_G.'? */
      lua_pushstring(L, name + 3); /* push name without prefix */
      (lua_rotate(L, (-2), -1),
       lua_settop(L, -(1) - 1)); /* remove original name */
    }
    lua_copy(L, -1, top + 1); /* move name to proper place */
    lua_settop(L, -(2) - 1);  /* remove pushed values */
    return 1;
  } else {
    lua_settop(L, top); /* remove function and global table */
    return 0;
  }
}

static void pushfuncname(lua_State *L, lua_Debug *ar) {
  if (pushglobalfuncname(L, ar)) { /* try first a global name */
    lua_pushfstring(L, "function '%s'", lua_tolstring(L, (-1), ((void *)0)));
    (lua_rotate(L, (-2), -1), lua_settop(L, -(1) - 1)); /* remove name */
  } else if (*ar->namewhat != '\0') /* is there a name from code? */
    lua_pushfstring(L, "%s '%s'", ar->namewhat, ar->name); /* use it */
  else if (*ar->what == 'm')                               /* main? */
    lua_pushstring(L, ""
                      "main chunk");
  else if (*ar->what != 'C') /* for Lua functions, use <file:line> */
    lua_pushfstring(L, "function <%s:%d>", ar->short_src, ar->linedefined);
  else /* nothing left... */
    lua_pushstring(L, ""
                      "?");
}

static int lastlevel(lua_State *L) {
  lua_Debug ar;
  int li = 1, le = 1;
  /* find an upper bound */
  while (lua_getstack(L, le, &ar)) {
    li = le;
    le *= 2;
  }
  /* do a binary search */
  while (li < le) {
    int m = (li + le) / 2;
    if (lua_getstack(L, m, &ar))
      li = m + 1;
    else
      le = m;
  }
  return le - 1;
}

extern void luaL_traceback(lua_State *L, lua_State *L1, const char *msg,
                           int level) {
  lua_Debug ar;
  int top = lua_gettop(L);
  int last = lastlevel(L1);
  int n1 = (last - level > 10 /* size of the first part of the stack */ +
                               11 /* size of the second part of the stack */)
               ? 10 /* size of the first part of the stack */
               : -1;
  if (msg)
    lua_pushfstring(L, "%s\n", msg);
  luaL_checkstack(L, 10, ((void *)0));
  lua_pushstring(L, ""
                    "stack traceback:");
  while (lua_getstack(L1, level++, &ar)) {
    if (n1-- == 0) { /* too many levels? */
      lua_pushstring(L, ""
                        "\n\t..."); /* add a '...' */
      level = last - 11 /* size of the second part of the stack */ +
              1; /* and skip to last ones */
    } else {
      lua_getinfo(L1, "Slnt", &ar);
      lua_pushfstring(L, "\n\t%s:", ar.short_src);
      if (ar.currentline > 0)
        lua_pushfstring(L, "%d:", ar.currentline);
      lua_pushstring(L, ""
                        " in ");
      pushfuncname(L, &ar);
      if (ar.istailcall)
        lua_pushstring(L, ""
                          "\n\t(...tail calls...)");
      lua_concat(L, lua_gettop(L) - top);
    }
  }
  lua_concat(L, lua_gettop(L) - top);
}

/* }====================================================== */

/*
** {======================================================
** Error-report functions
** =======================================================
*/

extern int luaL_argerror(lua_State *L, int arg, const char *extramsg) {
  lua_Debug ar;
  if (!lua_getstack(L, 0, &ar)) /* no stack frame? */
    return luaL_error(L, "bad argument #%d (%s)", arg, extramsg);
  lua_getinfo(L, "n", &ar);
  if (strcmp(ar.namewhat, "method") == 0) {
    arg--;        /* do not count 'self' */
    if (arg == 0) /* error is in the self argument itself? */
      return luaL_error(L, "calling '%s' on bad self (%s)", ar.name, extramsg);
  }
  if (ar.name == ((void *)0))
    ar.name = (pushglobalfuncname(L, &ar)) ? lua_tolstring(L, (-1), ((void *)0))
                                           : "?";
  return luaL_error(L, "bad argument #%d to '%s' (%s)", arg, ar.name, extramsg);
}

int luaL_typeerror(lua_State *L, int arg, const char *tname) {
  const char *msg;
  const char *typearg; /* name for the type of the actual argument */
  if (luaL_getmetafield(L, arg, "__name") == 4)
    typearg = lua_tolstring(L, (-1), ((void *)0)); /* use the given type name */
  else if (lua_type(L, arg) == 2)
    typearg = "light userdata"; /* special name for messages */
  else
    typearg = lua_typename(L, lua_type(L, (arg))); /* standard name */
  msg = lua_pushfstring(L, "%s expected, got %s", tname, typearg);
  return luaL_argerror(L, arg, msg);
}

static void tag_error(lua_State *L, int arg, int tag) {
  luaL_typeerror(L, arg, lua_typename(L, tag));
}

/*
** The use of 'lua_pushfstring' ensures this function does not
** need reserved stack space when called.
*/
extern void luaL_where(lua_State *L, int level) {
  lua_Debug ar;
  if (lua_getstack(L, level, &ar)) { /* check function at level */
    lua_getinfo(L, "Sl", &ar);       /* get info about it */
    if (ar.currentline > 0) {        /* is there info? */
      lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
      return;
    }
  }
  lua_pushfstring(L, ""); /* else, no information available... */
}

/*
** Again, the use of 'lua_pushvfstring' ensures this function does
** not need reserved stack space when called. (At worst, it generates
** an error with "stack overflow" instead of the given message.)
*/
extern int luaL_error(lua_State *L, const char *fmt, ...) {
  va_list argp;

  __builtin_va_start(argp, fmt);
  luaL_where(L, 1);
  lua_pushvfstring(L, fmt, argp);

  __builtin_va_end(argp);
  lua_concat(L, 2);
  return lua_error(L);
}

extern int luaL_fileresult(lua_State *L, int stat, const char *fname) {
  int en = (*__errno()); /* calls to Lua API may change this value */
  if (stat) {
    lua_pushboolean(L, 1);
    return 1;
  } else {
    lua_pushnil(L);
    if (fname)
      lua_pushfstring(L, "%s: %s", fname, strerror(en));
    else
      lua_pushstring(L, strerror(en));
    lua_pushinteger(L, en);
    return 3;
  }
}
extern int luaL_execresult(lua_State *L, int stat) {
  const char *what = "exit"; /* type of termination */
  if (stat == -1)            /* error? */
    return luaL_fileresult(L, 0, ((void *)0));
  else {
    /* no op */;                   /* interpret result */
    if (*what == 'e' && stat == 0) /* successful termination? */
      lua_pushboolean(L, 1);
    else
      lua_pushnil(L);
    lua_pushstring(L, what);
    lua_pushinteger(L, stat);
    return 3; /* return true/nil,what,code */
  }
}

/* }====================================================== */

/*
** {======================================================
** Userdata's metatable manipulation
** =======================================================
*/

extern int luaL_newmetatable(lua_State *L, const char *tname) {
  if ((lua_getfield(L, (-1000000 - 1000), (tname))) !=
      0)      /* name already in use? */
    return 0; /* leave previous value on top, but return 0 */
  lua_settop(L, -(1) - 1);
  lua_createtable(L, 0, 2); /* create metatable */
  lua_pushstring(L, tname);
  lua_setfield(L, -2, "__name"); /* metatable.__name = tname */
  lua_pushvalue(L, -1);
  lua_setfield(L, (-1000000 - 1000), tname); /* registry.name = metatable */
  return 1;
}

extern void luaL_setmetatable(lua_State *L, const char *tname) {
  (lua_getfield(L, (-1000000 - 1000), (tname)));
  lua_setmetatable(L, -2);
}

extern void *luaL_testudata(lua_State *L, int ud, const char *tname) {
  void *p = lua_touserdata(L, ud);
  if (p != ((void *)0)) {          /* value is a userdata? */
    if (lua_getmetatable(L, ud)) { /* does it have a metatable? */
      (lua_getfield(L, (-1000000 - 1000), (tname))); /* get correct metatable */
      if (!lua_rawequal(L, -1, -2))                  /* not the same? */
        p = ((void *)0);       /* value is a userdata with wrong metatable */
      lua_settop(L, -(2) - 1); /* remove both metatables */
      return p;
    }
  }
  return ((void *)0); /* value is not a userdata with a metatable */
}

extern void *luaL_checkudata(lua_State *L, int ud, const char *tname) {
  void *p = luaL_testudata(L, ud, tname);
  ((void)((p != ((void *)0)) || luaL_typeerror(L, (ud), (tname))));
  return p;
}

/* }====================================================== */

/*
** {======================================================
** Argument check functions
** =======================================================
*/

extern int luaL_checkoption(lua_State *L, int arg, const char *def,
                            const char *const lst[]) {
  const char *name = (def) ? (luaL_optlstring(L, (arg), (def), ((void *)0)))
                           : (luaL_checklstring(L, (arg), ((void *)0)));
  int i;
  for (i = 0; lst[i]; i++)
    if (strcmp(lst[i], name) == 0)
      return i;
  return luaL_argerror(L, arg, lua_pushfstring(L, "invalid option '%s'", name));
}

/*
** Ensures the stack has at least 'space' extra slots, raising an error
** if it cannot fulfill the request. (The error handling needs a few
** extra slots to format the error message. In case of an error without
** this extra space, Lua will generate the same 'stack overflow' error,
** but without 'msg'.)
*/
extern void luaL_checkstack(lua_State *L, int space, const char *msg) {
  if (!lua_checkstack(L, space)) {
    if (msg)
      luaL_error(L, "stack overflow (%s)", msg);
    else
      luaL_error(L, "stack overflow");
  }
}

extern void luaL_checktype(lua_State *L, int arg, int t) {
  if (lua_type(L, arg) != t)
    tag_error(L, arg, t);
}

extern void luaL_checkany(lua_State *L, int arg) {
  if (lua_type(L, arg) == (-1))
    luaL_argerror(L, arg, "value expected");
}

extern const char *luaL_checklstring(lua_State *L, int arg, size_t *len) {
  const char *s = lua_tolstring(L, arg, len);
  if (!s)
    tag_error(L, arg, 4);
  return s;
}

extern const char *luaL_optlstring(lua_State *L, int arg, const char *def,
                                   size_t *len) {
  if ((lua_type(L, (arg)) <= 0)) {
    if (len)
      *len = (def ? strlen(def) : 0);
    return def;
  } else
    return luaL_checklstring(L, arg, len);
}

extern lua_Number luaL_checknumber(lua_State *L, int arg) {
  int isnum;
  lua_Number d = lua_tonumberx(L, arg, &isnum);
  if (!isnum)
    tag_error(L, arg, 3);
  return d;
}

extern lua_Number luaL_optnumber(lua_State *L, int arg, lua_Number def) {
  return ((lua_type(L, ((arg))) <= 0) ? (def) : luaL_checknumber(L, (arg)));
}

static void interror(lua_State *L, int arg) {
  if (lua_isnumber(L, arg))
    luaL_argerror(L, arg, "number has no integer representation");
  else
    tag_error(L, arg, 3);
}

extern lua_Integer luaL_checkinteger(lua_State *L, int arg) {
  int isnum;
  lua_Integer d = lua_tointegerx(L, arg, &isnum);
  if (!isnum) {
    interror(L, arg);
  }
  return d;
}

extern lua_Integer luaL_optinteger(lua_State *L, int arg, lua_Integer def) {
  return ((lua_type(L, ((arg))) <= 0) ? (def) : luaL_checkinteger(L, (arg)));
}

/* }====================================================== */

/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/

/* userdata to box arbitrary data */
typedef struct UBox {
  void *box;
  size_t bsize;
} UBox;

static void *resizebox(lua_State *L, int idx, size_t newsize) {
  void *ud;
  lua_Alloc allocf = lua_getallocf(L, &ud);
  UBox *box = (UBox *)lua_touserdata(L, idx);
  void *temp = allocf(ud, box->box, box->bsize, newsize);
  if (temp == ((void *)0) && newsize > 0) /* allocation error? */
    luaL_error(L, "not enough memory for buffer allocation");
  box->box = temp;
  box->bsize = newsize;
  return temp;
}

static int boxgc(lua_State *L) {
  resizebox(L, 1, 0);
  return 0;
}

static const luaL_Reg boxmt[] = {/* box metamethods */
                                 {"__gc", boxgc},
                                 {"__close", boxgc},
                                 {((void *)0), ((void *)0)}};

static void newbox(lua_State *L) {
  UBox *box = (UBox *)lua_newuserdatauv(L, sizeof(UBox), 0);
  box->box = ((void *)0);
  box->bsize = 0;
  if (luaL_newmetatable(L, "_UBOX*")) /* creating metatable? */
    luaL_setfuncs(L, boxmt, 0);       /* set its metamethods */
  lua_setmetatable(L, -2);
}

/*
** check whether buffer is using a userdata on the stack as a temporary
** buffer
*/

/*
** Compute new size for buffer 'B', enough to accommodate extra 'sz'
** bytes.
*/
static size_t newbuffsize(luaL_Buffer *B, size_t sz) {
  size_t newsize = B->size * 2;           /* double buffer size */
  if (((size_t)(~(size_t)0)) - sz < B->n) /* overflow in (B->n + sz)? */
    return luaL_error(B->L, "buffer too large");
  if (newsize < B->n + sz) /* double is not big enough? */
    newsize = B->n + sz;
  return newsize;
}

/*
** Returns a pointer to a free area with at least 'sz' bytes in buffer
** 'B'. 'boxidx' is the relative position in the stack where the
** buffer's box is or should be.
*/
static char *prepbuffsize(luaL_Buffer *B, size_t sz, int boxidx) {
  if (B->size - B->n >= sz) /* enough space? */
    return B->b + B->n;
  else {
    lua_State *L = B->L;
    char *newbuff;
    size_t newsize = newbuffsize(B, sz);
    /* create larger buffer */
    if (((B)->b != (B)->init.b)) /* buffer already has a box? */
      newbuff = (char *)resizebox(L, boxidx, newsize); /* resize it */
    else {                                             /* no box yet */
      lua_pushnil(L); /* reserve slot for final result */
      newbox(L);      /* create a new box */
      /* move box (and slot) to its intended position */
      lua_rotate(L, boxidx - 1, 2);
      lua_toclose(L, boxidx);
      newbuff = (char *)resizebox(L, boxidx, newsize);
      memcpy(newbuff, B->b, B->n * sizeof(char)); /* copy original content */
    }
    B->b = newbuff;
    B->size = newsize;
    return newbuff + B->n;
  }
}

/*
** returns a pointer to a free area with at least 'sz' bytes
*/
extern char *luaL_prepbuffsize(luaL_Buffer *B, size_t sz) {
  return prepbuffsize(B, sz, -1);
}

extern void luaL_addlstring(luaL_Buffer *B, const char *s, size_t l) {
  if (l > 0) { /* avoid 'memcpy' when 's' can be NULL */
    char *b = prepbuffsize(B, l, -1);
    memcpy(b, s, l * sizeof(char));
    ((B)->n += (l));
  }
}

extern void luaL_addstring(luaL_Buffer *B, const char *s) {
  luaL_addlstring(B, s, strlen(s));
}

extern void luaL_pushresult(luaL_Buffer *B) {
  lua_State *L = B->L;
  lua_pushlstring(L, B->b, B->n);
  if (((B)->b != (B)->init.b)) {
    lua_copy(L, -1, -3);     /* move string to reserved slot */
    lua_settop(L, -(2) - 1); /* pop string and box (closing the box) */
  }
}

extern void luaL_pushresultsize(luaL_Buffer *B, size_t sz) {
  ((B)->n += (sz));
  luaL_pushresult(B);
}

/*
** 'luaL_addvalue' is the only function in the Buffer system where the
** box (if existent) is not on the top of the stack. So, instead of
** calling 'luaL_addlstring', it replicates the code using -2 as the
** last argument to 'prepbuffsize', signaling that the box is (or will
** be) bellow the string being added to the buffer. (Box creation can
** trigger an emergency GC, so we should not remove the string from the
** stack before we have the space guaranteed.)
*/
extern void luaL_addvalue(luaL_Buffer *B) {
  lua_State *L = B->L;
  size_t len;
  const char *s = lua_tolstring(L, -1, &len);
  char *b = prepbuffsize(B, len, -2);
  memcpy(b, s, len * sizeof(char));
  ((B)->n += (len));
  lua_settop(L, -(1) - 1); /* pop string */
}

extern void luaL_buffinit(lua_State *L, luaL_Buffer *B) {
  B->L = L;
  B->b = B->init.b;
  B->n = 0;
  B->size = ((int)(16 * sizeof(void *) * sizeof(lua_Number)));
}

extern char *luaL_buffinitsize(lua_State *L, luaL_Buffer *B, size_t sz) {
  luaL_buffinit(L, B);
  return prepbuffsize(B, sz, -1);
}

/* }====================================================== */

/*
** {======================================================
** Reference system
** =======================================================
*/

/* index of free-list header */

extern int luaL_ref(lua_State *L, int t) {
  int ref;
  if ((lua_type(L, (-1)) == 0)) {
    lua_settop(L, -(1) - 1); /* remove from stack */
    return (-1);             /* 'nil' has a unique fixed reference */
  }
  t = lua_absindex(L, t);
  lua_rawgeti(L, t, 0);                            /* get first free element */
  ref = (int)lua_tointegerx(L, (-1), ((void *)0)); /* ref = t[freelist] */
  lua_settop(L, -(1) - 1);                         /* remove it from stack */
  if (ref != 0) {                                  /* any free element? */
    lua_rawgeti(L, t, ref);                        /* remove it from list */
    lua_rawseti(L, t, 0);                          /* (t[freelist] = t[ref]) */
  } else                                           /* no free elements */
    ref = (int)lua_rawlen(L, t) + 1;               /* get a new reference */
  lua_rawseti(L, t, ref);
  return ref;
}

extern void luaL_unref(lua_State *L, int t, int ref) {
  if (ref >= 0) {
    t = lua_absindex(L, t);
    lua_rawgeti(L, t, 0);
    lua_rawseti(L, t, ref); /* t[ref] = t[freelist] */
    lua_pushinteger(L, ref);
    lua_rawseti(L, t, 0); /* t[freelist] = ref */
  }
}

/* }====================================================== */

/*
** {======================================================
** Load functions
** =======================================================
*/

typedef struct LoadF {
  int n;           /* number of pre-read characters */
  FILE *f;         /* file being read */
  char buff[1024]; /* area for reading file */
} LoadF;

static const char *getF(lua_State *L, void *ud, size_t *size) {
  LoadF *lf = (LoadF *)ud;
  (void)L;         /* not used */
  if (lf->n > 0) { /* are there pre-read characters to be read? */
    *size = lf->n; /* return them (chars already in buffer) */
    lf->n = 0;     /* no more pre-read characters */
  } else {         /* read a block from file */
    /* 'fread' can return > 0 *and* set the EOF flag. If next call to
       'getF' called 'fread', it might still wait for user input.
       The next check avoids this problem. */
    if (((int)(((lf->f)->_flags & 0x0020 /* found EOF */) != 0)))
      return ((void *)0);
    *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f); /* read block */
  }
  return lf->buff;
}

static int errfile(lua_State *L, const char *what, int fnameindex) {
  const char *serr = strerror((*__errno()));
  const char *filename = lua_tolstring(L, (fnameindex), ((void *)0)) + 1;
  lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
  (lua_rotate(L, (fnameindex), -1), lua_settop(L, -(1) - 1));
  return (5 + 1);
}

static int skipBOM(LoadF *lf) {
  const char *p = "\xEF\xBB\xBF"; /* UTF-8 BOM mark */
  int c;
  lf->n = 0;
  do {
    c = getc(lf->f);
    if (c == (-1) || c != *(const unsigned char *)p++)
      return c;
    lf->buff[lf->n++] = c; /* to be read by the parser */
  } while (*p != '\0');
  lf->n = 0;          /* prefix matched; discard it */
  return getc(lf->f); /* return next character */
}

/*
** reads the first character of file 'f' and skips an optional BOM mark
** in its beginning plus its first line if it starts with '#'. Returns
** true if it skipped the first line.  In any case, '*cp' has the
** first "valid" character of the file (after the optional BOM and
** a first-line comment).
*/
static int skipcomment(LoadF *lf, int *cp) {
  int c = *cp = skipBOM(lf);
  if (c == '#') { /* first line is a comment (Unix exec. file)? */
    do {          /* skip first line */
      c = getc(lf->f);
    } while (c != (-1) && c != '\n');
    *cp = getc(lf->f); /* skip end-of-line, if present */
    return 1;          /* there was a comment */
  } else
    return 0; /* no comment */
}

extern int luaL_loadfilex(lua_State *L, const char *filename,
                          const char *mode) {
  LoadF lf;
  int status, readstatus;
  int c;
  int fnameindex = lua_gettop(L) + 1; /* index of filename on the stack */
  if (filename == ((void *)0)) {
    lua_pushstring(L, ""
                      "=stdin");
    lf.f = ((__getreent())->_stdin);
  } else {
    lua_pushfstring(L, "@%s", filename);
    lf.f = fopen(filename, "r");
    if (lf.f == ((void *)0))
      return errfile(L, "open", fnameindex);
  }
  if (skipcomment(&lf, &c))               /* read initial portion */
    lf.buff[lf.n++] = '\n';               /* add line to correct line numbers */
  if (c == "\x1bLua"[0] && filename) {    /* binary file? */
    lf.f = freopen(filename, "rb", lf.f); /* reopen in binary mode */
    if (lf.f == ((void *)0))
      return errfile(L, "reopen", fnameindex);
    skipcomment(&lf, &c); /* re-read initial portion */
  }
  if (c != (-1))
    lf.buff[lf.n++] = c; /* 'c' is the first character of the stream */
  status = lua_load(L, getF, &lf, lua_tolstring(L, (-1), ((void *)0)), mode);
  readstatus = ((int)(((lf.f)->_flags & 0x0040 /* found error */) != 0));
  if (filename)
    fclose(lf.f); /* close file (even in case of errors) */
  if (readstatus) {
    lua_settop(L, fnameindex); /* ignore results from 'lua_load' */
    return errfile(L, "read", fnameindex);
  }
  (lua_rotate(L, (fnameindex), -1), lua_settop(L, -(1) - 1));
  return status;
}

typedef struct LoadS {
  const char *s;
  size_t size;
} LoadS;

static const char *getS(lua_State *L, void *ud, size_t *size) {
  LoadS *ls = (LoadS *)ud;
  (void)L; /* not used */
  if (ls->size == 0)
    return ((void *)0);
  *size = ls->size;
  ls->size = 0;
  return ls->s;
}

extern int luaL_loadbufferx(lua_State *L, const char *buff, size_t size,
                            const char *name, const char *mode) {
  LoadS ls;
  ls.s = buff;
  ls.size = size;
  return lua_load(L, getS, &ls, name, mode);
}

extern int luaL_loadstring(lua_State *L, const char *s) {
  return luaL_loadbufferx(L, s, strlen(s), s, ((void *)0));
}

/* }====================================================== */

extern int luaL_getmetafield(lua_State *L, int obj, const char *event) {
  if (!lua_getmetatable(L, obj)) /* no metatable? */
    return 0;
  else {
    int tt;
    lua_pushstring(L, event);
    tt = lua_rawget(L, -2);
    if (tt == 0)               /* is metafield nil? */
      lua_settop(L, -(2) - 1); /* remove metatable and metafield */
    else
      (lua_rotate(L, (-2), -1),
       lua_settop(L, -(1) - 1)); /* remove only metatable */
    return tt;                   /* return metafield type */
  }
}

extern int luaL_callmeta(lua_State *L, int obj, const char *event) {
  obj = lua_absindex(L, obj);
  if (luaL_getmetafield(L, obj, event) == 0) /* no metafield? */
    return 0;
  lua_pushvalue(L, obj);
  lua_callk(L, (1), (1), 0, ((void *)0));
  return 1;
}

extern lua_Integer luaL_len(lua_State *L, int idx) {
  lua_Integer l;
  int isnum;
  lua_len(L, idx);
  l = lua_tointegerx(L, -1, &isnum);
  if (!isnum)
    luaL_error(L, "object length is not an integer");
  lua_settop(L, -(1) - 1); /* remove object */
  return l;
}

extern const char *luaL_tolstring(lua_State *L, int idx, size_t *len) {
  if (luaL_callmeta(L, idx, "__tostring")) { /* metafield? */
    if (!lua_isstring(L, -1))
      luaL_error(L, "'__tostring' must return a string");
  } else {
    switch (lua_type(L, idx)) {
    case 3: {
      if (lua_isinteger(L, idx))
        lua_pushfstring(L, "%I",
                        (long long)lua_tointegerx(L, (idx), ((void *)0)));
      else
        lua_pushfstring(L, "%f", (double)lua_tonumberx(L, (idx), ((void *)0)));
      break;
    }
    case 4:
      lua_pushvalue(L, idx);
      break;
    case 1:
      lua_pushstring(L, (lua_toboolean(L, idx) ? "true" : "false"));
      break;
    case 0:
      lua_pushstring(L, ""
                        "nil");
      break;
    default: {
      int tt = luaL_getmetafield(L, idx, "__name"); /* try name */
      const char *kind = (tt == 4) ? lua_tolstring(L, (-1), ((void *)0))
                                   : lua_typename(L, lua_type(L, (idx)));
      lua_pushfstring(L, "%s: %p", kind, lua_topointer(L, idx));
      if (tt != 0)
        (lua_rotate(L, (-2), -1),
         lua_settop(L, -(1) - 1)); /* remove '__name' */
      break;
    }
    }
  }
  return lua_tolstring(L, -1, len);
}

/*
** set functions from list 'l' into table at top - 'nup'; each
** function gets the 'nup' elements at the top as upvalues.
** Returns with only the table at the stack.
*/
extern void luaL_setfuncs(lua_State *L, const luaL_Reg *l, int nup) {
  luaL_checkstack(L, nup, "too many upvalues");
  for (; l->name != ((void *)0);
       l++) { /* fill the table with given functions */
    int i;
    for (i = 0; i < nup; i++) /* copy upvalues to the top */
      lua_pushvalue(L, -nup);
    lua_pushcclosure(L, l->func, nup); /* closure with those upvalues */
    lua_setfield(L, -(nup + 2), l->name);
  }
  lua_settop(L, -(nup)-1); /* remove upvalues */
}

/*
** ensure that stack[idx][fname] has a table and push that table
** into the stack
*/
extern int luaL_getsubtable(lua_State *L, int idx, const char *fname) {
  if (lua_getfield(L, idx, fname) == 5)
    return 1; /* table already there */
  else {
    lua_settop(L, -(1) - 1); /* remove previous result */
    idx = lua_absindex(L, idx);
    lua_createtable(L, 0, 0);
    lua_pushvalue(L, -1);        /* copy to be left at top */
    lua_setfield(L, idx, fname); /* assign new table to field */
    return 0;                    /* false, because did not find table there */
  }
}

/*
** Stripped-down 'require': After checking "loaded" table, calls 'openf'
** to open a module, registers the result in 'package.loaded' table and,
** if 'glb' is true, also registers the result in the global table.
** Leaves resulting module on the top.
*/
extern void luaL_requiref(lua_State *L, const char *modname,
                          lua_CFunction openf, int glb) {
  luaL_getsubtable(L, (-1000000 - 1000), "_LOADED");
  lua_getfield(L, -1, modname); /* LOADED[modname] */
  if (!lua_toboolean(L, -1)) {  /* package not already loaded? */
    lua_settop(L, -(1) - 1);    /* remove field */
    lua_pushcclosure(L, (openf), 0);
    lua_pushstring(L, modname);             /* argument to open function */
    lua_callk(L, (1), (1), 0, ((void *)0)); /* call 'openf' to open module */
    lua_pushvalue(L, -1);         /* make copy of module (call result) */
    lua_setfield(L, -3, modname); /* LOADED[modname] = module */
  }
  (lua_rotate(L, (-2), -1), lua_settop(L, -(1) - 1)); /* remove LOADED table */
  if (glb) {
    lua_pushvalue(L, -1);      /* copy of module */
    lua_setglobal(L, modname); /* _G[modname] = module */
  }
}

extern const char *luaL_gsub(lua_State *L, const char *s, const char *p,
                             const char *r) {
  const char *wild;
  size_t l = strlen(p);
  luaL_Buffer b;
  luaL_buffinit(L, &b);
  while ((wild = strstr(s, p)) != ((void *)0)) {
    luaL_addlstring(&b, s, wild - s); /* push prefix */
    luaL_addstring(&b, r);            /* push replacement in place of pattern */
    s = wild + l;                     /* continue after 'p' */
  }
  luaL_addstring(&b, s); /* push last suffix */
  luaL_pushresult(&b);
  return lua_tolstring(L, (-1), ((void *)0));
}

static void *l_alloc(void *ud, void *ptr, size_t osize, size_t nsize) {
  (void)ud;
  (void)osize; /* not used */
  if (nsize == 0) {
    free(ptr);
    return ((void *)0);
  } else
    return realloc(ptr, nsize);
}

static int panic(lua_State *L) {
  (fprintf(((__getreent())->_stderr),
           ("PANIC: unprotected error in call to Lua API (%s)\n"),
           (lua_tolstring(L, (-1), ((void *)0)))),
   fflush(((__getreent())->_stderr)));
  return 0; /* return to Lua to abort */
}

/*
** Emit a warning. '*previoustocont' signals whether previous message
** was to be continued by the current one.
*/
static void warnf(void *ud, const char *message, int tocont) {
  int *previoustocont = (int *)ud;
  if (!*previoustocont) /* previous message was the last? */
    (fprintf(((__getreent())->_stderr), ("%s"), ("Lua warning: ")),
     fflush(((__getreent())->_stderr))); /* start a new warning */
  (fprintf(((__getreent())->_stderr), ("%s"), (message)),
   fflush(((__getreent())->_stderr))); /* write message */
  if (!tocont)                         /* is this the last part? */
    (fprintf(((__getreent())->_stderr), ("%s"), ("\n")),
     fflush(((__getreent())->_stderr))); /* finish message with end-of-line */
  *previoustocont = tocont;
}

extern lua_State *luaL_newstate(void) {
  lua_State *L = lua_newstate(l_alloc, ((void *)0));
  if (L) {
    int *previoustocont; /* space for warning state */
    lua_atpanic(L, &panic);
    previoustocont = (int *)lua_newuserdatauv(L, sizeof(int), 0);
    luaL_ref(L, (-1000000 - 1000)); /* make sure it won't be collected */
    *previoustocont = 0;            /* next message starts a new warning */
    lua_setwarnf(L, warnf, previoustocont);
  }
  return L;
}

extern void luaL_checkversion_(lua_State *L, lua_Number ver, size_t sz) {
  lua_Number v = lua_version(L);
  if (sz !=
      (sizeof(lua_Integer) * 16 + sizeof(lua_Number))) /* check numeric types */
    luaL_error(L, "core and library have incompatible numeric types");
  else if (v != ver)
    luaL_error(L, "version mismatch: app. needs %f, Lua core provides %f",
               (double)ver, (double)v);
}

/* standard library  -- not used by luac */

/*
** $Id: lbaselib.c $
** Basic library
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/* version suffix for environment variable names */

extern int(luaopen_base)(lua_State *L);

extern int(luaopen_coroutine)(lua_State *L);

extern int(luaopen_table)(lua_State *L);

extern int(luaopen_io)(lua_State *L);

extern int(luaopen_os)(lua_State *L);

extern int(luaopen_string)(lua_State *L);

extern int(luaopen_utf8)(lua_State *L);

extern int(luaopen_math)(lua_State *L);

extern int(luaopen_debug)(lua_State *L);

extern int(luaopen_package)(lua_State *L);

/* open all previous libraries */
extern void(luaL_openlibs)(lua_State *L);

static int luaB_print(lua_State *L) {
  int n = lua_gettop(L); /* number of arguments */
  int i;
  lua_getglobal(L, "tostring");
  for (i = 1; i <= n; i++) {
    const char *s;
    size_t l;
    lua_pushvalue(L, -1); /* function to be called */
    lua_pushvalue(L, i);  /* value to print */
    lua_callk(L, (1), (1), 0, ((void *)0));
    s = lua_tolstring(L, -1, &l); /* get result */
    if (s == ((void *)0))
      return luaL_error(L, "'tostring' must return a string to 'print'");
    if (i > 1)
      fwrite(("\t"), sizeof(char), (1), ((__getreent())->_stdout));
    fwrite((s), sizeof(char), (l), ((__getreent())->_stdout));
    lua_settop(L, -(1) - 1); /* pop result */
  }
  (fwrite(("\n"), sizeof(char), (1), ((__getreent())->_stdout)),
   fflush(((__getreent())->_stdout)));
  return 0;
}

static int luaB_warn(lua_State *L) {
  const char *msg = (luaL_checklstring(L, (1), ((void *)0)));
  lua_warning(L, msg, lua_toboolean(L, 2));
  return 0;
}

static const char *b_str2int(const char *s, int base, lua_Integer *pn) {
  lua_Unsigned n = 0;
  int neg = 0;
  s += strspn(s, " \f\n\r\t\v"); /* skip initial spaces */
  if (*s == '-') {
    s++;
    neg = 1;
  } /* handle sign */
  else if (*s == '+')
    s++;
  if (!((((__locale_ctype_ptr()) +
          sizeof(""[(unsigned char)*s]))[(int)((unsigned char)*s)]) &
        (01 | 02 | 04))) /* no digit? */
    return ((void *)0);
  do {
    int digit = (((((__locale_ctype_ptr()) +
                    sizeof(""[(unsigned char)*s]))[(int)((unsigned char)*s)]) &
                  04))
                    ? *s - '0'
                    : (__extension__({
                         __typeof__((unsigned char)*s) __x =
                             ((unsigned char)*s);
                         (void)(__locale_ctype_ptr())[__x];
                         (toupper)(__x);
                       }) -
                       'A') +
                          10;
    if (digit >= base)
      return ((void *)0); /* invalid numeral */
    n = n * base + digit;
    s++;
  } while (((((__locale_ctype_ptr()) +
              sizeof(""[(unsigned char)*s]))[(int)((unsigned char)*s)]) &
            (01 | 02 | 04)));
  s += strspn(s, " \f\n\r\t\v"); /* skip trailing spaces */
  *pn = (lua_Integer)((neg) ? (0u - n) : n);
  return s;
}

static int luaB_tonumber(lua_State *L) {
  if ((lua_type(L, (2)) <= 0)) { /* standard conversion? */
    if (lua_type(L, 1) == 3) {   /* already a number? */
      lua_settop(L, 1);          /* yes; return it */
      return 1;
    } else {
      size_t l;
      const char *s = lua_tolstring(L, 1, &l);
      if (s != ((void *)0) && lua_stringtonumber(L, s) == l + 1)
        return 1; /* successful conversion to number */
      /* else not a number */
      luaL_checkany(L, 1); /* (but there must be some parameter) */
    }
  } else {
    size_t l;
    const char *s;
    lua_Integer n = 0; /* to avoid warnings */
    lua_Integer base = luaL_checkinteger(L, 2);
    luaL_checktype(L, 1, 4); /* no numbers as strings */
    s = lua_tolstring(L, 1, &l);
    ((void)((2 <= base && base <= 36) ||
            luaL_argerror(L, (2), ("base out of range"))));
    if (b_str2int(s, (int)base, &n) == s + l) {
      lua_pushinteger(L, n);
      return 1;
    }             /* else not a number */
  }               /* else not a number */
  lua_pushnil(L); /* not a number */
  return 1;
}

static int luaB_error(lua_State *L) {
  int level = (int)luaL_optinteger(L, 2, 1);
  lua_settop(L, 1);
  if (lua_type(L, 1) == 4 && level > 0) {
    luaL_where(L, level); /* add extra information */
    lua_pushvalue(L, 1);
    lua_concat(L, 2);
  }
  return lua_error(L);
}

static int luaB_getmetatable(lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_getmetatable(L, 1)) {
    lua_pushnil(L);
    return 1; /* no metatable */
  }
  luaL_getmetafield(L, 1, "__metatable");
  return 1; /* returns either __metatable field (if present) or metatable */
}

static int luaB_setmetatable(lua_State *L) {
  int t = lua_type(L, 2);
  luaL_checktype(L, 1, 5);
  ((void)((t == 0 || t == 5) || luaL_typeerror(L, (2), ("nil or table"))));
  if (luaL_getmetafield(L, 1, "__metatable") != 0)
    return luaL_error(L, "cannot change a protected metatable");
  lua_settop(L, 2);
  lua_setmetatable(L, 1);
  return 1;
}

static int luaB_rawequal(lua_State *L) {
  luaL_checkany(L, 1);
  luaL_checkany(L, 2);
  lua_pushboolean(L, lua_rawequal(L, 1, 2));
  return 1;
}

static int luaB_rawlen(lua_State *L) {
  int t = lua_type(L, 1);
  ((void)((t == 5 || t == 4) || luaL_typeerror(L, (1), ("table or string"))));
  lua_pushinteger(L, lua_rawlen(L, 1));
  return 1;
}

static int luaB_rawget(lua_State *L) {
  luaL_checktype(L, 1, 5);
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_rawget(L, 1);
  return 1;
}

static int luaB_rawset(lua_State *L) {
  luaL_checktype(L, 1, 5);
  luaL_checkany(L, 2);
  luaL_checkany(L, 3);
  lua_settop(L, 3);
  lua_rawset(L, 1);
  return 1;
}

static int pushmode(lua_State *L, int oldmode) {
  lua_pushstring(L, (oldmode == 11) ? "incremental" : "generational");
  return 1;
}

static int luaB_collectgarbage(lua_State *L) {
  static const char *const opts[] = {"stop",        "restart",   "collect",
                                     "count",       "step",      "setpause",
                                     "setstepmul",  "isrunning", "generational",
                                     "incremental", ((void *)0)};
  static const int optsnum[] = {0, 1, 2, 3, 5, 6, 7, 9, 10, 11};
  int o = optsnum[luaL_checkoption(L, 1, "collect", opts)];
  switch (o) {
  case 3: {
    int k = lua_gc(L, o);
    int b = lua_gc(L, 4);
    lua_pushnumber(L, (lua_Number)k + ((lua_Number)b / 1024));
    return 1;
  }
  case 5: {
    int step = (int)luaL_optinteger(L, 2, 0);
    int res = lua_gc(L, o, step);
    lua_pushboolean(L, res);
    return 1;
  }
  case 6:
  case 7: {
    int p = (int)luaL_optinteger(L, 2, 0);
    int previous = lua_gc(L, o, p);
    lua_pushinteger(L, previous);
    return 1;
  }
  case 9: {
    int res = lua_gc(L, o);
    lua_pushboolean(L, res);
    return 1;
  }
  case 10: {
    int minormul = (int)luaL_optinteger(L, 2, 0);
    int majormul = (int)luaL_optinteger(L, 3, 0);
    return pushmode(L, lua_gc(L, o, minormul, majormul));
  }
  case 11: {
    int pause = (int)luaL_optinteger(L, 2, 0);
    int stepmul = (int)luaL_optinteger(L, 3, 0);
    int stepsize = (int)luaL_optinteger(L, 4, 0);
    return pushmode(L, lua_gc(L, o, pause, stepmul, stepsize));
  }
  default: {
    int res = lua_gc(L, o);
    lua_pushinteger(L, res);
    return 1;
  }
  }
}

static int luaB_type(lua_State *L) {
  int t = lua_type(L, 1);
  ((void)((t != (-1)) || luaL_argerror(L, (1), ("value expected"))));
  lua_pushstring(L, lua_typename(L, t));
  return 1;
}

static int luaB_next(lua_State *L) {
  luaL_checktype(L, 1, 5);
  lua_settop(L, 2); /* create a 2nd argument if there isn't one */
  if (lua_next(L, 1))
    return 2;
  else {
    lua_pushnil(L);
    return 1;
  }
}

static int luaB_pairs(lua_State *L) {
  luaL_checkany(L, 1);
  if (luaL_getmetafield(L, 1, "__pairs") == 0) { /* no metamethod? */
    lua_pushcclosure(L, (luaB_next), 0);         /* will return generator, */
    lua_pushvalue(L, 1);                         /* state, */
    lua_pushnil(L);                              /* and initial value */
  } else {
    lua_pushvalue(L, 1);                    /* argument 'self' to metamethod */
    lua_callk(L, (1), (3), 0, ((void *)0)); /* get 3 values from metamethod */
  }
  return 3;
}

/*
** Traversal function for 'ipairs'
*/
static int ipairsaux(lua_State *L) {
  lua_Integer i = luaL_checkinteger(L, 2) + 1;
  lua_pushinteger(L, i);
  return (lua_geti(L, 1, i) == 0) ? 1 : 2;
}

/*
** 'ipairs' function. Returns 'ipairsaux', given "table", 0.
** (The given "table" may not be a table.)
*/
static int luaB_ipairs(lua_State *L) {
  luaL_checkany(L, 1);
  lua_pushcclosure(L, (ipairsaux), 0); /* iteration function */
  lua_pushvalue(L, 1);                 /* state */
  lua_pushinteger(L, 0);               /* initial value */
  return 3;
}

static int load_aux(lua_State *L, int status, int envidx) {
  if (status == 0) {
    if (envidx != 0) {               /* 'env' parameter? */
      lua_pushvalue(L, envidx);      /* environment for loaded function */
      if (!lua_setupvalue(L, -2, 1)) /* set it as 1st upvalue */
        lua_settop(L, -(1) - 1); /* remove 'env' if not used by previous call */
    }
    return 1;
  } else { /* error (message is on top of the stack) */
    lua_pushnil(L);
    lua_rotate(L, (-2), 1); /* put before error message */
    return 2;               /* return nil plus error message */
  }
}

static int luaB_loadfile(lua_State *L) {
  const char *fname = (luaL_optlstring(L, (1), (((void *)0)), ((void *)0)));
  const char *mode = (luaL_optlstring(L, (2), (((void *)0)), ((void *)0)));
  int env =
      (!(lua_type(L, (3)) == (-1)) ? 3 : 0); /* 'env' index or 0 if no 'env' */
  int status = luaL_loadfilex(L, fname, mode);
  return load_aux(L, status, env);
}

/*
** {======================================================
** Generic Read function
** =======================================================
*/

/*
** reserved slot, above all arguments, to hold a copy of the returned
** string to avoid it being collected while parsed. 'load' has four
** optional arguments (chunk, source name, mode, and environment).
*/

/*
** Reader for generic 'load' function: 'lua_load' uses the
** stack for internal stuff, so the reader cannot change the
** stack top. Instead, it keeps its resulting string in a
** reserved slot inside the stack.
*/
static const char *generic_reader(lua_State *L, void *ud, size_t *size) {
  (void)(ud); /* not used */
  luaL_checkstack(L, 2, "too many nested functions");
  lua_pushvalue(L, 1);                    /* get function */
  lua_callk(L, (0), (1), 0, ((void *)0)); /* call it */
  if ((lua_type(L, (-1)) == 0)) {
    lua_settop(L, -(1) - 1); /* pop result */
    *size = 0;
    return ((void *)0);
  } else if (!lua_isstring(L, -1))
    luaL_error(L, "reader function must return a string");
  (lua_copy(L, -1, (5)),
   lua_settop(L, -(1) - 1)); /* save string in reserved slot */
  return lua_tolstring(L, 5, size);
}

static int luaB_load(lua_State *L) {
  int status;
  size_t l;
  const char *s = lua_tolstring(L, 1, &l);
  const char *mode = (luaL_optlstring(L, (3), ("bt"), ((void *)0)));
  int env =
      (!(lua_type(L, (4)) == (-1)) ? 4 : 0); /* 'env' index or 0 if no 'env' */
  if (s != ((void *)0)) {                    /* loading a string? */
    const char *chunkname = (luaL_optlstring(L, (2), (s), ((void *)0)));
    status = luaL_loadbufferx(L, s, l, chunkname, mode);
  } else { /* loading from a reader function */
    const char *chunkname = (luaL_optlstring(L, (2), ("=(load)"), ((void *)0)));
    luaL_checktype(L, 1, 6);
    lua_settop(L, 5); /* create reserved slot */
    status = lua_load(L, generic_reader, ((void *)0), chunkname, mode);
  }
  return load_aux(L, status, env);
}

/* }====================================================== */

static int dofilecont(lua_State *L, int d1, lua_KContext d2) {
  (void)d1;
  (void)d2; /* only to match 'lua_Kfunction' prototype */
  return lua_gettop(L) - 1;
}

static int luaB_dofile(lua_State *L) {
  const char *fname = (luaL_optlstring(L, (1), (((void *)0)), ((void *)0)));
  lua_settop(L, 1);
  if (luaL_loadfilex(L, fname, ((void *)0)) != 0)
    return lua_error(L);
  lua_callk(L, 0, (-1), 0, dofilecont);
  return dofilecont(L, 0, 0);
}

static int luaB_assert(lua_State *L) {
  if (lua_toboolean(L, 1)) /* condition is true? */
    return lua_gettop(L);  /* return all arguments */
  else {                   /* error */
    luaL_checkany(L, 1);   /* there must be a condition */
    (lua_rotate(L, (1), -1), lua_settop(L, -(1) - 1)); /* remove it */
    lua_pushstring(L, ""
                      "assertion failed!"); /* default message */
    lua_settop(L, 1);     /* leave only message (default if no other one) */
    return luaB_error(L); /* call 'error' */
  }
}

static int luaB_select(lua_State *L) {
  int n = lua_gettop(L);
  if (lua_type(L, 1) == 4 && *lua_tolstring(L, (1), ((void *)0)) == '#') {
    lua_pushinteger(L, n - 1);
    return 1;
  } else {
    lua_Integer i = luaL_checkinteger(L, 1);
    if (i < 0)
      i = n + i;
    else if (i > n)
      i = n;
    ((void)((1 <= i) || luaL_argerror(L, (1), ("index out of range"))));
    return n - (int)i;
  }
}

/*
** Continuation function for 'pcall' and 'xpcall'. Both functions
** already pushed a 'true' before doing the call, so in case of success
** 'finishpcall' only has to return everything in the stack minus
** 'extra' values (where 'extra' is exactly the number of items to be
** ignored).
*/
static int finishpcall(lua_State *L, int status, lua_KContext extra) {
  if (status != 0 && status != 1) { /* error? */
    lua_pushboolean(L, 0);          /* first result (false) */
    lua_pushvalue(L, -2);           /* error message */
    return 2;                       /* return false, msg */
  } else
    return lua_gettop(L) - (int)extra; /* return all results */
}

static int luaB_pcall(lua_State *L) {
  int status;
  luaL_checkany(L, 1);
  lua_pushboolean(L, 1); /* first result if no errors */
  lua_rotate(L, (1), 1); /* put it in place */
  status = lua_pcallk(L, lua_gettop(L) - 2, (-1), 0, 0, finishpcall);
  return finishpcall(L, status, 0);
}

/*
** Do a protected call with error handling. After 'lua_rotate', the
** stack will have <f, err, true, f, [args...]>; so, the function passes
** 2 to 'finishpcall' to skip the 2 first values when returning results.
*/
static int luaB_xpcall(lua_State *L) {
  int status;
  int n = lua_gettop(L);
  luaL_checktype(L, 2, 6); /* check error function */
  lua_pushboolean(L, 1);   /* first result */
  lua_pushvalue(L, 1);     /* function */
  lua_rotate(L, 3, 2);     /* move them below function's arguments */
  status = lua_pcallk(L, n - 2, (-1), 2, 2, finishpcall);
  return finishpcall(L, status, 2);
}

static int luaB_tostring(lua_State *L) {
  luaL_checkany(L, 1);
  luaL_tolstring(L, 1, ((void *)0));
  return 1;
}

static const luaL_Reg base_funcs[] = {{"assert", luaB_assert},
                                      {"collectgarbage", luaB_collectgarbage},
                                      {"dofile", luaB_dofile},
                                      {"error", luaB_error},
                                      {"getmetatable", luaB_getmetatable},
                                      {"ipairs", luaB_ipairs},
                                      {"loadfile", luaB_loadfile},
                                      {"load", luaB_load},
                                      {"next", luaB_next},
                                      {"pairs", luaB_pairs},
                                      {"pcall", luaB_pcall},
                                      {"print", luaB_print},
                                      {"warn", luaB_warn},
                                      {"rawequal", luaB_rawequal},
                                      {"rawlen", luaB_rawlen},
                                      {"rawget", luaB_rawget},
                                      {"rawset", luaB_rawset},
                                      {"select", luaB_select},
                                      {"setmetatable", luaB_setmetatable},
                                      {"tonumber", luaB_tonumber},
                                      {"tostring", luaB_tostring},
                                      {"type", luaB_type},
                                      {"xpcall", luaB_xpcall},
                                      /* placeholders */
                                      {"_G", ((void *)0)},
                                      {"_VERSION", ((void *)0)},
                                      {((void *)0), ((void *)0)}};

extern int luaopen_base(lua_State *L) {
  /* open lib into global table */
  ((void)lua_rawgeti(L, (-1000000 - 1000), 2));
  luaL_setfuncs(L, base_funcs, 0);
  /* set global _G */
  lua_pushvalue(L, -1);
  lua_setfield(L, -2, "_G");
  /* set global _VERSION */
  lua_pushstring(L, ""
                    "Lua "
                    "5"
                    "."
                    "4");
  lua_setfield(L, -2, "_VERSION");
  return 1;
}
/*
** $Id: lcorolib.c $
** Coroutine Library
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/

static lua_State *getco(lua_State *L) {
  lua_State *co = lua_tothread(L, 1);
  ((void)((co) || luaL_typeerror(L, (1), ("thread"))));
  return co;
}

static int auxresume(lua_State *L, lua_State *co, int narg) {
  int status, nres;
  if (!lua_checkstack(co, narg)) {
    lua_pushstring(L, ""
                      "too many arguments to resume");
    return -1; /* error flag */
  }
  if (lua_status(co) == 0 && lua_gettop(co) == 0) {
    lua_pushstring(L, ""
                      "cannot resume dead coroutine");
    return -1; /* error flag */
  }
  lua_xmove(L, co, narg);
  status = lua_resume(co, L, narg, &nres);
  if (status == 0 || status == 1) {
    if (!lua_checkstack(L, nres + 1)) {
      lua_settop(co, -(nres)-1); /* remove results anyway */
      lua_pushstring(L, ""
                        "too many results to resume");
      return -1; /* error flag */
    }
    lua_xmove(co, L, nres); /* move yielded values */
    return nres;
  } else {
    lua_xmove(co, L, 1); /* move error message */
    return -1;           /* error flag */
  }
}

static int luaB_coresume(lua_State *L) {
  lua_State *co = getco(L);
  int r;
  r = auxresume(L, co, lua_gettop(L) - 1);
  if (r < 0) {
    lua_pushboolean(L, 0);
    lua_rotate(L, (-2), 1);
    return 2; /* return false + error message */
  } else {
    lua_pushboolean(L, 1);
    lua_rotate(L, (-(r + 1)), 1);
    return r + 1; /* return true + 'resume' returns */
  }
}

static int luaB_auxwrap(lua_State *L) {
  lua_State *co = lua_tothread(L, ((-1000000 - 1000) - (1)));
  int r = auxresume(L, co, lua_gettop(L));
  if (r < 0) {
    if (lua_type(L, -1) == 4) { /* error object is a string? */
      luaL_where(L, 1);         /* add extra info */
      lua_rotate(L, (-2), 1);
      lua_concat(L, 2);
    }
    return lua_error(L); /* propagate error */
  }
  return r;
}

static int luaB_cocreate(lua_State *L) {
  lua_State *NL;
  luaL_checktype(L, 1, 6);
  NL = lua_newthread(L);
  lua_pushvalue(L, 1); /* move function to top */
  lua_xmove(L, NL, 1); /* move function from L to NL */
  return 1;
}

static int luaB_cowrap(lua_State *L) {
  luaB_cocreate(L);
  lua_pushcclosure(L, luaB_auxwrap, 1);
  return 1;
}

static int luaB_yield(lua_State *L) {
  return lua_yieldk(L, (lua_gettop(L)), 0, ((void *)0));
}
static const char *statname[] = {"running", "dead", "suspended", "normal"};

static int auxstatus(lua_State *L, lua_State *co) {
  if (L == co)
    return 0;
  else {
    switch (lua_status(co)) {
    case 1:
      return 2;
    case 0: {
      lua_Debug ar;
      if (lua_getstack(co, 0, &ar)) /* does it have frames? */
        return 3;                   /* it is running */
      else if (lua_gettop(co) == 0)
        return 1;
      else
        return 2; /* initial state */
    }
    default: /* some error occurred */
      return 1;
    }
  }
}

static int luaB_costatus(lua_State *L) {
  lua_State *co = getco(L);
  lua_pushstring(L, statname[auxstatus(L, co)]);
  return 1;
}

static int luaB_yieldable(lua_State *L) {
  lua_pushboolean(L, lua_isyieldable(L));
  return 1;
}

static int luaB_corunning(lua_State *L) {
  int ismain = lua_pushthread(L);
  lua_pushboolean(L, ismain);
  return 2;
}

static int luaB_kill(lua_State *L) {
  lua_State *co = getco(L);
  int status = auxstatus(L, co);
  switch (status) {
  case 1:
  case 2: {
    status = lua_resetthread(co);
    if (status == 0) {
      lua_pushboolean(L, 1);
      return 1;
    } else {
      lua_pushboolean(L, 0);
      lua_xmove(co, L, 1); /* copy error message */
      return 2;
    }
  }
  default: /* normal or running coroutine */
    return luaL_error(L, "cannot kill a %s coroutine", statname[status]);
  }
}

static const luaL_Reg co_funcs[] = {
    {"create", luaB_cocreate},       {"resume", luaB_coresume},
    {"running", luaB_corunning},     {"status", luaB_costatus},
    {"wrap", luaB_cowrap},           {"yield", luaB_yield},
    {"isyieldable", luaB_yieldable}, {"kill", luaB_kill},
    {((void *)0), ((void *)0)}};

extern int luaopen_coroutine(lua_State *L) {
  (luaL_checkversion_(L, 504, (sizeof(lua_Integer) * 16 + sizeof(lua_Number))),
   lua_createtable(L, 0, sizeof(co_funcs) / sizeof((co_funcs)[0]) - 1),
   luaL_setfuncs(L, co_funcs, 0));
  return 1;
}
/*
** $Id: ldblib.c $
** Interface from Lua to its debug API
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/

/*
** The hook table at registry[&HOOKKEY] maps threads to their current
** hook function. (We only need the unique address of 'HOOKKEY'.)
*/
static const int HOOKKEY = 0;

/*
** If L1 != L, L1 can be in any state, and therefore there are no
** guarantees about its stack space; any push in L1 must be
** checked.
*/
static void checkstack(lua_State *L, lua_State *L1, int n) {
  if (L != L1 && !lua_checkstack(L1, n))
    luaL_error(L, "stack overflow");
}

static int db_getregistry(lua_State *L) {
  lua_pushvalue(L, (-1000000 - 1000));
  return 1;
}

static int db_getmetatable(lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_getmetatable(L, 1)) {
    lua_pushnil(L); /* no metatable */
  }
  return 1;
}

static int db_setmetatable(lua_State *L) {
  int t = lua_type(L, 2);
  ((void)((t == 0 || t == 5) || luaL_typeerror(L, (2), ("nil or table"))));
  lua_settop(L, 2);
  lua_setmetatable(L, 1);
  return 1; /* return 1st argument */
}

static int db_getuservalue(lua_State *L) {
  int n = (int)luaL_optinteger(L, 2, 1);
  if (lua_type(L, 1) != 7)
    lua_pushnil(L);
  else if (lua_getiuservalue(L, 1, n) != (-1)) {
    lua_pushboolean(L, 1);
    return 2;
  }
  return 1;
}

static int db_setuservalue(lua_State *L) {
  int n = (int)luaL_optinteger(L, 3, 1);
  luaL_checktype(L, 1, 7);
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  if (!lua_setiuservalue(L, 1, n))
    lua_pushnil(L);
  return 1;
}

/*
** Auxiliary function used by several library functions: check for
** an optional thread as function's first argument and set 'arg' with
** 1 if this argument is present (so that functions can skip it to
** access their other arguments)
*/
static lua_State *getthread(lua_State *L, int *arg) {
  if ((lua_type(L, (1)) == 8)) {
    *arg = 1;
    return lua_tothread(L, 1);
  } else {
    *arg = 0;
    return L; /* function will operate over current thread */
  }
}

/*
** Variations of 'lua_settable', used by 'db_getinfo' to put results
** from 'lua_getinfo' into result table. Key is always a string;
** value can be a string, an int, or a boolean.
*/
static void settabss(lua_State *L, const char *k, const char *v) {
  lua_pushstring(L, v);
  lua_setfield(L, -2, k);
}

static void settabsi(lua_State *L, const char *k, int v) {
  lua_pushinteger(L, v);
  lua_setfield(L, -2, k);
}

static void settabsb(lua_State *L, const char *k, int v) {
  lua_pushboolean(L, v);
  lua_setfield(L, -2, k);
}

/*
** In function 'db_getinfo', the call to 'lua_getinfo' may push
** results on the stack; later it creates the result table to put
** these objects. Function 'treatstackoption' puts the result from
** 'lua_getinfo' on top of the result table so that it can call
** 'lua_setfield'.
*/
static void treatstackoption(lua_State *L, lua_State *L1, const char *fname) {
  if (L == L1)
    lua_rotate(L, -2, 1); /* exchange object and table */
  else
    lua_xmove(L1, L, 1);      /* move object to the "main" stack */
  lua_setfield(L, -2, fname); /* put object into table */
}

/*
** Calls 'lua_getinfo' and collects all results in a new table.
** L1 needs stack space for an optional input (function) plus
** two optional outputs (function and line table) from function
** 'lua_getinfo'.
*/
static int db_getinfo(lua_State *L) {
  lua_Debug ar;
  int arg;
  lua_State *L1 = getthread(L, &arg);
  const char *options =
      (luaL_optlstring(L, (arg + 2), ("flnSrtu"), ((void *)0)));
  checkstack(L, L1, 3);
  if ((lua_type(L, (arg + 1)) == 6)) {            /* info about a function? */
    options = lua_pushfstring(L, ">%s", options); /* add '>' to 'options' */
    lua_pushvalue(L, arg + 1); /* move function to 'L1' stack */
    lua_xmove(L, L1, 1);
  } else { /* stack level */
    if (!lua_getstack(L1, (int)luaL_checkinteger(L, arg + 1), &ar)) {
      lua_pushnil(L); /* level out of range */
      return 1;
    }
  }
  if (!lua_getinfo(L1, options, &ar))
    return luaL_argerror(L, arg + 2, "invalid option");
  lua_createtable(L, 0, 0); /* table to collect results */
  if (strchr(options, 'S')) {
    lua_pushlstring(L, ar.source, ar.srclen);
    lua_setfield(L, -2, "source");
    settabss(L, "short_src", ar.short_src);
    settabsi(L, "linedefined", ar.linedefined);
    settabsi(L, "lastlinedefined", ar.lastlinedefined);
    settabss(L, "what", ar.what);
  }
  if (strchr(options, 'l'))
    settabsi(L, "currentline", ar.currentline);
  if (strchr(options, 'u')) {
    settabsi(L, "nups", ar.nups);
    settabsi(L, "nparams", ar.nparams);
    settabsb(L, "isvararg", ar.isvararg);
  }
  if (strchr(options, 'n')) {
    settabss(L, "name", ar.name);
    settabss(L, "namewhat", ar.namewhat);
  }
  if (strchr(options, 'r')) {
    settabsi(L, "ftransfer", ar.ftransfer);
    settabsi(L, "ntransfer", ar.ntransfer);
  }
  if (strchr(options, 't'))
    settabsb(L, "istailcall", ar.istailcall);
  if (strchr(options, 'L'))
    treatstackoption(L, L1, "activelines");
  if (strchr(options, 'f'))
    treatstackoption(L, L1, "func");
  return 1; /* return table */
}

static int db_getlocal(lua_State *L) {
  int arg;
  lua_State *L1 = getthread(L, &arg);
  lua_Debug ar;
  const char *name;
  int nvar = (int)luaL_checkinteger(L, arg + 2); /* local-variable index */
  if ((lua_type(L, (arg + 1)) == 6)) {           /* function argument? */
    lua_pushvalue(L, arg + 1);                   /* push function */
    lua_pushstring(L, lua_getlocal(L, ((void *)0), nvar)); /* push local name */
    return 1; /* return only name (there is no value) */
  } else {    /* stack-level argument */
    int level = (int)luaL_checkinteger(L, arg + 1);
    if (!lua_getstack(L1, level, &ar)) /* out of range? */
      return luaL_argerror(L, arg + 1, "level out of range");
    checkstack(L, L1, 1);
    name = lua_getlocal(L1, &ar, nvar);
    if (name) {
      lua_xmove(L1, L, 1);     /* move local value */
      lua_pushstring(L, name); /* push name */
      lua_rotate(L, -2, 1);    /* re-order */
      return 2;
    } else {
      lua_pushnil(L); /* no name (nor value) */
      return 1;
    }
  }
}

static int db_setlocal(lua_State *L) {
  int arg;
  const char *name;
  lua_State *L1 = getthread(L, &arg);
  lua_Debug ar;
  int level = (int)luaL_checkinteger(L, arg + 1);
  int nvar = (int)luaL_checkinteger(L, arg + 2);
  if (!lua_getstack(L1, level, &ar)) /* out of range? */
    return luaL_argerror(L, arg + 1, "level out of range");
  luaL_checkany(L, arg + 3);
  lua_settop(L, arg + 3);
  checkstack(L, L1, 1);
  lua_xmove(L, L1, 1);
  name = lua_setlocal(L1, &ar, nvar);
  if (name == ((void *)0))
    lua_settop(L1, -(1) - 1); /* pop value (if not popped by 'lua_setlocal') */
  lua_pushstring(L, name);
  return 1;
}

/*
** get (if 'get' is true) or set an upvalue from a closure
*/
static int auxupvalue(lua_State *L, int get) {
  const char *name;
  int n = (int)luaL_checkinteger(L, 2); /* upvalue index */
  luaL_checktype(L, 1, 6);              /* closure */
  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
  if (name == ((void *)0))
    return 0;
  lua_pushstring(L, name);
  lua_rotate(L, (-(get + 1)), 1); /* no-op if get is false */
  return get + 1;
}

static int db_getupvalue(lua_State *L) { return auxupvalue(L, 1); }

static int db_setupvalue(lua_State *L) {
  luaL_checkany(L, 3);
  return auxupvalue(L, 0);
}

/*
** Check whether a given upvalue from a given closure exists and
** returns its index
*/
static int checkupval(lua_State *L, int argf, int argnup) {
  int nup = (int)luaL_checkinteger(L, argnup); /* upvalue index */
  luaL_checktype(L, argf, 6);                  /* closure */
  ((void)(((lua_getupvalue(L, argf, nup) != ((void *)0))) ||
          luaL_argerror(L, (argnup), ("invalid upvalue index"))));
  return nup;
}

static int db_upvalueid(lua_State *L) {
  int n = checkupval(L, 1, 2);
  lua_pushlightuserdata(L, lua_upvalueid(L, 1, n));
  return 1;
}

static int db_upvaluejoin(lua_State *L) {
  int n1 = checkupval(L, 1, 2);
  int n2 = checkupval(L, 3, 4);
  ((void)((!lua_iscfunction(L, 1)) ||
          luaL_argerror(L, (1), ("Lua function expected"))));
  ((void)((!lua_iscfunction(L, 3)) ||
          luaL_argerror(L, (3), ("Lua function expected"))));
  lua_upvaluejoin(L, 1, n1, 3, n2);
  return 0;
}

/*
** Call hook function registered at hook table for the current
** thread (if there is one)
*/
static void hookf(lua_State *L, lua_Debug *ar) {
  static const char *const hooknames[] = {"call", "return", "line", "count",
                                          "tail call"};
  lua_rawgetp(L, (-1000000 - 1000), &HOOKKEY);
  lua_pushthread(L);
  if (lua_rawget(L, -2) == 6) { /* is there a hook function? */
    lua_pushstring(L, hooknames[(int)ar->event]); /* push event name */
    if (ar->currentline >= 0)
      lua_pushinteger(L, ar->currentline); /* push current line */
    else
      lua_pushnil(L);
    ((void)0);
    lua_callk(L, (2), (0), 0, ((void *)0)); /* call hook function */
  }
}

/*
** Convert a string mask (for 'sethook') into a bit mask
*/
static int makemask(const char *smask, int count) {
  int mask = 0;
  if (strchr(smask, 'c'))
    mask |= (1 << 0);
  if (strchr(smask, 'r'))
    mask |= (1 << 1);
  if (strchr(smask, 'l'))
    mask |= (1 << 2);
  if (count > 0)
    mask |= (1 << 3);
  return mask;
}

/*
** Convert a bit mask (for 'gethook') into a string mask
*/
static char *unmakemask(int mask, char *smask) {
  int i = 0;
  if (mask & (1 << 0))
    smask[i++] = 'c';
  if (mask & (1 << 1))
    smask[i++] = 'r';
  if (mask & (1 << 2))
    smask[i++] = 'l';
  smask[i] = '\0';
  return smask;
}

static int db_sethook(lua_State *L) {
  int arg, mask, count;
  lua_Hook func;
  lua_State *L1 = getthread(L, &arg);
  if ((lua_type(L, (arg + 1)) <= 0)) { /* no hook? */
    lua_settop(L, arg + 1);
    func = ((void *)0);
    mask = 0;
    count = 0; /* turn off hooks */
  } else {
    const char *smask = (luaL_checklstring(L, (arg + 2), ((void *)0)));
    luaL_checktype(L, arg + 1, 6);
    count = (int)luaL_optinteger(L, arg + 3, 0);
    func = hookf;
    mask = makemask(smask, count);
  }
  if (lua_rawgetp(L, (-1000000 - 1000), &HOOKKEY) == 0) {
    lua_createtable(L, 0, 2); /* create a hook table */
    lua_pushvalue(L, -1);
    lua_rawsetp(L, (-1000000 - 1000), &HOOKKEY); /* set it in position */
    lua_pushstring(L, "k");
    lua_setfield(L, -2, "__mode"); /** hooktable.__mode = "k" */
    lua_pushvalue(L, -1);
    lua_setmetatable(L, -2); /* setmetatable(hooktable) = hooktable */
  }
  checkstack(L, L1, 1);
  lua_pushthread(L1);
  lua_xmove(L1, L, 1);       /* key (thread) */
  lua_pushvalue(L, arg + 1); /* value (hook function) */
  lua_rawset(L, -3);         /* hooktable[L1] = new Lua hook */
  lua_sethook(L1, func, mask, count);
  return 0;
}

static int db_gethook(lua_State *L) {
  int arg;
  lua_State *L1 = getthread(L, &arg);
  char buff[5];
  int mask = lua_gethookmask(L1);
  lua_Hook hook = lua_gethook(L1);
  if (hook == ((void *)0)) /* no hook? */
    lua_pushnil(L);
  else if (hook != hookf) /* external hook? */
    lua_pushstring(L, ""
                      "external hook");
  else { /* hook table must exist */
    lua_rawgetp(L, (-1000000 - 1000), &HOOKKEY);
    checkstack(L, L1, 1);
    lua_pushthread(L1);
    lua_xmove(L1, L, 1);
    lua_rawget(L, -2); /* 1st result = hooktable[L1] */
    (lua_rotate(L, (-2), -1), lua_settop(L, -(1) - 1)); /* remove hook table */
  }
  lua_pushstring(L, unmakemask(mask, buff)); /* 2nd result = mask */
  lua_pushinteger(L, lua_gethookcount(L1));  /* 3rd result = count */
  return 3;
}

static int db_debug(lua_State *L) {
  for (;;) {
    char buffer[250];
    (fprintf(((__getreent())->_stderr), ("%s"), ("lua_debug> ")),
     fflush(((__getreent())->_stderr)));
    if (fgets(buffer, sizeof(buffer), ((__getreent())->_stdin)) == 0 ||
        strcmp(buffer, "cont\n") == 0)
      return 0;
    if (luaL_loadbufferx(L, buffer, strlen(buffer), "=(debug command)",
                         ((void *)0)) ||
        lua_pcallk(L, (0), (0), (0), 0, ((void *)0)))
      (fprintf(((__getreent())->_stderr), ("%s\n"),
               (lua_tolstring(L, (-1), ((void *)0)))),
       fflush(((__getreent())->_stderr)));
    lua_settop(L, 0); /* remove eventual returns */
  }
}

static int db_traceback(lua_State *L) {
  int arg;
  lua_State *L1 = getthread(L, &arg);
  const char *msg = lua_tolstring(L, (arg + 1), ((void *)0));
  if (msg == ((void *)0) &&
      !(lua_type(L, (arg + 1)) <= 0)) /* non-string 'msg'? */
    lua_pushvalue(L, arg + 1);        /* return it untouched */
  else {
    int level = (int)luaL_optinteger(L, arg + 2, (L == L1) ? 1 : 0);
    luaL_traceback(L, L1, msg, level);
  }
  return 1;
}

static const luaL_Reg dblib[] = {{"debug", db_debug},
                                 {"getuservalue", db_getuservalue},
                                 {"gethook", db_gethook},
                                 {"getinfo", db_getinfo},
                                 {"getlocal", db_getlocal},
                                 {"getregistry", db_getregistry},
                                 {"getmetatable", db_getmetatable},
                                 {"getupvalue", db_getupvalue},
                                 {"upvaluejoin", db_upvaluejoin},
                                 {"upvalueid", db_upvalueid},
                                 {"setuservalue", db_setuservalue},
                                 {"sethook", db_sethook},
                                 {"setlocal", db_setlocal},
                                 {"setmetatable", db_setmetatable},
                                 {"setupvalue", db_setupvalue},
                                 {"traceback", db_traceback},
                                 {((void *)0), ((void *)0)}};

extern int luaopen_debug(lua_State *L) {
  (luaL_checkversion_(L, 504, (sizeof(lua_Integer) * 16 + sizeof(lua_Number))),
   lua_createtable(L, 0, sizeof(dblib) / sizeof((dblib)[0]) - 1),
   luaL_setfuncs(L, dblib, 0));
  return 1;
}
/*
** $Id: liolib.c $
** Standard I/O (and system) library
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
        locale.h
        Values appropriate for the formatting of monetary and other
        numberic quantities.
*/
/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/

/*
** Change this macro to accept other modes for 'fopen' besides
** the standard ones.
*/

/* accepted extensions to 'mode' in 'fopen' */

/* Check whether 'mode' matches '[rwa]%+?[L_MODEEXT]*' */
static int l_checkmode(const char *mode) {
  return (*mode != '\0' && strchr("rwa", *(mode++)) != ((void *)0) &&
          (*mode != '+' || (++mode, 1)) &&      /* skip if char is '+' */
          (strspn(mode, "b") == strlen(mode))); /* check extensions */
}

/*
** {======================================================
** l_popen spawns a new process connected to the current
** one through the file streams.
** =======================================================
*/
/* ISO C definitions */
/* }====================================================== */
/*
** {======================================================
** l_fseek: configuration for longer offsets
** =======================================================
*/
/* ISO C definitions */
/* }====================================================== */
typedef luaL_Stream LStream;

static int io_type(lua_State *L) {
  LStream *p;
  luaL_checkany(L, 1);
  p = (LStream *)luaL_testudata(L, 1, "FILE*");
  if (p == ((void *)0))
    lua_pushnil(L); /* not a file */
  else if (((p)->closef == ((void *)0)))
    lua_pushstring(L, ""
                      "closed file");
  else
    lua_pushstring(L, ""
                      "file");
  return 1;
}

static int f_tostring(lua_State *L) {
  LStream *p = ((LStream *)luaL_checkudata(L, 1, "FILE*"));
  if (((p)->closef == ((void *)0)))
    lua_pushstring(L, ""
                      "file (closed)");
  else
    lua_pushfstring(L, "file (%p)", p->f);
  return 1;
}

static FILE *tofile(lua_State *L) {
  LStream *p = ((LStream *)luaL_checkudata(L, 1, "FILE*"));
  if (((p)->closef == ((void *)0)))
    luaL_error(L, "attempt to use a closed file");
  ((void)0);
  return p->f;
}

/*
** When creating file handles, always creates a 'closed' file handle
** before opening the actual file; so, if there is a memory error, the
** handle is in a consistent state.
*/
static LStream *newprefile(lua_State *L) {
  LStream *p = (LStream *)lua_newuserdatauv(L, sizeof(LStream), 0);
  p->closef = ((void *)0); /* mark file handle as 'closed' */
  luaL_setmetatable(L, "FILE*");
  return p;
}

/*
** Calls the 'close' function from a file handle. The 'volatile' avoids
** a bug in some versions of the Clang compiler (e.g., clang 3.0 for
** 32 bits).
*/
static int aux_close(lua_State *L) {
  LStream *p = ((LStream *)luaL_checkudata(L, 1, "FILE*"));
  volatile lua_CFunction cf = p->closef;
  p->closef = ((void *)0); /* mark stream as closed */
  return (*cf)(L);         /* close it */
}

static int f_close(lua_State *L) {
  tofile(L); /* make sure argument is an open stream */
  return aux_close(L);
}

static int io_close(lua_State *L) {
  if ((lua_type(L, (1)) == (-1))) /* no argument? */
    lua_getfield(L, (-1000000 - 1000),
                 ("_IO_"
                  "output")); /* use standard output */
  return f_close(L);
}

static int f_gc(lua_State *L) {
  LStream *p = ((LStream *)luaL_checkudata(L, 1, "FILE*"));
  if (!((p)->closef == ((void *)0)) && p->f != ((void *)0))
    aux_close(L); /* ignore closed and incompletely open files */
  return 0;
}

/*
** function to close regular files
*/
static int io_fclose(lua_State *L) {
  LStream *p = ((LStream *)luaL_checkudata(L, 1, "FILE*"));
  int res = fclose(p->f);
  return luaL_fileresult(L, (res == 0), ((void *)0));
}

static LStream *newfile(lua_State *L) {
  LStream *p = newprefile(L);
  p->f = ((void *)0);
  p->closef = &io_fclose;
  return p;
}

static void opencheck(lua_State *L, const char *fname, const char *mode) {
  LStream *p = newfile(L);
  p->f = fopen(fname, mode);
  if (p->f == ((void *)0))
    luaL_error(L, "cannot open file '%s' (%s)", fname, strerror((*__errno())));
}

static int io_open(lua_State *L) {
  const char *filename = (luaL_checklstring(L, (1), ((void *)0)));
  const char *mode = (luaL_optlstring(L, (2), ("r"), ((void *)0)));
  LStream *p = newfile(L);
  const char *md = mode; /* to traverse/check mode */
  ((void)((l_checkmode(md)) || luaL_argerror(L, (2), ("invalid mode"))));
  p->f = fopen(filename, mode);
  return (p->f == ((void *)0)) ? luaL_fileresult(L, 0, filename) : 1;
}

/*
** function to close 'popen' files
*/
static int io_pclose(lua_State *L) {
  LStream *p = ((LStream *)luaL_checkudata(L, 1, "FILE*"));
  return luaL_execresult(L, ((void)L, (void)p->f, -1));
}

static int io_popen(lua_State *L) {
  const char *filename = (luaL_checklstring(L, (1), ((void *)0)));
  const char *mode = (luaL_optlstring(L, (2), ("r"), ((void *)0)));
  LStream *p = newprefile(L);
  p->f = ((void)filename, (void)mode, luaL_error(L, "'popen' not supported"),
          (FILE *)0);
  p->closef = &io_pclose;
  return (p->f == ((void *)0)) ? luaL_fileresult(L, 0, filename) : 1;
}

static int io_tmpfile(lua_State *L) {
  LStream *p = newfile(L);
  p->f = tmpfile();
  return (p->f == ((void *)0)) ? luaL_fileresult(L, 0, ((void *)0)) : 1;
}

static FILE *getiofile(lua_State *L, const char *findex) {
  LStream *p;
  lua_getfield(L, (-1000000 - 1000), findex);
  p = (LStream *)lua_touserdata(L, -1);
  if (((p)->closef == ((void *)0)))
    luaL_error(L, "standard %s file is closed",
               findex + (sizeof("_IO_") / sizeof(char) - 1));
  return p->f;
}

static int g_iofile(lua_State *L, const char *f, const char *mode) {
  if (!(lua_type(L, (1)) <= 0)) {
    const char *filename = lua_tolstring(L, (1), ((void *)0));
    if (filename)
      opencheck(L, filename, mode);
    else {
      tofile(L); /* check that it's a valid file handle */
      lua_pushvalue(L, 1);
    }
    lua_setfield(L, (-1000000 - 1000), f);
  }
  /* return current value */
  lua_getfield(L, (-1000000 - 1000), f);
  return 1;
}

static int io_input(lua_State *L) {
  return g_iofile(L,
                  ("_IO_"
                   "input"),
                  "r");
}

static int io_output(lua_State *L) {
  return g_iofile(L,
                  ("_IO_"
                   "output"),
                  "w");
}

static int io_readline(lua_State *L);

/*
** maximum number of arguments to 'f:lines'/'io.lines' (it + 3 must fit
** in the limit for upvalues of a closure)
*/

/*
** Auxiliar function to create the iteration function for 'lines'.
** The iteration function is a closure over 'io_readline', with
** the following upvalues:
** 1) The file being read (first value in the stack)
** 2) the number of arguments to read
** 3) a boolean, true iff file has to be closed when finished ('toclose')
** *) a variable number of format arguments (rest of the stack)
*/
static void aux_lines(lua_State *L, int toclose) {
  int n = lua_gettop(L) - 1; /* number of arguments to read */
  ((void)((n <= 250) || luaL_argerror(L, (250 + 2), ("too many arguments"))));
  lua_pushvalue(L, 1);         /* file */
  lua_pushinteger(L, n);       /* number of arguments to read */
  lua_pushboolean(L, toclose); /* close/not close file when finished */
  lua_rotate(L, 2, 3);         /* move the three values to their positions */
  lua_pushcclosure(L, io_readline, 3 + n);
}

static int f_lines(lua_State *L) {
  tofile(L); /* check that it's a valid file handle */
  aux_lines(L, 0);
  return 1;
}

/*
** Return an iteration function for 'io.lines'. If file has to be
** closed, also returns the file itself as a second result (to be
** closed as the state at the exit of a generic for).
*/
static int io_lines(lua_State *L) {
  int toclose;
  if ((lua_type(L, (1)) == (-1)))
    lua_pushnil(L);              /* at least one argument */
  if ((lua_type(L, (1)) == 0)) { /* no file name? */
    lua_getfield(L, (-1000000 - 1000),
                 ("_IO_"
                  "input"));                         /* get default input */
    (lua_copy(L, -1, (1)), lua_settop(L, -(1) - 1)); /* put it at index 1 */
    tofile(L);   /* check that it's a valid file handle */
    toclose = 0; /* do not close it after iteration */
  } else {       /* open a new file */
    const char *filename = (luaL_checklstring(L, (1), ((void *)0)));
    opencheck(L, filename, "r");
    (lua_copy(L, -1, (1)), lua_settop(L, -(1) - 1)); /* put file at index 1 */
    toclose = 1; /* close it after iteration */
  }
  aux_lines(L, toclose); /* push iteration function */
  if (toclose) {
    lua_pushnil(L);      /* state */
    lua_pushnil(L);      /* control */
    lua_pushvalue(L, 1); /* file is the to-be-closed variable (4th result) */
    return 4;
  } else
    return 1;
}

/*
** {======================================================
** READ
** =======================================================
*/

/* maximum length of a numeral */

/* auxiliary structure used by 'read_number' */
typedef struct {
  FILE *f;            /* file being read */
  int c;              /* current character (look ahead) */
  int n;              /* number of elements in buffer 'buff' */
  char buff[200 + 1]; /* +1 for ending '\0' */
} RN;

/*
** Add current char to buffer (if not out of space) and read next one
*/
static int nextc(RN *rn) {
  if (rn->n >= 200) {   /* buffer overflow? */
    rn->buff[0] = '\0'; /* invalidate result */
    return 0;           /* fail */
  } else {
    rn->buff[rn->n++] = rn->c; /* save current char */
    rn->c = getc(rn->f);       /* read next one */
    return 1;
  }
}

/*
** Accept current char if it is in 'set' (of size 2)
*/
static int test2(RN *rn, const char *set) {
  if (rn->c == set[0] || rn->c == set[1])
    return nextc(rn);
  else
    return 0;
}

/*
** Read a sequence of (hex)digits
*/
static int readdigits(RN *rn, int hex) {
  int count = 0;
  while ((hex ? ((((__locale_ctype_ptr()) + sizeof(""[rn->c]))[(int)(rn->c)]) &
                 (0100 | 04))
              : ((((__locale_ctype_ptr()) + sizeof(""[rn->c]))[(int)(rn->c)]) &
                 04)) &&
         nextc(rn))
    count++;
  return count;
}

/*
** Read a number: first reads a valid prefix of a numeral into a buffer.
** Then it calls 'lua_stringtonumber' to check whether the format is
** correct and to convert it to a Lua number.
*/
static int read_number(lua_State *L, FILE *f) {
  RN rn;
  int count = 0;
  int hex = 0;
  char decp[2];
  rn.f = f;
  rn.n = 0;
  decp[0] =
      (localeconv()->decimal_point[0]); /* get decimal point from locale */
  decp[1] = '.';                        /* always accept a dot */
  ((void)0);
  do {
    rn.c = getc(rn.f);
  } while (((((__locale_ctype_ptr()) + sizeof(""[rn.c]))[(int)(rn.c)]) &
            010));  /* skip spaces */
  test2(&rn, "-+"); /* optional sign */
  if (test2(&rn, "00")) {
    if (test2(&rn, "xX"))
      hex = 1; /* numeral is hexadecimal */
    else
      count = 1; /* count initial '0' as a valid digit */
  }
  count += readdigits(&rn, hex);                      /* integral part */
  if (test2(&rn, decp))                               /* decimal point? */
    count += readdigits(&rn, hex);                    /* fractional part */
  if (count > 0 && test2(&rn, (hex ? "pP" : "eE"))) { /* exponent mark? */
    test2(&rn, "-+");                                 /* exponent sign */
    readdigits(&rn, 0);                               /* exponent digits */
  }
  ungetc(rn.c, rn.f); /* unread look-ahead char */
  ((void)0);
  rn.buff[rn.n] = '\0';               /* finish string */
  if (lua_stringtonumber(L, rn.buff)) /* is this a valid number? */
    return 1;                         /* ok */
  else {                              /* invalid format */
    lua_pushnil(L);                   /* "result" to be removed */
    return 0;                         /* read fails */
  }
}

static int test_eof(lua_State *L, FILE *f) {
  int c = getc(f);
  ungetc(c, f); /* no-op when c == EOF */
  lua_pushstring(L, ""
                    "");
  return (c != (-1));
}

static int read_line(lua_State *L, FILE *f, int chop) {
  luaL_Buffer b;
  int c = '\0';
  luaL_buffinit(L, &b);
  while (c != (-1) && c != '\n') { /* repeat until end of line */
    char *buff = luaL_prepbuffsize(
        &b, ((int)(16 * sizeof(void *) *
                   sizeof(lua_Number)))); /* preallocate buffer */
    int i = 0;
    ((void)0); /* no memory errors can happen inside the lock */
    while (i < ((int)(16 * sizeof(void *) * sizeof(lua_Number))) &&
           (c = getc(f)) != (-1) && c != '\n')
      buff[i++] = c;
    ((void)0);
    ((&b)->n += (i));
  }
  if (!chop && c == '\n') /* want a newline and have one? */
    ((void)((&b)->n < (&b)->size || luaL_prepbuffsize((&b), 1)),
     ((&b)->b[(&b)->n++] = (c))); /* add ending newline to result */
  luaL_pushresult(&b);            /* close buffer */
  /* return ok if read something (either a newline or something else) */
  return (c == '\n' || lua_rawlen(L, -1) > 0);
}

static void read_all(lua_State *L, FILE *f) {
  size_t nr;
  luaL_Buffer b;
  luaL_buffinit(L, &b);
  do { /* read file in chunks of LUAL_BUFFERSIZE bytes */
    char *p = luaL_prepbuffsize(
        &b, ((int)(16 * sizeof(void *) * sizeof(lua_Number))));
    nr = fread(p, sizeof(char),
               ((int)(16 * sizeof(void *) * sizeof(lua_Number))), f);
    ((&b)->n += (nr));
  } while (nr == ((int)(16 * sizeof(void *) * sizeof(lua_Number))));
  luaL_pushresult(&b); /* close buffer */
}

static int read_chars(lua_State *L, FILE *f, size_t n) {
  size_t nr; /* number of chars actually read */
  char *p;
  luaL_Buffer b;
  luaL_buffinit(L, &b);
  p = luaL_prepbuffsize(&b, n);      /* prepare buffer to read whole block */
  nr = fread(p, sizeof(char), n, f); /* try to read 'n' chars */
  ((&b)->n += (nr));
  luaL_pushresult(&b); /* close buffer */
  return (nr > 0);     /* true iff read something */
}

static int g_read(lua_State *L, FILE *f, int first) {
  int nargs = lua_gettop(L) - 1;
  int n, success;

  ((void)((f)->_flags &= ~(0x0040 /* found error */ | 0x0020 /* found EOF */)));
  if (nargs == 0) { /* no arguments? */
    success = read_line(L, f, 1);
    n = first + 1; /* to return 1 result */
  } else {
    /* ensure stack space for all results and for auxlib's buffer */
    luaL_checkstack(L, nargs + 20, "too many arguments");
    success = 1;
    for (n = first; nargs-- && success; n++) {
      if (lua_type(L, n) == 3) {
        size_t l = (size_t)luaL_checkinteger(L, n);
        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
      } else {
        const char *p = (luaL_checklstring(L, (n), ((void *)0)));
        if (*p == '*')
          p++; /* skip optional '*' (for compatibility) */
        switch (*p) {
        case 'n': /* number */
          success = read_number(L, f);
          break;
        case 'l': /* line */
          success = read_line(L, f, 1);
          break;
        case 'L': /* line with end-of-line */
          success = read_line(L, f, 0);
          break;
        case 'a':         /* file */
          read_all(L, f); /* read entire file */
          success = 1;    /* always success */
          break;
        default:
          return luaL_argerror(L, n, "invalid format");
        }
      }
    }
  }
  if (((int)(((f)->_flags & 0x0040 /* found error */) != 0)))
    return luaL_fileresult(L, 0, ((void *)0));
  if (!success) {
    lua_settop(L, -(1) - 1); /* remove last result */
    lua_pushnil(L);          /* push nil instead */
  }
  return n - first;
}

static int io_read(lua_State *L) {
  return g_read(L,
                getiofile(L, ("_IO_"
                              "input")),
                1);
}

static int f_read(lua_State *L) { return g_read(L, tofile(L), 2); }

/*
** Iteration function for 'lines'.
*/
static int io_readline(lua_State *L) {
  LStream *p = (LStream *)lua_touserdata(L, ((-1000000 - 1000) - (1)));
  int i;
  int n = (int)lua_tointegerx(L, (((-1000000 - 1000) - (2))), ((void *)0));
  if (((p)->closef == ((void *)0))) /* file is already closed? */
    return luaL_error(L, "file is already closed");
  lua_settop(L, 1);
  luaL_checkstack(L, n, "too many arguments");
  for (i = 1; i <= n; i++) /* push arguments to 'g_read' */
    lua_pushvalue(L, ((-1000000 - 1000) - (3 + i)));
  n = g_read(L, p->f, 2);   /* 'n' is number of results */
  ((void)0);                /* should return at least a nil */
  if (lua_toboolean(L, -n)) /* read at least one value? */
    return n;               /* return them */
  else {                    /* first result is nil: EOF or error */
    if (n > 1) {            /* is there error information? */
      /* 2nd result is error message */
      return luaL_error(L, "%s", lua_tolstring(L, (-n + 1), ((void *)0)));
    }
    if (lua_toboolean(
            L, ((-1000000 - 1000) - (3)))) {       /* generator created file? */
      lua_settop(L, 0);                            /* clear stack */
      lua_pushvalue(L, ((-1000000 - 1000) - (1))); /* push file at index 1 */
      aux_close(L);                                /* close it */
    }
    return 0;
  }
}

/* }====================================================== */

static int g_write(lua_State *L, FILE *f, int arg) {
  int nargs = lua_gettop(L) - arg;
  int status = 1;
  for (; nargs--; arg++) {
    if (lua_type(L, arg) == 3) {
      /* optimization: could be done exactly as for strings */
      int len = lua_isinteger(L, arg)
                    ? fprintf(f,
                              "%"
                              "ll"
                              "d",
                              (long long)lua_tointegerx(L, (arg), ((void *)0)))
                    : fprintf(f, "%.14g",
                              (double)lua_tonumberx(L, (arg), ((void *)0)));
      status = status && (len > 0);
    } else {
      size_t l;
      const char *s = luaL_checklstring(L, arg, &l);
      status = status && (fwrite(s, sizeof(char), l, f) == l);
    }
  }
  if (status)
    return 1; /* file handle already on stack top */
  else
    return luaL_fileresult(L, status, ((void *)0));
}

static int io_write(lua_State *L) {
  return g_write(L,
                 getiofile(L, ("_IO_"
                               "output")),
                 1);
}

static int f_write(lua_State *L) {
  FILE *f = tofile(L);
  lua_pushvalue(L, 1); /* push file at the stack top (to be returned) */
  return g_write(L, f, 2);
}

static int f_seek(lua_State *L) {
  static const int mode[] = {
      0 /* set file offset to offset */
      ,
      1 /* set file offset to current plus offset */
      ,
      2 /* set file offset to EOF plus offset */
  };
  static const char *const modenames[] = {"set", "cur", "end", ((void *)0)};
  FILE *f = tofile(L);
  int op = luaL_checkoption(L, 2, "cur", modenames);
  lua_Integer p3 = luaL_optinteger(L, 3, 0);
  long offset = (long)p3;
  ((void)(((lua_Integer)offset == p3) ||
          luaL_argerror(L, (3), ("not an integer in proper range"))));
  op = fseek(f, offset, mode[op]);
  if (op)
    return luaL_fileresult(L, 0, ((void *)0)); /* error */
  else {
    lua_pushinteger(L, (lua_Integer)ftell(f));
    return 1;
  }
}

static int f_setvbuf(lua_State *L) {
  static const int mode[] = {
      2 /* setvbuf should set unbuffered */
      ,
      0 /* setvbuf should set fully buffered */
      ,
      1 /* setvbuf should set line buffered */
  };
  static const char *const modenames[] = {"no", "full", "line", ((void *)0)};
  FILE *f = tofile(L);
  int op = luaL_checkoption(L, 2, ((void *)0), modenames);
  lua_Integer sz =
      luaL_optinteger(L, 3, ((int)(16 * sizeof(void *) * sizeof(lua_Number))));
  int res = setvbuf(f, ((void *)0), mode[op], (size_t)sz);
  return luaL_fileresult(L, res == 0, ((void *)0));
}

static int io_flush(lua_State *L) {
  return luaL_fileresult(L,
                         fflush(getiofile(L, ("_IO_"
                                              "output"))) == 0,
                         ((void *)0));
}

static int f_flush(lua_State *L) {
  return luaL_fileresult(L, fflush(tofile(L)) == 0, ((void *)0));
}

/*
** functions for 'io' library
*/
static const luaL_Reg iolib[] = {
    {"close", io_close}, {"flush", io_flush}, {"input", io_input},
    {"lines", io_lines}, {"open", io_open},   {"output", io_output},
    {"popen", io_popen}, {"read", io_read},   {"tmpfile", io_tmpfile},
    {"type", io_type},   {"write", io_write}, {((void *)0), ((void *)0)}};

/*
** methods for file handles
*/
static const luaL_Reg flib[] = {
    {"close", f_close},        {"flush", f_flush},
    {"lines", f_lines},        {"read", f_read},
    {"seek", f_seek},          {"setvbuf", f_setvbuf},
    {"write", f_write},        {"__gc", f_gc},
    {"__close", f_gc},         {"__tostring", f_tostring},
    {((void *)0), ((void *)0)}};

static void createmeta(lua_State *L) {
  luaL_newmetatable(L, "FILE*");  /* create metatable for file handles */
  lua_pushvalue(L, -1);           /* push metatable */
  lua_setfield(L, -2, "__index"); /* metatable.__index = metatable */
  luaL_setfuncs(L, flib, 0);      /* add file methods to new metatable */
  lua_settop(L, -(1) - 1);        /* pop new metatable */
}

/*
** function to (not) close the standard files stdin, stdout, and stderr
*/
static int io_noclose(lua_State *L) {
  LStream *p = ((LStream *)luaL_checkudata(L, 1, "FILE*"));
  p->closef = &io_noclose; /* keep file opened */
  lua_pushnil(L);
  lua_pushstring(L, ""
                    "cannot close standard file");
  return 2;
}

static void createstdfile(lua_State *L, FILE *f, const char *k,
                          const char *fname) {
  LStream *p = newprefile(L);
  p->f = f;
  p->closef = &io_noclose;
  if (k != ((void *)0)) {
    lua_pushvalue(L, -1);
    lua_setfield(L, (-1000000 - 1000), k); /* add file to registry */
  }
  lua_setfield(L, -2, fname); /* add file to module */
}

extern int luaopen_io(lua_State *L) {
  (luaL_checkversion_(L, 504, (sizeof(lua_Integer) * 16 + sizeof(lua_Number))),
   lua_createtable(L, 0, sizeof(iolib) / sizeof((iolib)[0]) - 1),
   luaL_setfuncs(L, iolib, 0)); /* new module */
  createmeta(L);
  /* create (and set) default files */
  createstdfile(L, ((__getreent())->_stdin),
                ("_IO_"
                 "input"),
                "stdin");
  createstdfile(L, ((__getreent())->_stdout),
                ("_IO_"
                 "output"),
                "stdout");
  createstdfile(L, ((__getreent())->_stderr), ((void *)0), "stderr");
  return 1;
}
/*
** $Id: lmathlib.c $
** Standard mathematical library
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 2002-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>
 */
/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */

/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * time.h
 *
 * Struct and function declarations for dealing with time.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/

static int math_abs(lua_State *L) {
  if (lua_isinteger(L, 1)) {
    lua_Integer n = lua_tointegerx(L, (1), ((void *)0));
    if (n < 0)
      n = (lua_Integer)(0u - (lua_Unsigned)n);
    lua_pushinteger(L, n);
  } else
    lua_pushnumber(L, fabs(luaL_checknumber(L, 1)));
  return 1;
}

static int math_sin(lua_State *L) {
  lua_pushnumber(L, sin(luaL_checknumber(L, 1)));
  return 1;
}

static int math_cos(lua_State *L) {
  lua_pushnumber(L, cos(luaL_checknumber(L, 1)));
  return 1;
}

static int math_tan(lua_State *L) {
  lua_pushnumber(L, tan(luaL_checknumber(L, 1)));
  return 1;
}

static int math_asin(lua_State *L) {
  lua_pushnumber(L, asin(luaL_checknumber(L, 1)));
  return 1;
}

static int math_acos(lua_State *L) {
  lua_pushnumber(L, acos(luaL_checknumber(L, 1)));
  return 1;
}

static int math_atan(lua_State *L) {
  lua_Number y = luaL_checknumber(L, 1);
  lua_Number x = luaL_optnumber(L, 2, 1);
  lua_pushnumber(L, atan2(y, x));
  return 1;
}

static int math_toint(lua_State *L) {
  int valid;
  lua_Integer n = lua_tointegerx(L, 1, &valid);
  if (valid)
    lua_pushinteger(L, n);
  else {
    luaL_checkany(L, 1);
    lua_pushnil(L); /* value is not convertible to integer */
  }
  return 1;
}

static void pushnumint(lua_State *L, lua_Number d) {
  lua_Integer n;
  if (((d) >= (double)((-0x7fffffffffffffffLL - 1)) &&
       (d) < -(double)((-0x7fffffffffffffffLL - 1)) &&
       (*(&n) = (long long)(d), 1))) /* does 'd' fit in an integer? */
    lua_pushinteger(L, n);           /* result is integer */
  else
    lua_pushnumber(L, d); /* result is float */
}

static int math_floor(lua_State *L) {
  if (lua_isinteger(L, 1))
    lua_settop(L, 1); /* integer is its own floor */
  else {
    lua_Number d = floor(luaL_checknumber(L, 1));
    pushnumint(L, d);
  }
  return 1;
}

static int math_ceil(lua_State *L) {
  if (lua_isinteger(L, 1))
    lua_settop(L, 1); /* integer is its own ceil */
  else {
    lua_Number d = ceil(luaL_checknumber(L, 1));
    pushnumint(L, d);
  }
  return 1;
}

static int math_fmod(lua_State *L) {
  if (lua_isinteger(L, 1) && lua_isinteger(L, 2)) {
    lua_Integer d = lua_tointegerx(L, (2), ((void *)0));
    if ((lua_Unsigned)d + 1u <= 1u) { /* special cases: -1 or 0 */
      ((void)((d != 0) || luaL_argerror(L, (2), ("zero"))));
      lua_pushinteger(L, 0); /* avoid overflow with 0x80000... / -1 */
    } else
      lua_pushinteger(L, lua_tointegerx(L, (1), ((void *)0)) % d);
  } else
    lua_pushnumber(L, fmod(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
  return 1;
}

/*
** next function does not use 'modf', avoiding problems with 'double*'
** (which is not compatible with 'float*') when lua_Number is not
** 'double'.
*/
static int math_modf(lua_State *L) {
  if (lua_isinteger(L, 1)) {
    lua_settop(L, 1);     /* number is its own integer part */
    lua_pushnumber(L, 0); /* no fractional part */
  } else {
    lua_Number n = luaL_checknumber(L, 1);
    /* integer part (rounds toward zero) */
    lua_Number ip = (n < 0) ? ceil(n) : floor(n);
    pushnumint(L, ip);
    /* fractional part (test needed for inf/-inf) */
    lua_pushnumber(L, (n == ip) ? 0.0 : (n - ip));
  }
  return 2;
}

static int math_sqrt(lua_State *L) {
  lua_pushnumber(L, sqrt(luaL_checknumber(L, 1)));
  return 1;
}

static int math_ult(lua_State *L) {
  lua_Integer a = luaL_checkinteger(L, 1);
  lua_Integer b = luaL_checkinteger(L, 2);
  lua_pushboolean(L, (lua_Unsigned)a < (lua_Unsigned)b);
  return 1;
}

static int math_log(lua_State *L) {
  lua_Number x = luaL_checknumber(L, 1);
  lua_Number res;
  if ((lua_type(L, (2)) <= 0))
    res = log(x);
  else {
    lua_Number base = luaL_checknumber(L, 2);

    if (base == 2.0)
      res = (log(x) / 0.693147180559945309417);
    else

        if (base == 10.0)
      res = log10(x);
    else
      res = log(x) / log(base);
  }
  lua_pushnumber(L, res);
  return 1;
}

static int math_exp(lua_State *L) {
  lua_pushnumber(L, exp(luaL_checknumber(L, 1)));
  return 1;
}

static int math_deg(lua_State *L) {
  lua_pushnumber(L, luaL_checknumber(L, 1) *
                        (180.0 / (3.141592653589793238462643383279502884)));
  return 1;
}

static int math_rad(lua_State *L) {
  lua_pushnumber(L, luaL_checknumber(L, 1) *
                        ((3.141592653589793238462643383279502884) / 180.0));
  return 1;
}

static int math_min(lua_State *L) {
  int n = lua_gettop(L); /* number of arguments */
  int imin = 1;          /* index of current minimum value */
  int i;
  ((void)((n >= 1) || luaL_argerror(L, (1), ("value expected"))));
  for (i = 2; i <= n; i++) {
    if (lua_compare(L, i, imin, 1))
      imin = i;
  }
  lua_pushvalue(L, imin);
  return 1;
}

static int math_max(lua_State *L) {
  int n = lua_gettop(L); /* number of arguments */
  int imax = 1;          /* index of current maximum value */
  int i;
  ((void)((n >= 1) || luaL_argerror(L, (1), ("value expected"))));
  for (i = 2; i <= n; i++) {
    if (lua_compare(L, imax, i, 1))
      imax = i;
  }
  lua_pushvalue(L, imax);
  return 1;
}

static int math_type(lua_State *L) {
  if (lua_type(L, 1) == 3)
    lua_pushstring(L, (lua_isinteger(L, 1)) ? "integer" : "float");
  else {
    luaL_checkany(L, 1);
    lua_pushnil(L);
  }
  return 1;
}

/*
** {==================================================================
** Pseudo-Random Number Generator based on 'xoshiro256**'.
** ===================================================================
*/

/* number of binary digits in the mantissa of a float */
/*
** LUA_RAND32 forces the use of 32-bit integers in the implementation
** of the PRN generator (mainly for testing).
*/

/* try to find an integer type with at least 64 bits */
/* there is a 'long long' type (which must have at least 64 bits) */
/*
** Standard implementation, using 64-bit integers.
** If 'Rand64' has more than 64 bits, the extra bits do not interfere
** with the 64 initial bits, except in a right shift. Moreover, the
** final result has to discard the extra bits.
*/

/* avoid using extra bits when needed */

/* rotate left 'x' by 'n' bits */
static unsigned long long rotl(unsigned long long x, int n) {
  return (x << n) | (((x)&0xffffffffffffffffu) >> (64 - n));
}

static unsigned long long nextrand(unsigned long long *state) {
  unsigned long long state0 = state[0];
  unsigned long long state1 = state[1];
  unsigned long long state2 = state[2] ^ state0;
  unsigned long long state3 = state[3] ^ state1;
  unsigned long long res = rotl(state1 * 5, 7) * 9;
  state[0] = state0 ^ state3;
  state[1] = state1 ^ state2;
  state[2] = state2 ^ (state1 << 17);
  state[3] = rotl(state3, 45);
  return res;
}

/* must take care to not shift stuff by more than 63 slots */

/*
** Convert bits from a random integer into a float in the
** interval [0,1), getting the higher FIG bits from the
** random unsigned integer and converting that to a float.
*/

/* must throw out the extra (64 - FIGS) bits */

/* to scale to [0, 1), multiply by scaleFIG = 2^(-FIGS) */

static lua_Number I2d(unsigned long long x) {
  return (lua_Number)(((x)&0xffffffffffffffffu) >> (64 - (53))) *
         (0.5 / ((unsigned long long)1 << ((53) - 1)));
}

/* convert a 'Rand64' to a 'lua_Unsigned' */

/* convert a 'lua_Unsigned' to a 'Rand64' */
/*
** A state uses four 'Rand64' values.
*/
typedef struct {
  unsigned long long s[4];
} RanState;

/*
** Project the random integer 'ran' into the interval [0, n].
** Because 'ran' has 2^B possible values, the projection can only be
** uniform when the size of the interval is a power of 2 (exact
** division).  To get a uniform projection into [0, n], we first compute
** 'lim', the smallest Mersenne number not smaller than 'n'. We then
** project 'ran' into the interval [0, lim].  If the result is inside
** [0, n], we are done. Otherwise, we try with another 'ran', until we
** have a result inside the interval.
*/
static lua_Unsigned project(lua_Unsigned ran, lua_Unsigned n, RanState *state) {
  lua_Unsigned lim = n;
  if ((lim & (lim + 1)) > 0) { /* 'lim + 1' is not a power of 2? */
    /* compute the smallest (2^b - 1) not smaller than 'n' */
    lim |= (lim >> 1);
    lim |= (lim >> 2);
    lim |= (lim >> 4);
    lim |= (lim >> 8);
    lim |= (lim >> 16);

    lim |= (lim >> 32); /* integer type has more than 32 bits */
  }
  ((void)0)

      ;                    /* and it is the smallest one */
  while ((ran &= lim) > n) /* project 'ran' into [0..lim] */
    ran = ((lua_Unsigned)(
        (nextrand(state->s)) &
        0xffffffffffffffffu)); /* not inside [0..n]? try again */
  return ran;
}

static int math_random(lua_State *L) {
  lua_Integer low, up;
  lua_Unsigned p;
  RanState *state = (RanState *)lua_touserdata(L, ((-1000000 - 1000) - (1)));
  unsigned long long rv = nextrand(state->s); /* next pseudo-random value */
  switch (lua_gettop(L)) {                    /* check number of arguments */
  case 0: {                                   /* no arguments */
    lua_pushnumber(L, I2d(rv));               /* float between 0 and 1 */
    return 1;
  }
  case 1: { /* only upper limit */
    low = 1;
    up = luaL_checkinteger(L, 1);
    if (up == 0) { /* single 0 as argument? */
      lua_pushinteger(
          L,
          ((lua_Unsigned)((rv)&0xffffffffffffffffu))); /* full random integer */
      return 1;
    }
    break;
  }
  case 2: { /* lower and upper limits */
    low = luaL_checkinteger(L, 1);
    up = luaL_checkinteger(L, 2);
    break;
  }
  default:
    return luaL_error(L, "wrong number of arguments");
  }
  /* random integer in the interval [low, up] */
  ((void)((low <= up) || luaL_argerror(L, (1), ("interval is empty"))));
  /* project random integer into the interval [0, up - low] */
  p = project(((lua_Unsigned)((rv)&0xffffffffffffffffu)),
              (lua_Unsigned)up - (lua_Unsigned)low, state);
  lua_pushinteger(L, p + (lua_Unsigned)low);
  return 1;
}

static void setseed(unsigned long long *state, lua_Unsigned n1,
                    lua_Unsigned n2) {
  int i;
  state[0] = ((unsigned long long)(n1));
  state[1] = ((unsigned long long)(0xff)); /* avoid a zero state */
  state[2] = ((unsigned long long)(n2));
  state[3] = ((unsigned long long)(0));
  for (i = 0; i < 16; i++)
    nextrand(state); /* discard initial values to "spread" seed */
}

/*
** Set a "random" seed. To get some randomness, use the current time
** and the address of 'L' (in case the machine does address space layout
** randomization).
*/
static void randseed(lua_State *L, RanState *state) {
  lua_Unsigned seed1 = (lua_Unsigned)time(((void *)0));
  lua_Unsigned seed2 = (lua_Unsigned)(size_t)L;
  setseed(state->s, seed1, seed2);
}

static int math_randomseed(lua_State *L) {
  RanState *state = (RanState *)lua_touserdata(L, ((-1000000 - 1000) - (1)));
  if ((lua_type(L, (1)) == (-1)))
    randseed(L, state);
  else {
    lua_Integer n1 = luaL_checkinteger(L, 1);
    lua_Integer n2 = luaL_optinteger(L, 2, 0);
    setseed(state->s, n1, n2);
  }
  return 0;
}

static const luaL_Reg randfuncs[] = {{"random", math_random},
                                     {"randomseed", math_randomseed},
                                     {((void *)0), ((void *)0)}};

/*
** Register the random functions and initialize their state.
*/
static void setrandfunc(lua_State *L) {
  RanState *state = (RanState *)lua_newuserdatauv(L, sizeof(RanState), 0);
  randseed(L, state); /* initialize with a "random" seed */
  luaL_setfuncs(L, randfuncs, 1);
}

/* }================================================================== */

/*
** {==================================================================
** Deprecated functions (for compatibility only)
** ===================================================================
*/
/* }================================================================== */

static const luaL_Reg mathlib[] = {{"abs", math_abs},
                                   {"acos", math_acos},
                                   {"asin", math_asin},
                                   {"atan", math_atan},
                                   {"ceil", math_ceil},
                                   {"cos", math_cos},
                                   {"deg", math_deg},
                                   {"exp", math_exp},
                                   {"tointeger", math_toint},
                                   {"floor", math_floor},
                                   {"fmod", math_fmod},
                                   {"ult", math_ult},
                                   {"log", math_log},
                                   {"max", math_max},
                                   {"min", math_min},
                                   {"modf", math_modf},
                                   {"rad", math_rad},
                                   {"sin", math_sin},
                                   {"sqrt", math_sqrt},
                                   {"tan", math_tan},
                                   {"type", math_type},
                                   /* placeholders */
                                   {"random", ((void *)0)},
                                   {"randomseed", ((void *)0)},
                                   {"pi", ((void *)0)},
                                   {"huge", ((void *)0)},
                                   {"maxinteger", ((void *)0)},
                                   {"mininteger", ((void *)0)},
                                   {((void *)0), ((void *)0)}};

/*
** Open math library
*/
extern int luaopen_math(lua_State *L) {
  (luaL_checkversion_(L, 504, (sizeof(lua_Integer) * 16 + sizeof(lua_Number))),
   lua_createtable(L, 0, sizeof(mathlib) / sizeof((mathlib)[0]) - 1),
   luaL_setfuncs(L, mathlib, 0));
  lua_pushnumber(L, (3.141592653589793238462643383279502884));
  lua_setfield(L, -2, "pi");
  lua_pushnumber(L, (lua_Number)(__builtin_huge_val()));
  lua_setfield(L, -2, "huge");
  lua_pushinteger(L, 0x7fffffffffffffffLL);
  lua_setfield(L, -2, "maxinteger");
  lua_pushinteger(L, (-0x7fffffffffffffffLL - 1));
  lua_setfield(L, -2, "mininteger");
  setrandfunc(L);
  return 1;
}
/*
** $Id: loadlib.c $
** Dynamic library loader for Lua
** See Copyright Notice in lua.h
**
** This module contains an implementation of loadlib for Unix systems
** that have dlfcn, an implementation for Windows, and a stub for other
** systems.
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/

/*
** LUA_IGMARK is a mark to ignore all before it when building the
** luaopen_ function name.
*/

/*
** LUA_CSUBSEP is the character that replaces dots in submodule names
** when searching for a C loader.
** LUA_LSUBSEP is the character that replaces dots in submodule names
** when searching for a Lua loader.
*/
/* prefix for open functions in C libraries */

/* separator for open functions in C libraries */

/*
** unique key for table in the registry that keeps handles
** for all loaded C libraries
*/
static const int CLIBS = 0;

/*
** system-dependent functions
*/

/*
** unload library 'lib'
*/
static void lsys_unloadlib(void *lib);

/*
** load C library in file 'path'. If 'seeglb', load with all names in
** the library global.
** Returns the library; in case of error, returns NULL plus an
** error string in the stack.
*/
static void *lsys_load(lua_State *L, const char *path, int seeglb);

/*
** Try to find a function named 'sym' in library 'lib'.
** Returns the function; in case of error, returns NULL plus an
** error string in the stack.
*/
static lua_CFunction lsys_sym(lua_State *L, void *lib, const char *sym);
/*
** {======================================================
** Fallback for other systems
** =======================================================
*/
static void lsys_unloadlib(void *lib) { (void)(lib); /* not used */ }

static void *lsys_load(lua_State *L, const char *path, int seeglb) {
  (void)(path);
  (void)(seeglb); /* not used */
  lua_pushstring(L,
                 ""
                 "dynamic libraries not enabled; check your Lua installation");
  return ((void *)0);
}

static lua_CFunction lsys_sym(lua_State *L, void *lib, const char *sym) {
  (void)(lib);
  (void)(sym); /* not used */
  lua_pushstring(L,
                 ""
                 "dynamic libraries not enabled; check your Lua installation");
  return ((void *)0);
}

/* }====================================================== */

/*
** {==================================================================
** Set Paths
** ===================================================================
*/

/*
** LUA_PATH_VAR and LUA_CPATH_VAR are the names of the environment
** variables that Lua check to set its paths.
*/
/*
** return registry.LUA_NOENV as a boolean
*/
static int noenv(lua_State *L) {
  int b;
  lua_getfield(L, (-1000000 - 1000), "LUA_NOENV");
  b = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1); /* remove value */
  return b;
}

/*
** Set a path
*/
static void setpath(lua_State *L, const char *fieldname, const char *envname,
                    const char *dft) {
  const char *nver = lua_pushfstring(L, "%s%s", envname,
                                     "_"
                                     "5"
                                     "_"
                                     "4");
  const char *path = getenv(nver);     /* use versioned name */
  if (path == ((void *)0))             /* no environment variable? */
    path = getenv(envname);            /* try unversioned name */
  if (path == ((void *)0) || noenv(L)) /* no environment variable? */
    lua_pushstring(L, dft);            /* use default */
  else {
    /* replace ";;" by ";AUXMARK;" and then AUXMARK by default path */
    path = luaL_gsub(L, path,
                     ";"
                     ";",
                     ";"
                     "\1" /* auxiliary mark */ ";");
    luaL_gsub(L, path, "\1" /* auxiliary mark */, dft);
    (lua_rotate(L, (-2), -1),
     lua_settop(L, -(1) - 1)); /* remove result from 1st 'gsub' */
  }
  ((void)0);
  lua_setfield(L, -3, fieldname); /* package[fieldname] = path value */
  lua_settop(L, -(1) - 1);        /* pop versioned variable name */
}

/* }================================================================== */

/*
** return registry.CLIBS[path]
*/
static void *checkclib(lua_State *L, const char *path) {
  void *plib;
  lua_rawgetp(L, (-1000000 - 1000), &CLIBS);
  lua_getfield(L, -1, path);
  plib = lua_touserdata(L, -1); /* plib = CLIBS[path] */
  lua_settop(L, -(2) - 1);      /* pop CLIBS table and 'plib' */
  return plib;
}

/*
** registry.CLIBS[path] = plib        -- for queries
** registry.CLIBS[#CLIBS + 1] = plib  -- also keep a list of all libraries
*/
static void addtoclib(lua_State *L, const char *path, void *plib) {
  lua_rawgetp(L, (-1000000 - 1000), &CLIBS);
  lua_pushlightuserdata(L, plib);
  lua_pushvalue(L, -1);
  lua_setfield(L, -3, path);               /* CLIBS[path] = plib */
  lua_rawseti(L, -2, luaL_len(L, -2) + 1); /* CLIBS[#CLIBS + 1] = plib */
  lua_settop(L, -(1) - 1);                 /* pop CLIBS table */
}

/*
** __gc tag method for CLIBS table: calls 'lsys_unloadlib' for all lib
** handles in list CLIBS
*/
static int gctm(lua_State *L) {
  lua_Integer n = luaL_len(L, 1);
  for (; n >= 1; n--) {   /* for each handle, in reverse order */
    lua_rawgeti(L, 1, n); /* get handle CLIBS[n] */
    lsys_unloadlib(lua_touserdata(L, -1));
    lua_settop(L, -(1) - 1); /* pop handle */
  }
  return 0;
}

/* error codes for 'lookforfunc' */

/*
** Look for a C function named 'sym' in a dynamically loaded library
** 'path'.
** First, check whether the library is already loaded; if not, try
** to load it.
** Then, if 'sym' is '*', return true (as library has been loaded).
** Otherwise, look for symbol 'sym' in the library and push a
** C function with that symbol.
** Return 0 and 'true' or a function in the stack; in case of
** errors, return an error code and an error message in the stack.
*/
static int lookforfunc(lua_State *L, const char *path, const char *sym) {
  void *reg = checkclib(L, path);          /* check loaded C libraries */
  if (reg == ((void *)0)) {                /* must load library? */
    reg = lsys_load(L, path, *sym == '*'); /* global symbols if 'sym'=='*' */
    if (reg == ((void *)0))
      return 1; /* unable to load library */
    addtoclib(L, path, reg);
  }
  if (*sym == '*') {       /* loading only library (no function)? */
    lua_pushboolean(L, 1); /* return 'true' */
    return 0;              /* no errors */
  } else {
    lua_CFunction f = lsys_sym(L, reg, sym);
    if (f == ((void *)0))
      return 2;                  /* unable to find function */
    lua_pushcclosure(L, (f), 0); /* else create new function */
    return 0;                    /* no errors */
  }
}

static int ll_loadlib(lua_State *L) {
  const char *path = (luaL_checklstring(L, (1), ((void *)0)));
  const char *init = (luaL_checklstring(L, (2), ((void *)0)));
  int stat = lookforfunc(L, path, init);
  if (stat == 0) /* no errors? */
    return 1;    /* return the loaded function */
  else {         /* error; error message is on stack top */
    lua_pushnil(L);
    lua_rotate(L, (-2), 1);
    lua_pushstring(L, (stat == 1) ? "absent" : "init");
    return 3; /* return nil, error message, and where */
  }
}

/*
** {======================================================
** 'require' function
** =======================================================
*/

static int readable(const char *filename) {
  FILE *f = fopen(filename, "r"); /* try to open file */
  if (f == ((void *)0))
    return 0; /* open failed */
  fclose(f);
  return 1;
}

static const char *pushnextfilename(lua_State *L, const char *path) {
  const char *l;
  if (*path == *";")
    path++; /* skip separator */
  if (*path == '\0')
    return ((void *)0);               /* no more names */
  l = strchr(path, *";");             /* find next separator */
  if (l == ((void *)0))               /* no more separators? */
    l = path + strlen(path);          /* go until the end */
  lua_pushlstring(L, path, l - path); /* file name */
  return l;                           /* rest of the path */
}

/*
** Given a path such as ";blabla.so;blublu.so", pushes the string
**
** 	no file 'blabla.so'
**	no file 'blublu.so'
*/
static void pusherrornotfound(lua_State *L, const char *path) {
  if (*path == *";")
    path++; /* skip separator */
  lua_pushstring(L, "\n\tno file '");
  luaL_gsub(L, path, ";", "'\n\tno file '");
  lua_pushstring(L, "'");
  lua_concat(L, 3);
}

static const char *searchpath(lua_State *L, const char *name, const char *path,
                              const char *sep, const char *dirsep) {
  /* separator is non-empty and appears in 'name'? */
  if (*sep != '\0' && strchr(name, *sep) != ((void *)0))
    name = luaL_gsub(L, name, sep, dirsep); /* replace it by 'dirsep' */
  /* replace marks ('?') in 'path' by the file name */
  path = luaL_gsub(L, path, "?", name);
  while ((path = pushnextfilename(L, path)) != ((void *)0)) {
    const char *filename = lua_tolstring(L, (-1), ((void *)0));
    if (readable(filename))  /* does file exist and is readable? */
      return filename;       /* return that file name */
    lua_settop(L, -(1) - 1); /* else remove file name */
  }
  pusherrornotfound(
      L, lua_tolstring(L, (-1), ((void *)0))); /* create error message */
  return ((void *)0);                          /* not found */
}

static int ll_searchpath(lua_State *L) {
  const char *f = searchpath(L, (luaL_checklstring(L, (1), ((void *)0))),
                             (luaL_checklstring(L, (2), ((void *)0))),
                             (luaL_optlstring(L, (3), ("."), ((void *)0))),
                             (luaL_optlstring(L, (4), ("/"), ((void *)0))));
  if (f != ((void *)0))
    return 1;
  else { /* error message is on top of the stack */
    lua_pushnil(L);
    lua_rotate(L, (-2), 1);
    return 2; /* return nil + error message */
  }
}

static const char *findfile(lua_State *L, const char *name, const char *pname,
                            const char *dirsep) {
  const char *path;
  lua_getfield(L, ((-1000000 - 1000) - (1)), pname);
  path = lua_tolstring(L, (-1), ((void *)0));
  if (path == ((void *)0))
    luaL_error(L, "'package.%s' must be a string", pname);
  return searchpath(L, name, path, ".", dirsep);
}

static int checkload(lua_State *L, int stat, const char *filename) {
  if (stat) {                    /* module loaded successfully? */
    lua_pushstring(L, filename); /* will be 2nd argument to module */
    return 2;                    /* return open function and file name */
  } else
    return luaL_error(L, "error loading module '%s' from file '%s':\n\t%s",
                      lua_tolstring(L, (1), ((void *)0)), filename,
                      lua_tolstring(L, (-1), ((void *)0)));
}

static int searcher_Lua(lua_State *L) {
  const char *filename;
  const char *name = (luaL_checklstring(L, (1), ((void *)0)));
  filename = findfile(L, name, "path", "/");
  if (filename == ((void *)0))
    return 1; /* module not found in this path */
  return checkload(L, (luaL_loadfilex(L, filename, ((void *)0)) == 0),
                   filename);
}

/*
** Try to find a load function for module 'modname' at file 'filename'.
** First, change '.' to '_' in 'modname'; then, if 'modname' has
** the form X-Y (that is, it has an "ignore mark"), build a function
** name "luaopen_X" and look for it. (For compatibility, if that
** fails, it also tries "luaopen_Y".) If there is no ignore mark,
** look for a function named "luaopen_modname".
*/
static int loadfunc(lua_State *L, const char *filename, const char *modname) {
  const char *openfunc;
  const char *mark;
  modname = luaL_gsub(L, modname, ".", "_");
  mark = strchr(modname, *"-");
  if (mark) {
    int stat;
    openfunc = lua_pushlstring(L, modname, mark - modname);
    openfunc = lua_pushfstring(L,
                               "luaopen_"
                               "%s",
                               openfunc);
    stat = lookforfunc(L, filename, openfunc);
    if (stat != 2)
      return stat;
    modname = mark + 1; /* else go ahead and try old-style name */
  }
  openfunc = lua_pushfstring(L,
                             "luaopen_"
                             "%s",
                             modname);
  return lookforfunc(L, filename, openfunc);
}

static int searcher_C(lua_State *L) {
  const char *name = (luaL_checklstring(L, (1), ((void *)0)));
  const char *filename = findfile(L, name, "cpath", "/");
  if (filename == ((void *)0))
    return 1; /* module not found in this path */
  return checkload(L, (loadfunc(L, filename, name) == 0), filename);
}

static int searcher_Croot(lua_State *L) {
  const char *filename;
  const char *name = (luaL_checklstring(L, (1), ((void *)0)));
  const char *p = strchr(name, '.');
  int stat;
  if (p == ((void *)0))
    return 0; /* is root */
  lua_pushlstring(L, name, p - name);
  filename = findfile(L, lua_tolstring(L, (-1), ((void *)0)), "cpath", "/");
  if (filename == ((void *)0))
    return 1; /* root not found */
  if ((stat = loadfunc(L, filename, name)) != 0) {
    if (stat != 2)
      return checkload(L, 0, filename); /* real error */
    else {                              /* open function not found */
      lua_pushfstring(L, "\n\tno module '%s' in file '%s'", name, filename);
      return 1;
    }
  }
  lua_pushstring(L, filename); /* will be 2nd argument to module */
  return 2;
}

static int searcher_preload(lua_State *L) {
  const char *name = (luaL_checklstring(L, (1), ((void *)0)));
  lua_getfield(L, (-1000000 - 1000), "_PRELOAD");
  if (lua_getfield(L, -1, name) == 0) /* not found? */
    lua_pushfstring(L, "\n\tno field package.preload['%s']", name);
  return 1;
}

static void findloader(lua_State *L, const char *name) {
  int i;
  luaL_Buffer msg; /* to build error message */
  /* push 'package.searchers' to index 3 in the stack */
  if (lua_getfield(L, ((-1000000 - 1000) - (1)), "searchers") != 5)
    luaL_error(L, "'package.searchers' must be a table");
  luaL_buffinit(L, &msg);
  /*  iterate over available searchers to find a loader */
  for (i = 1;; i++) {
    if (lua_rawgeti(L, 3, i) == 0) { /* no more searchers? */
      lua_settop(L, -(1) - 1);       /* remove nil */
      luaL_pushresult(&msg);         /* create error message */
      luaL_error(L, "module '%s' not found:%s", name,
                 lua_tolstring(L, (-1), ((void *)0)));
    }
    lua_pushstring(L, name);
    lua_callk(L, (1), (2), 0, ((void *)0)); /* call it */
    if ((lua_type(L, (-2)) == 6))           /* did it find a loader? */
      return;                               /* module loader found */
    else if (lua_isstring(L, -2)) { /* searcher returned error message? */
      lua_settop(L, -(1) - 1);      /* remove extra return */
      luaL_addvalue(&msg);          /* concatenate error message */
    } else
      lua_settop(L, -(2) - 1); /* remove both returns */
  }
}

static int ll_require(lua_State *L) {
  const char *name = (luaL_checklstring(L, (1), ((void *)0)));
  lua_settop(L, 1); /* LOADED table will be at index 2 */
  lua_getfield(L, (-1000000 - 1000), "_LOADED");
  lua_getfield(L, 2, name); /* LOADED[name] */
  if (lua_toboolean(L, -1)) /* is it there? */
    return 1;               /* package is already loaded */
  /* else must load package */
  lua_settop(L, -(1) - 1); /* remove 'getfield' result */
  findloader(L, name);
  lua_pushstring(L, name); /* pass name as argument to module loader */
  lua_rotate(L, (-2), 1);  /* name is 1st argument (before search data) */
  lua_callk(L, (2), (1), 0, ((void *)0)); /* run loader to load module */
  if (!(lua_type(L, (-1)) == 0))          /* non-nil return? */
    lua_setfield(L, 2, name);             /* LOADED[name] = returned value */
  if (lua_getfield(L, 2, name) == 0) {    /* module set no value? */
    lua_pushboolean(L, 1);                /* use true as result */
    lua_pushvalue(L, -1);                 /* extra copy to be returned */
    lua_setfield(L, 2, name);             /* LOADED[name] = true */
  }
  return 1;
}

/* }====================================================== */

static const luaL_Reg pk_funcs[] = {{"loadlib", ll_loadlib},
                                    {"searchpath", ll_searchpath},
                                    /* placeholders */
                                    {"preload", ((void *)0)},
                                    {"cpath", ((void *)0)},
                                    {"path", ((void *)0)},
                                    {"searchers", ((void *)0)},
                                    {"loaded", ((void *)0)},
                                    {((void *)0), ((void *)0)}};

static const luaL_Reg ll_funcs[] = {{"require", ll_require},
                                    {((void *)0), ((void *)0)}};

static void createsearcherstable(lua_State *L) {
  static const lua_CFunction searchers[] = {
      searcher_preload, searcher_Lua, searcher_C, searcher_Croot, ((void *)0)};
  int i;
  /* create 'searchers' table */
  lua_createtable(L, sizeof(searchers) / sizeof(searchers[0]) - 1, 0);
  /* fill it with predefined searchers */
  for (i = 0; searchers[i] != ((void *)0); i++) {
    lua_pushvalue(L, -2); /* set 'package' as upvalue for all searchers */
    lua_pushcclosure(L, searchers[i], 1);
    lua_rawseti(L, -2, i + 1);
  }
  lua_setfield(L, -2, "searchers"); /* put it in field 'searchers' */
}

/*
** create table CLIBS to keep track of loaded C libraries,
** setting a finalizer to close all libraries when closing state.
*/
static void createclibstable(lua_State *L) {
  lua_createtable(L, 0, 0); /* create CLIBS table */
  lua_createtable(L, 0, 1); /* create metatable for CLIBS */
  lua_pushcclosure(L, (gctm), 0);
  lua_setfield(L, -2, "__gc"); /* set finalizer for CLIBS table */
  lua_setmetatable(L, -2);
  lua_rawsetp(L, (-1000000 - 1000), &CLIBS); /* set CLIBS table in registry */
}

extern int luaopen_package(lua_State *L) {
  createclibstable(L);
  (luaL_checkversion_(L, 504, (sizeof(lua_Integer) * 16 + sizeof(lua_Number))),
   lua_createtable(L, 0, sizeof(pk_funcs) / sizeof((pk_funcs)[0]) - 1),
   luaL_setfuncs(L, pk_funcs, 0)); /* create 'package' table */
  createsearcherstable(L);
  /* set paths */
  setpath(L, "path", "LUA_PATH",
          "/usr/local/"
          "share/lua/"
          "5"
          "."
          "4"
          "/"
          "?.lua;"
          "/usr/local/"
          "share/lua/"
          "5"
          "."
          "4"
          "/"
          "?/init.lua;"
          "/usr/local/"
          "lib/lua/"
          "5"
          "."
          "4"
          "/"
          "?.lua;"
          "/usr/local/"
          "lib/lua/"
          "5"
          "."
          "4"
          "/"
          "?/init.lua;"
          "./?.lua;"
          "./?/init.lua");
  setpath(L, "cpath", "LUA_CPATH",
          "/usr/local/"
          "lib/lua/"
          "5"
          "."
          "4"
          "/"
          "?.so;"
          "/usr/local/"
          "lib/lua/"
          "5"
          "."
          "4"
          "/"
          "loadall.so;"
          "./?.so");
  /* store config information */
  lua_pushstring(L, ""
                    "/"
                    "\n"
                    ";"
                    "\n"
                    "?"
                    "\n"
                    "!"
                    "\n"
                    "-"
                    "\n");
  lua_setfield(L, -2, "config");
  /* set field 'loaded' */
  luaL_getsubtable(L, (-1000000 - 1000), "_LOADED");
  lua_setfield(L, -2, "loaded");
  /* set field 'preload' */
  luaL_getsubtable(L, (-1000000 - 1000), "_PRELOAD");
  lua_setfield(L, -2, "preload");
  ((void)lua_rawgeti(L, (-1000000 - 1000), 2));
  lua_pushvalue(L, -2);          /* set 'package' as upvalue for next lib */
  luaL_setfuncs(L, ll_funcs, 1); /* open lib into global table */
  lua_settop(L, -(1) - 1);       /* pop global table */
  return 1;                      /* return 'package' table */
}
/*
** $Id: loslib.c $
** Standard Operating System library
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
        locale.h
        Values appropriate for the formatting of monetary and other
        numberic quantities.
*/
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */
/*
 * time.h
 *
 * Struct and function declarations for dealing with time.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/

/*
** {==================================================================
** List of valid conversion specifiers for the 'strftime' function;
** options are grouped by length; group of length 2 start with '||'.
** ===================================================================
*/

/* options for ANSI C 89 (only 1-char options) */

/* options for ISO C 99 and POSIX */

/* options for Windows */
/* }================================================================== */

/*
** {==================================================================
** Configuration for time-related stuff
** ===================================================================
*/

/*
** type to represent time_t in Lua
*/

static time_t l_checktime(lua_State *L, int arg) {
  lua_Integer t = luaL_checkinteger(L, arg);
  ((void)(((time_t)t == t) || luaL_argerror(L, (arg), ("time out-of-bounds"))));
  return (time_t)t;
}

/*
** By default, Lua uses gmtime/localtime, except when POSIX is available,
** where it uses gmtime_r/localtime_r
*/
/* ISO C definitions */

/* }================================================================== */

/*
** {==================================================================
** Configuration for 'tmpnam':
** By default, Lua uses tmpnam except when POSIX is available, where
** it uses mkstemp.
** ===================================================================
*/
/* ISO C definitions */

/* }================================================================== */

static int os_execute(lua_State *L) {
  const char *cmd = (luaL_optlstring(L, (1), (((void *)0)), ((void *)0)));
  int stat = system(cmd);
  if (cmd != ((void *)0))
    return luaL_execresult(L, stat);
  else {
    lua_pushboolean(L, stat); /* true if there is a shell */
    return 1;
  }
}

static int os_remove(lua_State *L) {
  const char *filename = (luaL_checklstring(L, (1), ((void *)0)));
  return luaL_fileresult(L, remove(filename) == 0, filename);
}

static int os_rename(lua_State *L) {
  const char *fromname = (luaL_checklstring(L, (1), ((void *)0)));
  const char *toname = (luaL_checklstring(L, (2), ((void *)0)));
  return luaL_fileresult(L, rename(fromname, toname) == 0, ((void *)0));
}

static int os_tmpname(lua_State *L) {
  char buff[4096 /* Keep in sync with PATH_MAX in limits.h. */
  ];
  int err;
  { err = (tmpnam(buff) == ((void *)0)); };
  if (err)
    return luaL_error(L, "unable to generate a unique filename");
  lua_pushstring(L, buff);
  return 1;
}

static int os_getenv(lua_State *L) {
  lua_pushstring(
      L,
      getenv((luaL_checklstring(L, (1), ((void *)0))))); /* if NULL push nil */
  return 1;
}

static int os_clock(lua_State *L) {
  lua_pushnumber(L, ((lua_Number)clock()) / (lua_Number)1000);
  return 1;
}

/*
** {======================================================
** Time/Date operations
** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
**   wday=%w+1, yday=%j, isdst=? }
** =======================================================
*/

static void setfield(lua_State *L, const char *key, int value) {
  lua_pushinteger(L, value);
  lua_setfield(L, -2, key);
}

static void setboolfield(lua_State *L, const char *key, int value) {
  if (value < 0) /* undefined? */
    return;      /* does not set field */
  lua_pushboolean(L, value);
  lua_setfield(L, -2, key);
}

/*
** Set all fields from structure 'tm' in the table on top of the stack
*/
static void setallfields(lua_State *L, struct tm *stm) {
  setfield(L, "sec", stm->tm_sec);
  setfield(L, "min", stm->tm_min);
  setfield(L, "hour", stm->tm_hour);
  setfield(L, "day", stm->tm_mday);
  setfield(L, "month", stm->tm_mon + 1);
  setfield(L, "year", stm->tm_year + 1900);
  setfield(L, "wday", stm->tm_wday + 1);
  setfield(L, "yday", stm->tm_yday + 1);
  setboolfield(L, "isdst", stm->tm_isdst);
}

static int getboolfield(lua_State *L, const char *key) {
  int res;
  res = (lua_getfield(L, -1, key) == 0) ? -1 : lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  return res;
}

/* maximum value for date fields (to avoid arithmetic overflows with 'int') */

static int getfield(lua_State *L, const char *key, int d, int delta) {
  int isnum;
  int t = lua_getfield(L, -1, key); /* get field and its type */
  lua_Integer res = lua_tointegerx(L, -1, &isnum);
  if (!isnum) { /* field is not an integer? */
    if (t != 0) /* some other value? */
      return luaL_error(L, "field '%s' is not an integer", key);
    else if (d < 0) /* absent field; no default? */
      return luaL_error(L, "field '%s' missing in date table", key);
    res = d;
  } else {
    if (!(-(0x7fffffff / 2) <= res && res <= (0x7fffffff / 2)))
      return luaL_error(L, "field '%s' is out-of-bound", key);
    res -= delta;
  }
  lua_settop(L, -(1) - 1);
  return (int)res;
}

static const char *checkoption(lua_State *L, const char *conv,
                               ptrdiff_t convlen, char *buff) {
  const char *option = "aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%"
                       "||"
                       "EcECExEXEyEY"
                       "OdOeOHOIOmOMOSOuOUOVOwOWOy" /* two-char options */;
  int oplen = 1; /* length of options being checked */
  for (; *option != '\0' && oplen <= convlen; option += oplen) {
    if (*option == '|') /* next block? */
      oplen++;          /* will check options with next length (+1) */
    else if (memcmp(conv, option, oplen) == 0) { /* match? */
      memcpy(buff, conv, oplen); /* copy valid option to buffer */
      buff[oplen] = '\0';
      return conv + oplen; /* return next item */
    }
  }
  luaL_argerror(
      L, 1, lua_pushfstring(L, "invalid conversion specifier '%%%s'", conv));
  return conv; /* to avoid warnings */
}

/* maximum size for an individual 'strftime' item */

static int os_date(lua_State *L) {
  size_t slen;
  const char *s = luaL_optlstring(L, 1, "%c", &slen);
  time_t t =
      ((lua_type(L, ((2))) <= 0) ? (time(((void *)0))) : l_checktime(L, (2)));
  const char *se = s + slen; /* 's' end */
  struct tm tmr, *stm;
  if (*s == '!') { /* UTC? */
    stm = ((void)(&tmr)->tm_sec, gmtime(&t));
    s++; /* skip '!' */
  } else
    stm = ((void)(&tmr)->tm_sec, localtime(&t));
  if (stm == ((void *)0)) /* invalid date? */
    return luaL_error(L,
                      "time result cannot be represented in this installation");
  if (strcmp(s, "*t") == 0) {
    lua_createtable(L, 0, 9); /* 9 = number of fields */
    setallfields(L, stm);
  } else {
    char cc[4]; /* buffer for individual conversion specifiers */
    luaL_Buffer b;
    cc[0] = '%';
    luaL_buffinit(L, &b);
    while (s < se) {
      if (*s != '%') /* not a conversion specifier? */
        ((void)((&b)->n < (&b)->size || luaL_prepbuffsize((&b), 1)),
         ((&b)->b[(&b)->n++] = (*s++)));
      else {
        size_t reslen;
        char *buff = luaL_prepbuffsize(&b, 250);
        s++;                                   /* skip '%' */
        s = checkoption(L, s, se - s, cc + 1); /* copy specifier to 'cc' */
        reslen = strftime(buff, 250, cc, stm);
        ((&b)->n += (reslen));
      }
    }
    luaL_pushresult(&b);
  }
  return 1;
}

static int os_time(lua_State *L) {
  time_t t;
  if ((lua_type(L, (1)) <= 0)) /* called without args? */
    t = time(((void *)0));     /* get current time */
  else {
    struct tm ts;
    luaL_checktype(L, 1, 5);
    lua_settop(L, 1); /* make sure table is at the top */
    ts.tm_sec = getfield(L, "sec", 0, 0);
    ts.tm_min = getfield(L, "min", 0, 0);
    ts.tm_hour = getfield(L, "hour", 12, 0);
    ts.tm_mday = getfield(L, "day", -1, 0);
    ts.tm_mon = getfield(L, "month", -1, 1);
    ts.tm_year = getfield(L, "year", -1, 1900);
    ts.tm_isdst = getboolfield(L, "isdst");
    t = mktime(&ts);
    setallfields(L, &ts); /* update fields with normalized values */
  }
  if (t != (time_t)(lua_Integer)t || t == (time_t)(-1))
    return luaL_error(L,
                      "time result cannot be represented in this installation");
  lua_pushinteger(L, (lua_Integer)(t));
  return 1;
}

static int os_difftime(lua_State *L) {
  time_t t1 = l_checktime(L, 1);
  time_t t2 = l_checktime(L, 2);
  lua_pushnumber(L, (lua_Number)difftime(t1, t2));
  return 1;
}

/* }====================================================== */

static int os_setlocale(lua_State *L) {
  static const int cat[] = {0, 1, 2, 3,

                            4, 5};
  static const char *const catnames[] = {
      "all", "collate", "ctype", "monetary", "numeric", "time", ((void *)0)};
  const char *l = (luaL_optlstring(L, (1), (((void *)0)), ((void *)0)));
  int op = luaL_checkoption(L, 2, "all", catnames);
  lua_pushstring(L, setlocale(cat[op], l));
  return 1;
}

static int os_exit(lua_State *L) {
  int status;
  if ((lua_type(L, (1)) == 1))
    status = (lua_toboolean(L, 1) ? 0 : 1);
  else
    status = (int)luaL_optinteger(L, 1, 0);
  if (lua_toboolean(L, 2))
    lua_close(L);
  if (L)
    exit(status); /* 'if' to avoid warnings for unreachable 'return' */
  return 0;
}

static const luaL_Reg syslib[] = {
    {"clock", os_clock},         {"date", os_date},
    {"difftime", os_difftime},   {"execute", os_execute},
    {"exit", os_exit},           {"getenv", os_getenv},
    {"remove", os_remove},       {"rename", os_rename},
    {"setlocale", os_setlocale}, {"time", os_time},
    {"tmpname", os_tmpname},     {((void *)0), ((void *)0)}};

/* }====================================================== */

extern int luaopen_os(lua_State *L) {
  (luaL_checkversion_(L, 504, (sizeof(lua_Integer) * 16 + sizeof(lua_Number))),
   lua_createtable(L, 0, sizeof(syslib) / sizeof((syslib)[0]) - 1),
   luaL_setfuncs(L, syslib, 0));
  return 1;
}
/*
** $Id: lstrlib.c $
** Standard library for string operations and pattern-matching
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 2002-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>
 */
/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
/*
        locale.h
        Values appropriate for the formatting of monetary and other
        numberic quantities.
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/

/*
** maximum number of captures that a pattern can do during
** pattern-matching. This limit is arbitrary, but must fit in
** an unsigned char.
*/

/* macro to 'unsign' a character */

/*
** Some sizes are better limited to fit in 'int', but must also fit in
** 'size_t'. (We assume that 'lua_Integer' cannot be smaller than 'int'.)
*/
static int str_len(lua_State *L) {
  size_t l;
  luaL_checklstring(L, 1, &l);
  lua_pushinteger(L, (lua_Integer)l);
  return 1;
}

/*
** translate a relative initial string position
** (negative means back from end): clip result to [1, inf).
** The length of any string in Lua must fit in a lua_Integer,
** so there are no overflows in the casts.
** The inverted comparison avoids a possible overflow
** computing '-pos'.
*/
static size_t posrelatI(lua_Integer pos, size_t len) {
  if (pos > 0)
    return (size_t)pos;
  else if (pos == 0)
    return 1;
  else if (pos < -(lua_Integer)len) /* inverted comparison */
    return 1;                       /* clip to 1 */
  else
    return len + (size_t)pos + 1;
}

/*
** Gets an optional ending string position from argument 'arg',
** with default value 'def'.
** Negative means back from end: clip result to [0, len]
*/
static size_t getendpos(lua_State *L, int arg, lua_Integer def, size_t len) {
  lua_Integer pos = luaL_optinteger(L, arg, def);
  if (pos > (lua_Integer)len)
    return len;
  else if (pos >= 0)
    return (size_t)pos;
  else if (pos < -(lua_Integer)len)
    return 0;
  else
    return len + (size_t)pos + 1;
}

static int str_sub(lua_State *L) {
  size_t l;
  const char *s = luaL_checklstring(L, 1, &l);
  size_t start = posrelatI(luaL_checkinteger(L, 2), l);
  size_t end = getendpos(L, 3, -1, l);
  if (start <= end)
    lua_pushlstring(L, s + start - 1, (end - start) + 1);
  else
    lua_pushstring(L, ""
                      "");
  return 1;
}

static int str_reverse(lua_State *L) {
  size_t l, i;
  luaL_Buffer b;
  const char *s = luaL_checklstring(L, 1, &l);
  char *p = luaL_buffinitsize(L, &b, l);
  for (i = 0; i < l; i++)
    p[i] = s[l - i - 1];
  luaL_pushresultsize(&b, l);
  return 1;
}

static int str_lower(lua_State *L) {
  size_t l;
  size_t i;
  luaL_Buffer b;
  const char *s = luaL_checklstring(L, 1, &l);
  char *p = luaL_buffinitsize(L, &b, l);
  for (i = 0; i < l; i++)
    p[i] = __extension__({
      __typeof__(((unsigned char)(s[i]))) __x = (((unsigned char)(s[i])));
      (void)(__locale_ctype_ptr())[__x];
      (tolower)(__x);
    });
  luaL_pushresultsize(&b, l);
  return 1;
}

static int str_upper(lua_State *L) {
  size_t l;
  size_t i;
  luaL_Buffer b;
  const char *s = luaL_checklstring(L, 1, &l);
  char *p = luaL_buffinitsize(L, &b, l);
  for (i = 0; i < l; i++)
    p[i] = __extension__({
      __typeof__(((unsigned char)(s[i]))) __x = (((unsigned char)(s[i])));
      (void)(__locale_ctype_ptr())[__x];
      (toupper)(__x);
    });
  luaL_pushresultsize(&b, l);
  return 1;
}

static int str_rep(lua_State *L) {
  size_t l, lsep;
  const char *s = luaL_checklstring(L, 1, &l);
  lua_Integer n = luaL_checkinteger(L, 2);
  const char *sep = luaL_optlstring(L, 3, "", &lsep);
  if (n <= 0)
    lua_pushstring(L, ""
                      "");
  else if (l + lsep < l ||
           l + lsep > (sizeof(size_t) < sizeof(int) ? ((size_t)(~(size_t)0))
                                                    : (size_t)(0x7fffffff)) /
                          n) /* may overflow? */
    return luaL_error(L, "resulting string too large");
  else {
    size_t totallen = (size_t)n * l + (size_t)(n - 1) * lsep;
    luaL_Buffer b;
    char *p = luaL_buffinitsize(L, &b, totallen);
    while (n-- > 1) { /* first n-1 copies (followed by separator) */
      memcpy(p, s, l * sizeof(char));
      p += l;
      if (lsep > 0) { /* empty 'memcpy' is not that cheap */
        memcpy(p, sep, lsep * sizeof(char));
        p += lsep;
      }
    }
    memcpy(p, s, l * sizeof(char)); /* last copy (not followed by separator) */
    luaL_pushresultsize(&b, totallen);
  }
  return 1;
}

static int str_byte(lua_State *L) {
  size_t l;
  const char *s = luaL_checklstring(L, 1, &l);
  lua_Integer pi = luaL_optinteger(L, 2, 1);
  size_t posi = posrelatI(pi, l);
  size_t pose = getendpos(L, 3, pi, l);
  int n, i;
  if (posi > pose)
    return 0;                            /* empty interval; return no values */
  if (pose - posi >= (size_t)0x7fffffff) /* arithmetic overflow? */
    return luaL_error(L, "string slice too long");
  n = (int)(pose - posi) + 1;
  luaL_checkstack(L, n, "string slice too long");
  for (i = 0; i < n; i++)
    lua_pushinteger(L, ((unsigned char)(s[posi + i - 1])));
  return n;
}

static int str_char(lua_State *L) {
  int n = lua_gettop(L); /* number of arguments */
  int i;
  luaL_Buffer b;
  char *p = luaL_buffinitsize(L, &b, n);
  for (i = 1; i <= n; i++) {
    lua_Unsigned c = (lua_Unsigned)luaL_checkinteger(L, i);
    ((void)((c <= (lua_Unsigned)255) ||
            luaL_argerror(L, (i), ("value out of range"))));
    p[i - 1] = ((unsigned char)(c));
  }
  luaL_pushresultsize(&b, n);
  return 1;
}

static int writer(lua_State *L, const void *b, size_t size, void *B) {
  (void)L;
  luaL_addlstring((luaL_Buffer *)B, (const char *)b, size);
  return 0;
}

static int str_dump(lua_State *L) {
  luaL_Buffer b;
  int strip = lua_toboolean(L, 2);
  luaL_checktype(L, 1, 6);
  lua_settop(L, 1);
  luaL_buffinit(L, &b);
  if (lua_dump(L, writer, &b, strip) != 0)
    return luaL_error(L, "unable to dump given function");
  luaL_pushresult(&b);
  return 1;
}

/*
** {======================================================
** METAMETHODS
** =======================================================
*/

static int tonum(lua_State *L, int arg) {
  if (lua_type(L, arg) == 3) { /* already a number? */
    lua_pushvalue(L, arg);
    return 1;
  } else { /* check whether it is a numerical string */
    size_t len;
    const char *s = lua_tolstring(L, arg, &len);
    return (s != ((void *)0) && lua_stringtonumber(L, s) == len + 1);
  }
}

static void trymt(lua_State *L, const char *mtname) {
  lua_settop(L, 2); /* back to the original arguments */
  if (lua_type(L, 2) == 4 || !luaL_getmetafield(L, 2, mtname))
    luaL_error(L, "attempt to %s a '%s' with a '%s'", mtname + 2,
               lua_typename(L, lua_type(L, (-2))),
               lua_typename(L, lua_type(L, (-1))));
  lua_rotate(L, (-3), 1);                 /* put metamethod before arguments */
  lua_callk(L, (2), (1), 0, ((void *)0)); /* call metamethod */
}

static int arith(lua_State *L, int op, const char *mtname) {
  if (tonum(L, 1) && tonum(L, 2))
    lua_arith(L, op); /* result will be on the top */
  else
    trymt(L, mtname);
  return 1;
}

static int arith_add(lua_State *L) {
  return arith(L, 0 /* ORDER TM, ORDER OP */, "__add");
}

static int arith_sub(lua_State *L) { return arith(L, 1, "__sub"); }

static int arith_mul(lua_State *L) { return arith(L, 2, "__mul"); }

static int arith_mod(lua_State *L) { return arith(L, 3, "__mod"); }

static int arith_pow(lua_State *L) { return arith(L, 4, "__pow"); }

static int arith_div(lua_State *L) { return arith(L, 5, "__div"); }

static int arith_idiv(lua_State *L) { return arith(L, 6, "__idiv"); }

static int arith_unm(lua_State *L) { return arith(L, 12, "__unm"); }

static const luaL_Reg stringmetamethods[] = {
    {"__add", arith_add},      {"__sub", arith_sub},
    {"__mul", arith_mul},      {"__mod", arith_mod},
    {"__pow", arith_pow},      {"__div", arith_div},
    {"__idiv", arith_idiv},    {"__unm", arith_unm},
    {"__index", ((void *)0)}, /* placeholder */
    {((void *)0), ((void *)0)}};

/* }====================================================== */

/*
** {======================================================
** PATTERN MATCHING
** =======================================================
*/

typedef struct MatchState {
  const char *src_init; /* init of source string */
  const char *src_end;  /* end ('\0') of source string */
  const char *p_end;    /* end ('\0') of pattern */
  lua_State *L;
  int matchdepth; /* control for recursive depth (to avoid C stack overflow) */
  unsigned char level; /* total number of captures (finished or unfinished) */
  struct {
    const char *init;
    ptrdiff_t len;
  } capture[32];
} MatchState;

/* recursive function */
static const char *match(MatchState *ms, const char *s, const char *p);

/* maximum recursion depth for 'match' */
static int check_capture(MatchState *ms, int l) {
  l -= '1';
  if (l < 0 || l >= ms->level || ms->capture[l].len == (-1))
    return luaL_error(ms->L, "invalid capture index %%%d", l + 1);
  return l;
}

static int capture_to_close(MatchState *ms) {
  int level = ms->level;
  for (level--; level >= 0; level--)
    if (ms->capture[level].len == (-1))
      return level;
  return luaL_error(ms->L, "invalid pattern capture");
}

static const char *classend(MatchState *ms, const char *p) {
  switch (*p++) {
  case '%': {
    if (p == ms->p_end)
      luaL_error(ms->L, "malformed pattern (ends with '%%')");
    return p + 1;
  }
  case '[': {
    if (*p == '^')
      p++;
    do { /* look for a ']' */
      if (p == ms->p_end)
        luaL_error(ms->L, "malformed pattern (missing ']')");
      if (*(p++) == '%' && p < ms->p_end)
        p++; /* skip escapes (e.g. '%]') */
    } while (*p != ']');
    return p + 1;
  }
  default: {
    return p;
  }
  }
}

static int match_class(int c, int cl) {
  int res;
  switch (__extension__({
    __typeof__(cl) __x = (cl);
    (void)(__locale_ctype_ptr())[__x];
    (tolower)(__x);
  })) {
  case 'a':
    res = ((((__locale_ctype_ptr()) + sizeof(""[c]))[(int)(c)]) & (01 | 02));
    break;
  case 'c':
    res = ((((__locale_ctype_ptr()) + sizeof(""[c]))[(int)(c)]) & 040);
    break;
  case 'd':
    res = ((((__locale_ctype_ptr()) + sizeof(""[c]))[(int)(c)]) & 04);
    break;
  case 'g':
    res = ((((__locale_ctype_ptr()) + sizeof(""[c]))[(int)(c)]) &
           (020 | 01 | 02 | 04));
    break;
  case 'l':
    res = (((((__locale_ctype_ptr()) + sizeof(""[c]))[(int)(c)]) & (01 | 02)) ==
           02);
    break;
  case 'p':
    res = ((((__locale_ctype_ptr()) + sizeof(""[c]))[(int)(c)]) & 020);
    break;
  case 's':
    res = ((((__locale_ctype_ptr()) + sizeof(""[c]))[(int)(c)]) & 010);
    break;
  case 'u':
    res = (((((__locale_ctype_ptr()) + sizeof(""[c]))[(int)(c)]) & (01 | 02)) ==
           01);
    break;
  case 'w':
    res =
        ((((__locale_ctype_ptr()) + sizeof(""[c]))[(int)(c)]) & (01 | 02 | 04));
    break;
  case 'x':
    res = ((((__locale_ctype_ptr()) + sizeof(""[c]))[(int)(c)]) & (0100 | 04));
    break;
  case 'z':
    res = (c == 0);
    break; /* deprecated option */
  default:
    return (cl == c);
  }
  return ((((((__locale_ctype_ptr()) + sizeof(""[cl]))[(int)(cl)]) &
            (01 | 02)) == 02)
              ? res
              : !res);
}

static int matchbracketclass(int c, const char *p, const char *ec) {
  int sig = 1;
  if (*(p + 1) == '^') {
    sig = 0;
    p++; /* skip the '^' */
  }
  while (++p < ec) {
    if (*p == '%') {
      p++;
      if (match_class(c, ((unsigned char)(*p))))
        return sig;
    } else if ((*(p + 1) == '-') && (p + 2 < ec)) {
      p += 2;
      if (((unsigned char)(*(p - 2))) <= c && c <= ((unsigned char)(*p)))
        return sig;
    } else if (((unsigned char)(*p)) == c)
      return sig;
  }
  return !sig;
}

static int singlematch(MatchState *ms, const char *s, const char *p,
                       const char *ep) {
  if (s >= ms->src_end)
    return 0;
  else {
    int c = ((unsigned char)(*s));
    switch (*p) {
    case '.':
      return 1; /* matches any char */
    case '%':
      return match_class(c, ((unsigned char)(*(p + 1))));
    case '[':
      return matchbracketclass(c, p, ep - 1);
    default:
      return (((unsigned char)(*p)) == c);
    }
  }
}

static const char *matchbalance(MatchState *ms, const char *s, const char *p) {
  if (p >= ms->p_end - 1)
    luaL_error(ms->L, "malformed pattern (missing arguments to '%%b')");
  if (*s != *p)
    return ((void *)0);
  else {
    int b = *p;
    int e = *(p + 1);
    int cont = 1;
    while (++s < ms->src_end) {
      if (*s == e) {
        if (--cont == 0)
          return s + 1;
      } else if (*s == b)
        cont++;
    }
  }
  return ((void *)0); /* string ends out of balance */
}

static const char *max_expand(MatchState *ms, const char *s, const char *p,
                              const char *ep) {
  ptrdiff_t i = 0; /* counts maximum expand for item */
  while (singlematch(ms, s + i, p, ep))
    i++;
  /* keeps trying to match with the maximum repetitions */
  while (i >= 0) {
    const char *res = match(ms, (s + i), ep + 1);
    if (res)
      return res;
    i--; /* else didn't match; reduce 1 repetition to try again */
  }
  return ((void *)0);
}

static const char *min_expand(MatchState *ms, const char *s, const char *p,
                              const char *ep) {
  for (;;) {
    const char *res = match(ms, s, ep + 1);
    if (res != ((void *)0))
      return res;
    else if (singlematch(ms, s, p, ep))
      s++; /* try with one more repetition */
    else
      return ((void *)0);
  }
}

static const char *start_capture(MatchState *ms, const char *s, const char *p,
                                 int what) {
  const char *res;
  int level = ms->level;
  if (level >= 32)
    luaL_error(ms->L, "too many captures");
  ms->capture[level].init = s;
  ms->capture[level].len = what;
  ms->level = level + 1;
  if ((res = match(ms, s, p)) == ((void *)0)) /* match failed? */
    ms->level--;                              /* undo capture */
  return res;
}

static const char *end_capture(MatchState *ms, const char *s, const char *p) {
  int l = capture_to_close(ms);
  const char *res;
  ms->capture[l].len = s - ms->capture[l].init; /* close capture */
  if ((res = match(ms, s, p)) == ((void *)0))   /* match failed? */
    ms->capture[l].len = (-1);                  /* undo capture */
  return res;
}

static const char *match_capture(MatchState *ms, const char *s, int l) {
  size_t len;
  l = check_capture(ms, l);
  len = ms->capture[l].len;
  if ((size_t)(ms->src_end - s) >= len &&
      memcmp(ms->capture[l].init, s, len) == 0)
    return s + len;
  else
    return ((void *)0);
}

static const char *match(MatchState *ms, const char *s, const char *p) {
  if (ms->matchdepth-- == 0)
    luaL_error(ms->L, "pattern too complex");
init:                   /* using goto's to optimize tail recursion */
  if (p != ms->p_end) { /* end of pattern? */
    switch (*p) {
    case '(': {            /* start capture */
      if (*(p + 1) == ')') /* position capture? */
        s = start_capture(ms, s, p + 2, (-2));
      else
        s = start_capture(ms, s, p + 1, (-1));
      break;
    }
    case ')': { /* end capture */
      s = end_capture(ms, s, p + 1);
      break;
    }
    case '$': {
      if ((p + 1) != ms->p_end) /* is the '$' the last char in pattern? */
        goto dflt;              /* no; go to default */
      s = (s == ms->src_end) ? s : ((void *)0); /* check end of string */
      break;
    }
    case '%': { /* escaped sequences not in the format class[*+?-]? */
      switch (*(p + 1)) {
      case 'b': { /* balanced string? */
        s = matchbalance(ms, s, p + 2);
        if (s != ((void *)0)) {
          p += 4;
          goto init; /* return match(ms, s, p + 4); */
        }            /* else fail (s == NULL) */
        break;
      }
      case 'f': { /* frontier? */
        const char *ep;
        char previous;
        p += 2;
        if (*p != '[')
          luaL_error(ms->L, "missing '[' after '%%f' in pattern");
        ep = classend(ms, p); /* points to what is next */
        previous = (s == ms->src_init) ? '\0' : *(s - 1);
        if (!matchbracketclass(((unsigned char)(previous)), p, ep - 1) &&
            matchbracketclass(((unsigned char)(*s)), p, ep - 1)) {
          p = ep;
          goto init; /* return match(ms, s, ep); */
        }
        s = ((void *)0); /* match failed */
        break;
      }
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': { /* capture results (%0-%9)? */
        s = match_capture(ms, s, ((unsigned char)(*(p + 1))));
        if (s != ((void *)0)) {
          p += 2;
          goto init; /* return match(ms, s, p + 2) */
        }
        break;
      }
      default:
        goto dflt;
      }
      break;
    }
    default:
    dflt : {                            /* pattern class plus optional suffix */
      const char *ep = classend(ms, p); /* points to optional suffix */
      /* does not match at least once? */
      if (!singlematch(ms, s, p, ep)) {
        if (*ep == '*' || *ep == '?' || *ep == '-') { /* accept empty? */
          p = ep + 1;
          goto init;       /* return match(ms, s, ep + 1); */
        } else             /* '+' or no suffix */
          s = ((void *)0); /* fail */
      } else {             /* matched once */
        switch (*ep) {     /* handle optional suffix */
        case '?': {        /* optional */
          const char *res;
          if ((res = match(ms, s + 1, ep + 1)) != ((void *)0))
            s = res;
          else {
            p = ep + 1;
            goto init; /* else return match(ms, s, ep + 1); */
          }
          break;
        }
        case '+': /* 1 or more repetitions */
          s++;    /* 1 match already done */
          /* FALLTHROUGH */
        case '*': /* 0 or more repetitions */
          s = max_expand(ms, s, p, ep);
          break;
        case '-': /* 0 or more repetitions (minimum) */
          s = min_expand(ms, s, p, ep);
          break;
        default: /* no suffix */
          s++;
          p = ep;
          goto init; /* return match(ms, s + 1, ep); */
        }
      }
      break;
    }
    }
  }
  ms->matchdepth++;
  return s;
}

static const char *lmemfind(const char *s1, size_t l1, const char *s2,
                            size_t l2) {
  if (l2 == 0)
    return s1; /* empty strings are everywhere */
  else if (l2 > l1)
    return ((void *)0); /* avoids a negative 'l1' */
  else {
    const char *init; /* to search for a '*s2' inside 's1' */
    l2--;             /* 1st char will be checked by 'memchr' */
    l1 = l1 - l2;     /* 's2' cannot be found after that */
    while (l1 > 0 &&
           (init = (const char *)memchr(s1, *s2, l1)) != ((void *)0)) {
      init++; /* 1st char is already checked */
      if (memcmp(init, s2 + 1, l2) == 0)
        return init - 1;
      else { /* correct 'l1' and 's1' to try again */
        l1 -= init - s1;
        s1 = init;
      }
    }
    return ((void *)0); /* not found */
  }
}

static void push_onecapture(MatchState *ms, int i, const char *s,
                            const char *e) {
  if (i >= ms->level) {
    if (i == 0)                         /* ms->level == 0, too */
      lua_pushlstring(ms->L, s, e - s); /* add whole match */
    else
      luaL_error(ms->L, "invalid capture index %%%d", i + 1);
  } else {
    ptrdiff_t l = ms->capture[i].len;
    if (l == (-1))
      luaL_error(ms->L, "unfinished capture");
    if (l == (-2))
      lua_pushinteger(ms->L, (ms->capture[i].init - ms->src_init) + 1);
    else
      lua_pushlstring(ms->L, ms->capture[i].init, l);
  }
}

static int push_captures(MatchState *ms, const char *s, const char *e) {
  int i;
  int nlevels = (ms->level == 0 && s) ? 1 : ms->level;
  luaL_checkstack(ms->L, nlevels, "too many captures");
  for (i = 0; i < nlevels; i++)
    push_onecapture(ms, i, s, e);
  return nlevels; /* number of strings pushed */
}

/* check whether pattern has no special characters */
static int nospecials(const char *p, size_t l) {
  size_t upto = 0;
  do {
    if (strpbrk(p + upto, "^$*+?.([%-"))
      return 0;                   /* pattern has a special character */
    upto += strlen(p + upto) + 1; /* may have more after \0 */
  } while (upto <= l);
  return 1; /* no special chars found */
}

static void prepstate(MatchState *ms, lua_State *L, const char *s, size_t ls,
                      const char *p, size_t lp) {
  ms->L = L;
  ms->matchdepth = 200;
  ms->src_init = s;
  ms->src_end = s + ls;
  ms->p_end = p + lp;
}

static void reprepstate(MatchState *ms) {
  ms->level = 0;
  ((void)0);
}

static int str_find_aux(lua_State *L, int find) {
  size_t ls, lp;
  const char *s = luaL_checklstring(L, 1, &ls);
  const char *p = luaL_checklstring(L, 2, &lp);
  size_t init = posrelatI(luaL_optinteger(L, 3, 1), ls) - 1;
  if (init > ls) {  /* start after string's end? */
    lua_pushnil(L); /* cannot find anything */
    return 1;
  }
  /* explicit request or no special characters? */
  if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {
    /* do a plain search */
    const char *s2 = lmemfind(s + init, ls - init, p, lp);
    if (s2) {
      lua_pushinteger(L, (s2 - s) + 1);
      lua_pushinteger(L, (s2 - s) + lp);
      return 2;
    }
  } else {
    MatchState ms;
    const char *s1 = s + init;
    int anchor = (*p == '^');
    if (anchor) {
      p++;
      lp--; /* skip anchor character */
    }
    prepstate(&ms, L, s, ls, p, lp);
    do {
      const char *res;
      reprepstate(&ms);
      if ((res = match(&ms, s1, p)) != ((void *)0)) {
        if (find) {
          lua_pushinteger(L, (s1 - s) + 1); /* start */
          lua_pushinteger(L, res - s);      /* end */
          return push_captures(&ms, ((void *)0), 0) + 2;
        } else
          return push_captures(&ms, s1, res);
      }
    } while (s1++ < ms.src_end && !anchor);
  }
  lua_pushnil(L); /* not found */
  return 1;
}

static int str_find(lua_State *L) { return str_find_aux(L, 1); }

static int str_match(lua_State *L) { return str_find_aux(L, 0); }

/* state for 'gmatch' */
typedef struct GMatchState {
  const char *src;       /* current position */
  const char *p;         /* pattern */
  const char *lastmatch; /* end of last match */
  MatchState ms;         /* match state */
} GMatchState;

static int gmatch_aux(lua_State *L) {
  GMatchState *gm = (GMatchState *)lua_touserdata(L, ((-1000000 - 1000) - (3)));
  const char *src;
  gm->ms.L = L;
  for (src = gm->src; src <= gm->ms.src_end; src++) {
    const char *e;
    reprepstate(&gm->ms);
    if ((e = match(&gm->ms, src, gm->p)) != ((void *)0) && e != gm->lastmatch) {
      gm->src = gm->lastmatch = e;
      return push_captures(&gm->ms, src, e);
    }
  }
  return 0; /* not found */
}

static int gmatch(lua_State *L) {
  size_t ls, lp;
  const char *s = luaL_checklstring(L, 1, &ls);
  const char *p = luaL_checklstring(L, 2, &lp);
  size_t init = posrelatI(luaL_optinteger(L, 3, 1), ls) - 1;
  GMatchState *gm;
  lua_settop(L, 2); /* keep strings on closure to avoid being collected */
  gm = (GMatchState *)lua_newuserdatauv(L, sizeof(GMatchState), 0);
  if (init > ls)   /* start after string's end? */
    init = ls + 1; /* avoid overflows in 's + init' */
  prepstate(&gm->ms, L, s, ls, p, lp);
  gm->src = s + init;
  gm->p = p;
  gm->lastmatch = ((void *)0);
  lua_pushcclosure(L, gmatch_aux, 3);
  return 1;
}

static void add_s(MatchState *ms, luaL_Buffer *b, const char *s,
                  const char *e) {
  size_t l, i;
  lua_State *L = ms->L;
  const char *news = lua_tolstring(L, 3, &l);
  for (i = 0; i < l; i++) {
    if (news[i] != '%')
      ((void)((b)->n < (b)->size || luaL_prepbuffsize((b), 1)),
       ((b)->b[(b)->n++] = (news[i])));
    else {
      i++; /* skip ESC */
      if (!((((__locale_ctype_ptr()) + sizeof(""[((unsigned char)(news[i]))]))[(
                int)(((unsigned char)(news[i])))]) &
            04)) {
        if (news[i] != '%')
          luaL_error(L, "invalid use of '%c' in replacement string", '%');
        ((void)((b)->n < (b)->size || luaL_prepbuffsize((b), 1)),
         ((b)->b[(b)->n++] = (news[i])));
      } else if (news[i] == '0')
        luaL_addlstring(b, s, e - s);
      else {
        push_onecapture(ms, news[i] - '1', s, e);
        luaL_tolstring(L, -1,
                       ((void *)0)); /* if number, convert it to string */
        (lua_rotate(L, (-2), -1),
         lua_settop(L, -(1) - 1)); /* remove original value */
        luaL_addvalue(b);          /* add capture to accumulated result */
      }
    }
  }
}

static void add_value(MatchState *ms, luaL_Buffer *b, const char *s,
                      const char *e, int tr) {
  lua_State *L = ms->L;
  switch (tr) {
  case 6: {
    int n;
    lua_pushvalue(L, 3);
    n = push_captures(ms, s, e);
    lua_callk(L, (n), (1), 0, ((void *)0));
    break;
  }
  case 5: {
    push_onecapture(ms, 0, s, e);
    lua_gettable(L, 3);
    break;
  }
  default: { /* LUA_TNUMBER or LUA_TSTRING */
    add_s(ms, b, s, e);
    return;
  }
  }
  if (!lua_toboolean(L, -1)) { /* nil or false? */
    lua_settop(L, -(1) - 1);
    lua_pushlstring(L, s, e - s); /* keep original text */
  } else if (!lua_isstring(L, -1))
    luaL_error(L, "invalid replacement value (a %s)",
               lua_typename(L, lua_type(L, (-1))));
  luaL_addvalue(b); /* add result to accumulator */
}

static int str_gsub(lua_State *L) {
  size_t srcl, lp;
  const char *src = luaL_checklstring(L, 1, &srcl);    /* subject */
  const char *p = luaL_checklstring(L, 2, &lp);        /* pattern */
  const char *lastmatch = ((void *)0);                 /* end of last match */
  int tr = lua_type(L, 3);                             /* replacement type */
  lua_Integer max_s = luaL_optinteger(L, 4, srcl + 1); /* max replacements */
  int anchor = (*p == '^');
  lua_Integer n = 0; /* replacement count */
  MatchState ms;
  luaL_Buffer b;
  ((void)((tr == 3 || tr == 4 || tr == 6 || tr == 5) ||
          luaL_typeerror(L, (3), ("string/function/table"))))

      ;
  luaL_buffinit(L, &b);
  if (anchor) {
    p++;
    lp--; /* skip anchor character */
  }
  prepstate(&ms, L, src, srcl, p, lp);
  while (n < max_s) {
    const char *e;
    reprepstate(&ms); /* (re)prepare state for new match */
    if ((e = match(&ms, src, p)) != ((void *)0) &&
        e != lastmatch) { /* match? */
      n++;
      add_value(&ms, &b, src, e, tr); /* add replacement to buffer */
      src = lastmatch = e;
    } else if (src < ms.src_end) /* otherwise, skip one character */
      ((void)((&b)->n < (&b)->size || luaL_prepbuffsize((&b), 1)),
       ((&b)->b[(&b)->n++] = (*src++)));
    else
      break; /* end of subject */
    if (anchor)
      break;
  }
  luaL_addlstring(&b, src, ms.src_end - src);
  luaL_pushresult(&b);
  lua_pushinteger(L, n); /* number of substitutions */
  return 2;
}

/* }====================================================== */

/*
** {======================================================
** STRING FORMAT
** =======================================================
*/
/*
** Maximum size of each formatted item. This maximum size is produced
** by format('%.99f', -maxfloat), and is equal to 99 + 3 ('-', '.',
** and '\0') + number of decimal digits to represent maxfloat (which
** is maximum exponent + 1). (99+3+1 then rounded to 120 for "extra
** expenses", such as locale-dependent stuff)
*/

/* valid flags in a format specification */

/*
** maximum size of each format specification (such as "%-099.99d")
*/

static void addquoted(luaL_Buffer *b, const char *s, size_t len) {
  ((void)((b)->n < (b)->size || luaL_prepbuffsize((b), 1)),
   ((b)->b[(b)->n++] = ('"')));
  while (len--) {
    if (*s == '"' || *s == '\\' || *s == '\n') {
      ((void)((b)->n < (b)->size || luaL_prepbuffsize((b), 1)),
       ((b)->b[(b)->n++] = ('\\')));
      ((void)((b)->n < (b)->size || luaL_prepbuffsize((b), 1)),
       ((b)->b[(b)->n++] = (*s)));
    } else if (((((__locale_ctype_ptr()) + sizeof(""[((unsigned char)(*s))]))[(
                    int)(((unsigned char)(*s)))]) &
                040)) {
      char buff[10];
      if (!((((__locale_ctype_ptr()) +
              sizeof(""[((unsigned char)(*(s + 1)))]))[(
                int)(((unsigned char)(*(s + 1))))]) &
            04))
        snprintf(buff, sizeof(buff), "\\%d", (int)((unsigned char)(*s)));
      else
        snprintf(buff, sizeof(buff), "\\%03d", (int)((unsigned char)(*s)));
      luaL_addstring(b, buff);
    } else
      ((void)((b)->n < (b)->size || luaL_prepbuffsize((b), 1)),
       ((b)->b[(b)->n++] = (*s)));
    s++;
  }
  ((void)((b)->n < (b)->size || luaL_prepbuffsize((b), 1)),
   ((b)->b[(b)->n++] = ('"')));
}

/*
** Serialize a floating-point number in such a way that it can be
** scanned back by Lua. Use hexadecimal format for "common" numbers
** (to preserve precision); inf, -inf, and NaN are handled separately.
** (NaN cannot be expressed as a numeral, so we write '(0/0)' for it.)
*/
static int quotefloat(lua_State *L, char *buff, lua_Number n) {
  const char *s; /* for the fixed representations */
  if (n == (lua_Number)(__builtin_huge_val())) /* inf? */
    s = "1e9999";
  else if (n == -(lua_Number)(__builtin_huge_val())) /* -inf? */
    s = "-1e9999";
  else if (n != n) /* NaN? */
    s = "(0/0)";
  else { /* format number as hexadecimal */
    int nb = ((void)L, snprintf(buff, (120 + (308)),
                                "%"
                                ""
                                "a",
                                (double)(n)));
    /* ensures that 'buff' string uses a dot as the radix character */
    if (memchr(buff, '.', nb) == ((void *)0)) {      /* no dot? */
      char point = (localeconv()->decimal_point[0]); /* try locale point */
      char *ppoint = (char *)memchr(buff, point, nb);
      if (ppoint)
        *ppoint = '.'; /* change it to a dot */
    }
    return nb;
  }
  /* for the fixed representations */
  return snprintf(buff, (120 + (308)), "%s", s);
}

static void addliteral(lua_State *L, luaL_Buffer *b, int arg) {
  switch (lua_type(L, arg)) {
  case 4: {
    size_t len;
    const char *s = lua_tolstring(L, arg, &len);
    addquoted(b, s, len);
    break;
  }
  case 3: {
    char *buff = luaL_prepbuffsize(b, (120 + (308)));
    int nb;
    if (!lua_isinteger(L, arg)) /* float? */
      nb = quotefloat(L, buff, lua_tonumberx(L, (arg), ((void *)0)));
    else { /* integers */
      lua_Integer n = lua_tointegerx(L, (arg), ((void *)0));
      const char *format = (n == (-0x7fffffffffffffffLL - 1)) /* corner case? */
                               ? "0x%"
                                 "ll"
                                 "x" /* use hex */
                               : "%"
                                 "ll"
                                 "d"; /* else use default format */
      nb = snprintf(buff, (120 + (308)), format, (long long)n);
    }
    ((b)->n += (nb));
    break;
  }
  case 0:
  case 1: {
    luaL_tolstring(L, arg, ((void *)0));
    luaL_addvalue(b);
    break;
  }
  default: {
    luaL_argerror(L, arg, "value has no literal form");
  }
  }
}

static const char *scanformat(lua_State *L, const char *strfrmt, char *form) {
  const char *p = strfrmt;
  while (*p != '\0' && strchr("-+ #0", *p) != ((void *)0))
    p++; /* skip flags */
  if ((size_t)(p - strfrmt) >= sizeof("-+ #0") / sizeof(char))
    luaL_error(L, "invalid format (repeated flags)");
  if (((((__locale_ctype_ptr()) +
         sizeof(""[((unsigned char)(*p))]))[(int)(((unsigned char)(*p)))]) &
       04))
    p++; /* skip width */
  if (((((__locale_ctype_ptr()) +
         sizeof(""[((unsigned char)(*p))]))[(int)(((unsigned char)(*p)))]) &
       04))
    p++; /* (2 digits at most) */
  if (*p == '.') {
    p++;
    if (((((__locale_ctype_ptr()) +
           sizeof(""[((unsigned char)(*p))]))[(int)(((unsigned char)(*p)))]) &
         04))
      p++; /* skip precision */
    if (((((__locale_ctype_ptr()) +
           sizeof(""[((unsigned char)(*p))]))[(int)(((unsigned char)(*p)))]) &
         04))
      p++; /* (2 digits at most) */
  }
  if (((((__locale_ctype_ptr()) +
         sizeof(""[((unsigned char)(*p))]))[(int)(((unsigned char)(*p)))]) &
       04))
    luaL_error(L, "invalid format (width or precision too long)");
  *(form++) = '%';
  memcpy(form, strfrmt, ((p - strfrmt) + 1) * sizeof(char));
  form += (p - strfrmt) + 1;
  *form = '\0';
  return p;
}

/*
** add length modifier into formats
*/
static void addlenmod(char *form, const char *lenmod) {
  size_t l = strlen(form);
  size_t lm = strlen(lenmod);
  char spec = form[l - 1];
  strcpy(form + l - 1, lenmod);
  form[l + lm - 1] = spec;
  form[l + lm] = '\0';
}

static int str_format(lua_State *L) {
  int top = lua_gettop(L);
  int arg = 1;
  size_t sfl;
  const char *strfrmt = luaL_checklstring(L, arg, &sfl);
  const char *strfrmt_end = strfrmt + sfl;
  luaL_Buffer b;
  luaL_buffinit(L, &b);
  while (strfrmt < strfrmt_end) {
    if (*strfrmt != '%')
      ((void)((&b)->n < (&b)->size || luaL_prepbuffsize((&b), 1)),
       ((&b)->b[(&b)->n++] = (*strfrmt++)));
    else if (*++strfrmt == '%')
      ((void)((&b)->n < (&b)->size || luaL_prepbuffsize((&b), 1)),
       ((&b)->b[(&b)->n++] = (*strfrmt++))); /* %% */
    else {                                   /* format item */
      char form[32];                         /* to store the format ('%...') */
      char *buff =
          luaL_prepbuffsize(&b, (120 + (308))); /* to put formatted item */
      int nb = 0; /* number of bytes in added item */
      if (++arg > top)
        return luaL_argerror(L, arg, "no value");
      strfrmt = scanformat(L, strfrmt, form);
      switch (*strfrmt++) {
      case 'c': {
        nb =
            snprintf(buff, (120 + (308)), form, (int)luaL_checkinteger(L, arg));
        break;
      }
      case 'd':
      case 'i':
      case 'o':
      case 'u':
      case 'x':
      case 'X': {
        lua_Integer n = luaL_checkinteger(L, arg);
        addlenmod(form, "ll");
        nb = snprintf(buff, (120 + (308)), form, (long long)n);
        break;
      }
      case 'a':
      case 'A':
        addlenmod(form, "");
        nb = ((void)L, snprintf(buff, (120 + (308)), form,
                                (double)(luaL_checknumber(L, arg))));
        break;
      case 'e':
      case 'E':
      case 'f':
      case 'g':
      case 'G': {
        lua_Number n = luaL_checknumber(L, arg);
        addlenmod(form, "");
        nb = snprintf(buff, (120 + (308)), form, (double)n);
        break;
      }
      case 'p': {
        const void *p = lua_topointer(L, arg);
        nb = snprintf(buff, (120 + (308)), form, p);
        break;
      }
      case 'q': {
        if (form[2] != '\0') /* modifiers? */
          return luaL_error(L, "specifier '%%q' cannot have modifiers");
        addliteral(L, &b, arg);
        break;
      }
      case 's': {
        size_t l;
        const char *s = luaL_tolstring(L, arg, &l);
        if (form[2] == '\0') /* no modifiers? */
          luaL_addvalue(&b); /* keep entire string */
        else {
          ((void)((l == strlen(s)) ||
                  luaL_argerror(L, (arg), ("string contains zeros"))));
          if (!strchr(form, '.') && l >= 100) {
            /* no precision and string is too long to be formatted */
            luaL_addvalue(&b); /* keep entire string */
          } else {             /* format the string into 'buff' */
            nb = snprintf(buff, (120 + (308)), form, s);
            lua_settop(L, -(1) - 1); /* remove result from 'luaL_tolstring' */
          }
        }
        break;
      }
      default: { /* also treat cases 'pnLlh' */
        return luaL_error(L, "invalid conversion '%s' to 'format'", form);
      }
      }
      ((void)0);
      ((&b)->n += (nb));
    }
  }
  luaL_pushresult(&b);
  return 1;
}

/* }====================================================== */

/*
** {======================================================
** PACK/UNPACK
** =======================================================
*/

/* value used for padding */

/* maximum size for the binary representation of an integer */

/* number of bits in a character */

/* mask for one character (NB 1's) */

/* size of a lua_Integer */

/* dummy union to get native endianness */
static const union {
  int dummy;
  char little; /* true iff machine is little endian */
} nativeendian = {1};

/* dummy structure to get native alignment requirements */
struct cD {
  char c;
  union {
    double d;
    void *p;
    lua_Integer i;
    lua_Number n;
  } u;
};

/*
** Union for serializing floats
*/
typedef union Ftypes {
  float f;
  double d;
  lua_Number n;
  char buff[5 * sizeof(lua_Number)]; /* enough for any float type */
} Ftypes;

/*
** information to pack/unpack stuff
*/
typedef struct Header {
  lua_State *L;
  int islittle;
  int maxalign;
} Header;

/*
** options for pack/unpack
*/
typedef enum KOption {
  Kint,       /* signed integers */
  Kuint,      /* unsigned integers */
  Kfloat,     /* floating-point numbers */
  Kchar,      /* fixed-length strings */
  Kstring,    /* strings with prefixed length */
  Kzstr,      /* zero-terminated strings */
  Kpadding,   /* padding */
  Kpaddalign, /* padding for alignment */
  Knop        /* no-op (configuration or spaces) */
} KOption;

/*
** Read an integer numeral from string 'fmt' or return 'df' if
** there is no numeral
*/
static int digit(int c) { return '0' <= c && c <= '9'; }

static int getnum(const char **fmt, int df) {
  if (!digit(**fmt)) /* no number? */
    return df;       /* return default value */
  else {
    int a = 0;
    do {
      a = a * 10 + (*((*fmt)++) - '0');
    } while (digit(**fmt) &&
             a <= ((int)(sizeof(size_t) < sizeof(int) ? ((size_t)(~(size_t)0))
                                                      : (size_t)(0x7fffffff)) -
                   9) /
                      10);
    return a;
  }
}

/*
** Read an integer numeral and raises an error if it is larger
** than the maximum size for integers.
*/
static int getnumlimit(Header *h, const char **fmt, int df) {
  int sz = getnum(fmt, df);
  if (sz > 16 || sz <= 0)
    return luaL_error(h->L, "integral size (%d) out of limits [1,%d]", sz, 16);
  return sz;
}

/*
** Initialize Header
*/
static void initheader(lua_State *L, Header *h) {
  h->L = L;
  h->islittle = nativeendian.little;
  h->maxalign = 1;
}

/*
** Read and classify next option. 'size' is filled with option's size.
*/
static KOption getoption(Header *h, const char **fmt, int *size) {
  int opt = *((*fmt)++);
  *size = 0; /* default */
  switch (opt) {
  case 'b':
    *size = sizeof(char);
    return Kint;
  case 'B':
    *size = sizeof(char);
    return Kuint;
  case 'h':
    *size = sizeof(short);
    return Kint;
  case 'H':
    *size = sizeof(short);
    return Kuint;
  case 'l':
    *size = sizeof(long);
    return Kint;
  case 'L':
    *size = sizeof(long);
    return Kuint;
  case 'j':
    *size = sizeof(lua_Integer);
    return Kint;
  case 'J':
    *size = sizeof(lua_Integer);
    return Kuint;
  case 'T':
    *size = sizeof(size_t);
    return Kuint;
  case 'f':
    *size = sizeof(float);
    return Kfloat;
  case 'd':
    *size = sizeof(double);
    return Kfloat;
  case 'n':
    *size = sizeof(lua_Number);
    return Kfloat;
  case 'i':
    *size = getnumlimit(h, fmt, sizeof(int));
    return Kint;
  case 'I':
    *size = getnumlimit(h, fmt, sizeof(int));
    return Kuint;
  case 's':
    *size = getnumlimit(h, fmt, sizeof(size_t));
    return Kstring;
  case 'c':
    *size = getnum(fmt, -1);
    if (*size == -1)
      luaL_error(h->L, "missing size for format option 'c'");
    return Kchar;
  case 'z':
    return Kzstr;
  case 'x':
    *size = 1;
    return Kpadding;
  case 'X':
    return Kpaddalign;
  case ' ':
    break;
  case '<':
    h->islittle = 1;
    break;
  case '>':
    h->islittle = 0;
    break;
  case '=':
    h->islittle = nativeendian.little;
    break;
  case '!':
    h->maxalign = getnumlimit(h, fmt, (__builtin_offsetof(struct cD, u)));
    break;
  default:
    luaL_error(h->L, "invalid format option '%c'", opt);
  }
  return Knop;
}

/*
** Read, classify, and fill other details about the next option.
** 'psize' is filled with option's size, 'notoalign' with its
** alignment requirements.
** Local variable 'size' gets the size to be aligned. (Kpadal option
** always gets its full alignment, other options are limited by
** the maximum alignment ('maxalign'). Kchar option needs no alignment
** despite its size.
*/
static KOption getdetails(Header *h, size_t totalsize, const char **fmt,
                          int *psize, int *ntoalign) {
  KOption opt = getoption(h, fmt, psize);
  int align = *psize;      /* usually, alignment follows size */
  if (opt == Kpaddalign) { /* 'X' gets alignment from following option */
    if (**fmt == '\0' || getoption(h, fmt, &align) == Kchar || align == 0)
      luaL_argerror(h->L, 1, "invalid next option for option 'X'");
  }
  if (align <= 1 || opt == Kchar) /* need no alignment? */
    *ntoalign = 0;
  else {
    if (align > h->maxalign) /* enforce maximum alignment */
      align = h->maxalign;
    if ((align & (align - 1)) != 0) /* is 'align' not a power of 2? */
      luaL_argerror(h->L, 1, "format asks for alignment not power of 2");
    *ntoalign = (align - (int)(totalsize & (align - 1))) & (align - 1);
  }
  return opt;
}

/*
** Pack integer 'n' with 'size' bytes and 'islittle' endianness.
** The final 'if' handles the case when 'size' is larger than
** the size of a Lua integer, correcting the extra sign-extension
** bytes if necessary (by default they would be zeros).
*/
static void packint(luaL_Buffer *b, lua_Unsigned n, int islittle, int size,
                    int neg) {
  char *buff = luaL_prepbuffsize(b, size);
  int i;
  buff[islittle ? 0 : size - 1] = (char)(n & ((1 << 8) - 1)); /* first byte */
  for (i = 1; i < size; i++) {
    n >>= 8;
    buff[islittle ? i : size - 1 - i] = (char)(n & ((1 << 8) - 1));
  }
  if (neg &&
      size > ((int)sizeof(
                 lua_Integer))) { /* negative number need sign extension? */
    for (i = ((int)sizeof(lua_Integer)); i < size;
         i++) /* correct extra bytes */
      buff[islittle ? i : size - 1 - i] = (char)((1 << 8) - 1);
  }
  ((b)->n += (size)); /* add result to buffer */
}

/*
** Copy 'size' bytes from 'src' to 'dest', correcting endianness if
** given 'islittle' is different from native endianness.
*/
static void copywithendian(volatile char *dest, volatile const char *src,
                           int size, int islittle) {
  if (islittle == nativeendian.little) {
    while (size-- != 0)
      *(dest++) = *(src++);
  } else {
    dest += size - 1;
    while (size-- != 0)
      *(dest--) = *(src++);
  }
}

static int str_pack(lua_State *L) {
  luaL_Buffer b;
  Header h;
  const char *fmt =
      (luaL_checklstring(L, (1), ((void *)0))); /* format string */
  int arg = 1;                                  /* current argument to pack */
  size_t totalsize = 0; /* accumulate total size of result */
  initheader(L, &h);
  lua_pushnil(L); /* mark to separate arguments from string buffer */
  luaL_buffinit(L, &b);
  while (*fmt != '\0') {
    int size, ntoalign;
    KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);
    totalsize += ntoalign + size;
    while (ntoalign-- > 0)
      ((void)((&b)->n < (&b)->size || luaL_prepbuffsize((&b), 1)),
       ((&b)->b[(&b)->n++] = (0x00))); /* fill alignment */
    arg++;
    switch (opt) {
    case Kint: { /* signed integers */
      lua_Integer n = luaL_checkinteger(L, arg);
      if (size < ((int)sizeof(lua_Integer))) { /* need overflow check? */
        lua_Integer lim = (lua_Integer)1 << ((size * 8) - 1);
        ((void)((-lim <= n && n < lim) ||
                luaL_argerror(L, (arg), ("integer overflow"))));
      }
      packint(&b, (lua_Unsigned)n, h.islittle, size, (n < 0));
      break;
    }
    case Kuint: { /* unsigned integers */
      lua_Integer n = luaL_checkinteger(L, arg);
      if (size < ((int)sizeof(lua_Integer))) /* need overflow check? */
        ((void)(((lua_Unsigned)n < ((lua_Unsigned)1 << (size * 8))) ||
                luaL_argerror(L, (arg), ("unsigned overflow"))));
      packint(&b, (lua_Unsigned)n, h.islittle, size, 0);
      break;
    }
    case Kfloat: { /* floating-point options */
      volatile Ftypes u;
      char *buff = luaL_prepbuffsize(&b, size);
      lua_Number n = luaL_checknumber(L, arg); /* get argument */
      if (size == sizeof(u.f))
        u.f = (float)n; /* copy it into 'u' */
      else if (size == sizeof(u.d))
        u.d = (double)n;
      else
        u.n = n;
      /* move 'u' to final result, correcting endianness if needed */
      copywithendian(buff, u.buff, size, h.islittle);
      ((&b)->n += (size));
      break;
    }
    case Kchar: { /* fixed-size string */
      size_t len;
      const char *s = luaL_checklstring(L, arg, &len);
      ((void)((len <= (size_t)size) ||
              luaL_argerror(L, (arg), ("string longer than given size"))));
      luaL_addlstring(&b, s, len); /* add string */
      while (len++ < (size_t)size) /* pad extra space */
        ((void)((&b)->n < (&b)->size || luaL_prepbuffsize((&b), 1)),
         ((&b)->b[(&b)->n++] = (0x00)));
      break;
    }
    case Kstring: { /* strings with length count */
      size_t len;
      const char *s = luaL_checklstring(L, arg, &len);
      ((void)((size >= (int)sizeof(size_t) ||
               len < ((size_t)1 << (size * 8))) ||
              luaL_argerror(L, (arg),
                            ("string length does not fit in given size"))))

          ;
      packint(&b, (lua_Unsigned)len, h.islittle, size, 0); /* pack length */
      luaL_addlstring(&b, s, len);
      totalsize += len;
      break;
    }
    case Kzstr: { /* zero-terminated string */
      size_t len;
      const char *s = luaL_checklstring(L, arg, &len);
      ((void)((strlen(s) == len) ||
              luaL_argerror(L, (arg), ("string contains zeros"))));
      luaL_addlstring(&b, s, len);
      ((void)((&b)->n < (&b)->size || luaL_prepbuffsize((&b), 1)),
       ((&b)->b[(&b)->n++] = ('\0'))); /* add zero at the end */
      totalsize += len + 1;
      break;
    }
    case Kpadding:
      ((void)((&b)->n < (&b)->size || luaL_prepbuffsize((&b), 1)),
       ((&b)->b[(&b)->n++] = (0x00))); /* FALLTHROUGH */
    case Kpaddalign:
    case Knop:
      arg--; /* undo increment */
      break;
    }
  }
  luaL_pushresult(&b);
  return 1;
}

static int str_packsize(lua_State *L) {
  Header h;
  const char *fmt =
      (luaL_checklstring(L, (1), ((void *)0))); /* format string */
  size_t totalsize = 0; /* accumulate total size of result */
  initheader(L, &h);
  while (*fmt != '\0') {
    int size, ntoalign;
    KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);
    ((void)((opt != Kstring && opt != Kzstr) ||
            luaL_argerror(L, (1), ("variable-length format"))));
    size += ntoalign; /* total space used by option */
    ((void)((totalsize <= (sizeof(size_t) < sizeof(int)
                               ? ((size_t)(~(size_t)0))
                               : (size_t)(0x7fffffff)) -
                              size) ||
            luaL_argerror(L, (1), ("format result too large"))));
    totalsize += size;
  }
  lua_pushinteger(L, (lua_Integer)totalsize);
  return 1;
}

/*
** Unpack an integer with 'size' bytes and 'islittle' endianness.
** If size is smaller than the size of a Lua integer and integer
** is signed, must do sign extension (propagating the sign to the
** higher bits); if size is larger than the size of a Lua integer,
** it must check the unread bytes to see whether they do not cause an
** overflow.
*/
static lua_Integer unpackint(lua_State *L, const char *str, int islittle,
                             int size, int issigned) {
  lua_Unsigned res = 0;
  int i;
  int limit =
      (size <= ((int)sizeof(lua_Integer))) ? size : ((int)sizeof(lua_Integer));
  for (i = limit - 1; i >= 0; i--) {
    res <<= 8;
    res |= (lua_Unsigned)(unsigned char)str[islittle ? i : size - 1 - i];
  }
  if (size <
      ((int)sizeof(lua_Integer))) { /* real size smaller than lua_Integer? */
    if (issigned) {                 /* needs sign extension? */
      lua_Unsigned mask = (lua_Unsigned)1 << (size * 8 - 1);
      res = ((res ^ mask) - mask); /* do sign extension */
    }
  } else if (size > ((int)sizeof(lua_Integer))) { /* must check unread bytes */
    int mask = (!issigned || (lua_Integer)res >= 0) ? 0 : ((1 << 8) - 1);
    for (i = limit; i < size; i++) {
      if ((unsigned char)str[islittle ? i : size - 1 - i] != mask)
        luaL_error(L, "%d-byte integer does not fit into Lua Integer", size);
    }
  }
  return (lua_Integer)res;
}

static int str_unpack(lua_State *L) {
  Header h;
  const char *fmt = (luaL_checklstring(L, (1), ((void *)0)));
  size_t ld;
  const char *data = luaL_checklstring(L, 2, &ld);
  size_t pos = posrelatI(luaL_optinteger(L, 3, 1), ld) - 1;
  int n = 0; /* number of results */
  ((void)((pos <= ld) ||
          luaL_argerror(L, (3), ("initial position out of string"))));
  initheader(L, &h);
  while (*fmt != '\0') {
    int size, ntoalign;
    KOption opt = getdetails(&h, pos, &fmt, &size, &ntoalign);
    ((void)(((size_t)ntoalign + size <= ld - pos) ||
            luaL_argerror(L, (2), ("data string too short"))));
    pos += ntoalign; /* skip alignment */
    /* stack space for item + next position */
    luaL_checkstack(L, 2, "too many results");
    n++;
    switch (opt) {
    case Kint:
    case Kuint: {
      lua_Integer res =
          unpackint(L, data + pos, h.islittle, size, (opt == Kint));
      lua_pushinteger(L, res);
      break;
    }
    case Kfloat: {
      volatile Ftypes u;
      lua_Number num;
      copywithendian(u.buff, data + pos, size, h.islittle);
      if (size == sizeof(u.f))
        num = (lua_Number)u.f;
      else if (size == sizeof(u.d))
        num = (lua_Number)u.d;
      else
        num = u.n;
      lua_pushnumber(L, num);
      break;
    }
    case Kchar: {
      lua_pushlstring(L, data + pos, size);
      break;
    }
    case Kstring: {
      size_t len = (size_t)unpackint(L, data + pos, h.islittle, size, 0);
      ((void)((len <= ld - pos - size) ||
              luaL_argerror(L, (2), ("data string too short"))));
      lua_pushlstring(L, data + pos + size, len);
      pos += len; /* skip string */
      break;
    }
    case Kzstr: {
      size_t len = (int)strlen(data + pos);
      ((void)((pos + len < ld) ||
              luaL_argerror(L, (2), ("unfinished string for format 'z'"))));
      lua_pushlstring(L, data + pos, len);
      pos += len + 1; /* skip string plus final '\0' */
      break;
    }
    case Kpaddalign:
    case Kpadding:
    case Knop:
      n--; /* undo increment */
      break;
    }
    pos += size;
  }
  lua_pushinteger(L, pos + 1); /* next position */
  return n + 1;
}

/* }====================================================== */

static const luaL_Reg strlib[] = {
    {"byte", str_byte},     {"char", str_char},
    {"dump", str_dump},     {"find", str_find},
    {"format", str_format}, {"gmatch", gmatch},
    {"gsub", str_gsub},     {"len", str_len},
    {"lower", str_lower},   {"match", str_match},
    {"rep", str_rep},       {"reverse", str_reverse},
    {"sub", str_sub},       {"upper", str_upper},
    {"pack", str_pack},     {"packsize", str_packsize},
    {"unpack", str_unpack}, {((void *)0), ((void *)0)}};

static void createmetatable(lua_State *L) {
  /* table to be metatable for strings */
  lua_createtable(
      L, 0, sizeof(stringmetamethods) / sizeof((stringmetamethods)[0]) - 1);
  luaL_setfuncs(L, stringmetamethods, 0);
  lua_pushstring(L, ""
                    "");          /* dummy string */
  lua_pushvalue(L, -2);           /* copy table */
  lua_setmetatable(L, -2);        /* set table as metatable for strings */
  lua_settop(L, -(1) - 1);        /* pop dummy string */
  lua_pushvalue(L, -2);           /* get string library */
  lua_setfield(L, -2, "__index"); /* metatable.__index = string */
  lua_settop(L, -(1) - 1);        /* pop metatable */
}

/*
** Open string library
*/
extern int luaopen_string(lua_State *L) {
  (luaL_checkversion_(L, 504, (sizeof(lua_Integer) * 16 + sizeof(lua_Number))),
   lua_createtable(L, 0, sizeof(strlib) / sizeof((strlib)[0]) - 1),
   luaL_setfuncs(L, strlib, 0));
  createmetatable(L);
  return 1;
}
/*
** $Id: ltablib.c $
** Library for Table Manipulation
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/

/*
** Operations that an object must define to mimic a table
** (some functions only need some of them)
*/
static int checkfield(lua_State *L, const char *key, int n) {
  lua_pushstring(L, key);
  return (lua_rawget(L, -n) != 0);
}

/*
** Check that 'arg' either is a table or can behave like one (that is,
** has a metatable with the required metamethods)
*/
static void checktab(lua_State *L, int arg, int what) {
  if (lua_type(L, arg) != 5) {      /* is it not a table? */
    int n = 1;                      /* number of elements to pop */
    if (lua_getmetatable(L, arg) && /* must have metatable */
        (!(what & 1 /* read */) || checkfield(L, "__index", ++n)) &&
        (!(what & 2 /* write */) || checkfield(L, "__newindex", ++n)) &&
        (!(what & 4 /* length */) || checkfield(L, "__len", ++n))) {
      lua_settop(L, -(n)-1); /* pop metatable and tested metamethods */
    } else
      luaL_checktype(L, arg, 5); /* force an error */
  }
}

static int tinsert(lua_State *L) {
  lua_Integer e = (checktab(L, 1,
                            ((1 /* read */ | 2 /* write */) /* read/write */) |
                                4 /* length */),
                   luaL_len(L, 1)) +
                  1; /* first empty element */
  lua_Integer pos;   /* where to insert new element */
  switch (lua_gettop(L)) {
  case 2: {  /* called with only 2 arguments */
    pos = e; /* insert new element at the end */
    break;
  }
  case 3: {
    lua_Integer i;
    pos = luaL_checkinteger(L, 2); /* 2nd argument is the position */
    /* check whether 'pos' is in [1, e] */
    ((void)(((lua_Unsigned)pos - 1u < (lua_Unsigned)e) ||
            luaL_argerror(L, (2), ("position out of bounds"))));
    for (i = e; i > pos; i--) { /* move up elements */
      lua_geti(L, 1, i - 1);
      lua_seti(L, 1, i); /* t[i] = t[i - 1] */
    }
    break;
  }
  default: {
    return luaL_error(L, "wrong number of arguments to 'insert'");
  }
  }
  lua_seti(L, 1, pos); /* t[pos] = v */
  return 0;
}

static int tremove(lua_State *L) {
  lua_Integer size =
      (checktab(L, 1,
                ((1 /* read */ | 2 /* write */) /* read/write */) |
                    4 /* length */),
       luaL_len(L, 1));
  lua_Integer pos = luaL_optinteger(L, 2, size);
  if (pos != size) /* validate 'pos' if given */
    /* check whether 'pos' is in [1, size + 1] */
    ((void)(((lua_Unsigned)pos - 1u <= (lua_Unsigned)size) ||
            luaL_argerror(L, (1), ("position out of bounds"))));
  lua_geti(L, 1, pos); /* result = t[pos] */
  for (; pos < size; pos++) {
    lua_geti(L, 1, pos + 1);
    lua_seti(L, 1, pos); /* t[pos] = t[pos + 1] */
  }
  lua_pushnil(L);
  lua_seti(L, 1, pos); /* remove entry t[pos] */
  return 1;
}

/*
** Copy elements (1[f], ..., 1[e]) into (tt[t], tt[t+1], ...). Whenever
** possible, copy in increasing order, which is better for rehashing.
** "possible" means destination after original range, or smaller
** than origin, or copying to another table.
*/
static int tmove(lua_State *L) {
  lua_Integer f = luaL_checkinteger(L, 2);
  lua_Integer e = luaL_checkinteger(L, 3);
  lua_Integer t = luaL_checkinteger(L, 4);
  int tt = !(lua_type(L, (5)) <= 0) ? 5 : 1; /* destination table */
  checktab(L, 1, 1 /* read */);
  checktab(L, tt, 2 /* write */);
  if (e >= f) { /* otherwise, nothing to move */
    lua_Integer n, i;
    ((void)((f > 0 || e < 0x7fffffffffffffffLL + f) ||
            luaL_argerror(L, (3), ("too many elements to move"))));
    n = e - f + 1; /* number of elements to move */
    ((void)((t <= 0x7fffffffffffffffLL - n + 1) ||
            luaL_argerror(L, (4), ("destination wrap around"))));
    if (t > e || t <= f || (tt != 1 && !lua_compare(L, 1, tt, 0))) {
      for (i = 0; i < n; i++) {
        lua_geti(L, 1, f + i);
        lua_seti(L, tt, t + i);
      }
    } else {
      for (i = n - 1; i >= 0; i--) {
        lua_geti(L, 1, f + i);
        lua_seti(L, tt, t + i);
      }
    }
  }
  lua_pushvalue(L, tt); /* return destination table */
  return 1;
}

static void addfield(lua_State *L, luaL_Buffer *b, lua_Integer i) {
  lua_geti(L, 1, i);
  if (!lua_isstring(L, -1))
    luaL_error(L, "invalid value (%s) at index %d in table for 'concat'",
               lua_typename(L, lua_type(L, (-1))), i);
  luaL_addvalue(b);
}

static int tconcat(lua_State *L) {
  luaL_Buffer b;
  lua_Integer last =
      (checktab(L, 1, (1 /* read */) | 4 /* length */), luaL_len(L, 1));
  size_t lsep;
  const char *sep = luaL_optlstring(L, 2, "", &lsep);
  lua_Integer i = luaL_optinteger(L, 3, 1);
  last = luaL_optinteger(L, 4, last);
  luaL_buffinit(L, &b);
  for (; i < last; i++) {
    addfield(L, &b, i);
    luaL_addlstring(&b, sep, lsep);
  }
  if (i == last) /* add last value (if interval was not empty) */
    addfield(L, &b, i);
  luaL_pushresult(&b);
  return 1;
}

/*
** {======================================================
** Pack/unpack
** =======================================================
*/

static int tpack(lua_State *L) {
  int i;
  int n = lua_gettop(L);    /* number of elements to pack */
  lua_createtable(L, n, 1); /* create result table */
  lua_rotate(L, (1), 1);    /* put it at index 1 */
  for (i = n; i >= 1; i--)  /* assign elements */
    lua_seti(L, 1, i);
  lua_pushinteger(L, n);
  lua_setfield(L, 1, "n"); /* t.n = number of elements */
  return 1;                /* return table */
}

static int tunpack(lua_State *L) {
  lua_Unsigned n;
  lua_Integer i = luaL_optinteger(L, 2, 1);
  lua_Integer e = ((lua_type(L, ((3))) <= 0) ? (luaL_len(L, 1))
                                             : luaL_checkinteger(L, (3)));
  if (i > e)
    return 0;              /* empty range */
  n = (lua_Unsigned)e - i; /* number of elements minus 1 (avoid overflows) */
  if (n >= (unsigned int)0x7fffffff || !lua_checkstack(L, (int)(++n)))
    return luaL_error(L, "too many results to unpack");
  for (; i < e; i++) { /* push arg[i..e - 1] (to avoid overflows) */
    lua_geti(L, 1, i);
  }
  lua_geti(L, 1, e); /* push last element */
  return (int)n;
}

/* }====================================================== */

/*
** {======================================================
** Quicksort
** (based on 'Algorithms in MODULA-3', Robert Sedgewick;
**  Addison-Wesley, 1993.)
** =======================================================
*/

/* type for array indices */
typedef unsigned int IdxT;

/*
** Produce a "random" 'unsigned int' to randomize pivot choice. This
** macro is used only when 'sort' detects a big imbalance in the result
** of a partition. (If you don't want/need this "randomness", ~0 is a
** good choice.)
*/

/*
 * time.h
 *
 * Struct and function declarations for dealing with time.
 */

/* size of 'e' measured in number of 'unsigned int's */

/*
** Use 'time' and 'clock' as sources of "randomness". Because we don't
** know the types 'clock_t' and 'time_t', we cannot cast them to
** anything without risking overflows. A safe way to use their values
** is to copy them to an array of a known type and use the array values.
*/
static unsigned int l_randomizePivot(void) {
  clock_t c = clock();
  time_t t = time(((void *)0));
  unsigned int buff[(sizeof(c) / sizeof(unsigned int)) +
                    (sizeof(t) / sizeof(unsigned int))];
  unsigned int i, rnd = 0;
  memcpy(buff, &c, (sizeof(c) / sizeof(unsigned int)) * sizeof(unsigned int));
  memcpy(buff + (sizeof(c) / sizeof(unsigned int)), &t,
         (sizeof(t) / sizeof(unsigned int)) * sizeof(unsigned int));
  for (i = 0; i < (sizeof(buff) / sizeof(unsigned int)); i++)
    rnd += buff[i];
  return rnd;
}

/* arrays larger than 'RANLIMIT' may use randomized pivots */

static void set2(lua_State *L, IdxT i, IdxT j) {
  lua_seti(L, 1, i);
  lua_seti(L, 1, j);
}

/*
** Return true iff value at stack index 'a' is less than the value at
** index 'b' (according to the order of the sort).
*/
static int sort_comp(lua_State *L, int a, int b) {
  if ((lua_type(L, (2)) == 0))      /* no function? */
    return lua_compare(L, a, b, 1); /* a < b */
  else {                            /* function */
    int res;
    lua_pushvalue(L, 2);     /* push function */
    lua_pushvalue(L, a - 1); /* -1 to compensate function */
    lua_pushvalue(L, b - 2); /* -2 to compensate function and 'a' */
    lua_callk(L, (2), (1), 0, ((void *)0)); /* call function */
    res = lua_toboolean(L, -1);             /* get result */
    lua_settop(L, -(1) - 1);                /* pop result */
    return res;
  }
}

/*
** Does the partition: Pivot P is at the top of the stack.
** precondition: a[lo] <= P == a[up-1] <= a[up],
** so it only needs to do the partition from lo + 1 to up - 2.
** Pos-condition: a[lo .. i - 1] <= a[i] == P <= a[i + 1 .. up]
** returns 'i'.
*/
static IdxT partition(lua_State *L, IdxT lo, IdxT up) {
  IdxT i = lo;     /* will be incremented before first use */
  IdxT j = up - 1; /* will be decremented before first use */
  /* loop invariant: a[lo .. i] <= P <= a[j .. up] */
  for (;;) {
    /* next loop: repeat ++i while a[i] < P */
    while (lua_geti(L, 1, ++i), sort_comp(L, -1, -2)) {
      if (i == up - 1) /* a[i] < P  but a[up - 1] == P  ?? */
        luaL_error(L, "invalid order function for sorting");
      lua_settop(L, -(1) - 1); /* remove a[i] */
    }
    /* after the loop, a[i] >= P and a[lo .. i - 1] < P */
    /* next loop: repeat --j while P < a[j] */
    while (lua_geti(L, 1, --j), sort_comp(L, -3, -1)) {
      if (j < i) /* j < i  but  a[j] > P ?? */
        luaL_error(L, "invalid order function for sorting");
      lua_settop(L, -(1) - 1); /* remove a[j] */
    }
    /* after the loop, a[j] <= P and a[j + 1 .. up] >= P */
    if (j < i) { /* no elements out of place? */
      /* a[lo .. i - 1] <= P <= a[j + 1 .. i .. up] */
      lua_settop(L, -(1) - 1); /* pop a[j] */
      /* swap pivot (a[up - 1]) with a[i] to satisfy pos-condition */
      set2(L, up - 1, i);
      return i;
    }
    /* otherwise, swap a[i] - a[j] to restore invariant and repeat */
    set2(L, i, j);
  }
}

/*
** Choose an element in the middle (2nd-3th quarters) of [lo,up]
** "randomized" by 'rnd'
*/
static IdxT choosePivot(IdxT lo, IdxT up, unsigned int rnd) {
  IdxT r4 = (up - lo) / 4; /* range/4 */
  IdxT p = rnd % (r4 * 2) + (lo + r4);
  ((void)0);
  return p;
}

/*
** QuickSort algorithm (recursive function)
*/
static void auxsort(lua_State *L, IdxT lo, IdxT up, unsigned int rnd) {
  while (lo < up) { /* loop for tail recursion */
    IdxT p;         /* Pivot index */
    IdxT n;         /* to be used later */
    /* sort elements 'lo', 'p', and 'up' */
    lua_geti(L, 1, lo);
    lua_geti(L, 1, up);
    if (sort_comp(L, -1, -2)) /* a[up] < a[lo]? */
      set2(L, lo, up);        /* swap a[lo] - a[up] */
    else
      lua_settop(L, -(2) - 1);      /* remove both values */
    if (up - lo == 1)               /* only 2 elements? */
      return;                       /* already sorted */
    if (up - lo < 100u || rnd == 0) /* small interval or no randomize? */
      p = (lo + up) / 2;            /* middle element is a good pivot */
    else /* for larger intervals, it is worth a random pivot */
      p = choosePivot(lo, up, rnd);
    lua_geti(L, 1, p);
    lua_geti(L, 1, lo);
    if (sort_comp(L, -2, -1)) /* a[p] < a[lo]? */
      set2(L, p, lo);         /* swap a[p] - a[lo] */
    else {
      lua_settop(L, -(1) - 1); /* remove a[lo] */
      lua_geti(L, 1, up);
      if (sort_comp(L, -1, -2)) /* a[up] < a[p]? */
        set2(L, p, up);         /* swap a[up] - a[p] */
      else
        lua_settop(L, -(2) - 1);
    }
    if (up - lo == 2)       /* only 3 elements? */
      return;               /* already sorted */
    lua_geti(L, 1, p);      /* get middle element (Pivot) */
    lua_pushvalue(L, -1);   /* push Pivot */
    lua_geti(L, 1, up - 1); /* push a[up - 1] */
    set2(L, p, up - 1);     /* swap Pivot (a[p]) with a[up - 1] */
    p = partition(L, lo, up);
    /* a[lo .. p - 1] <= a[p] == P <= a[p + 1 .. up] */
    if (p - lo < up - p) {        /* lower interval is smaller? */
      auxsort(L, lo, p - 1, rnd); /* call recursively for lower interval */
      n = p - lo;                 /* size of smaller interval */
      lo = p + 1; /* tail call for [p + 1 .. up] (upper interval) */
    } else {
      auxsort(L, p + 1, up, rnd); /* call recursively for upper interval */
      n = up - p;                 /* size of smaller interval */
      up = p - 1; /* tail call for [lo .. p - 1]  (lower interval) */
    }
    if ((up - lo) / 128 > n)    /* partition too imbalanced? */
      rnd = l_randomizePivot(); /* try a new randomization */
  }                             /* tail call auxsort(L, lo, up, rnd) */
}

static int sort(lua_State *L) {
  lua_Integer n = (checktab(L, 1,
                            ((1 /* read */ | 2 /* write */) /* read/write */) |
                                4 /* length */),
                   luaL_len(L, 1));
  if (n > 1) { /* non-trivial interval? */
    ((void)((n < 0x7fffffff) || luaL_argerror(L, (1), ("array too big"))));
    if (!(lua_type(L, (2)) <= 0)) /* is there a 2nd argument? */
      luaL_checktype(L, 2, 6);    /* must be a function */
    lua_settop(L, 2);             /* make sure there are two arguments */
    auxsort(L, 1, (IdxT)n, 0);
  }
  return 0;
}

/* }====================================================== */

static const luaL_Reg tab_funcs[] = {
    {"concat", tconcat}, {"insert", tinsert},       {"pack", tpack},
    {"unpack", tunpack}, {"remove", tremove},       {"move", tmove},
    {"sort", sort},      {((void *)0), ((void *)0)}};

extern int luaopen_table(lua_State *L) {
  (luaL_checkversion_(L, 504, (sizeof(lua_Integer) * 16 + sizeof(lua_Number))),
   lua_createtable(L, 0, sizeof(tab_funcs) / sizeof((tab_funcs)[0]) - 1),
   luaL_setfuncs(L, tab_funcs, 0));
  return 1;
}
/*
** $Id: lutf8lib.c $
** Standard library for UTF-8 manipulation
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
        assert.h
*/

/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
void __assert(const char *, int, const char *) __attribute__((__noreturn__));
void __assert_func(const char *, int, const char *, const char *)
    __attribute__((__noreturn__));
/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/

/*
** Integer type for decoded UTF-8 values; MAXUTF needs 31 bits.
*/

typedef unsigned int utfint;
/* from strlib */
/* translate a relative string position: negative means back from end */
static lua_Integer u_posrelat(lua_Integer pos, size_t len) {
  if (pos >= 0)
    return pos;
  else if (0u - (size_t)pos > len)
    return 0;
  else
    return (lua_Integer)len + pos + 1;
}

/*
** Decode one UTF-8 sequence, returning NULL if byte sequence is
** invalid.  The array 'limits' stores the minimum value for each
** sequence length, to check for overlong representations. Its first
** entry forces an error for non-ascii bytes with no continuation
** bytes (count == 0).
*/
static const char *utf8_decode(const char *s, utfint *val, int strict) {
  static const utfint limits[] = {~(utfint)0, 0x80,      0x800,
                                  0x10000u,   0x200000u, 0x4000000u};
  unsigned int c = (unsigned char)s[0];
  utfint res = 0; /* final result */
  if (c < 0x80)   /* ascii? */
    res = c;
  else {
    int count = 0;              /* to count number of continuation bytes */
    for (; c & 0x40; c <<= 1) { /* while it needs continuation bytes... */
      unsigned int cc = (unsigned char)s[++count]; /* read next byte */
      if ((cc & 0xC0) != 0x80)        /* not a continuation byte? */
        return ((void *)0);           /* invalid byte sequence */
      res = (res << 6) | (cc & 0x3F); /* add lower 6 bits from cont. byte */
    }
    res |= ((utfint)(c & 0x7F) << (count * 5)); /* add first byte */
    if (count > 5 || res > 0x7FFFFFFFu || res < limits[count])
      return ((void *)0); /* invalid byte sequence */
    s += count;           /* skip continuation bytes read */
  }
  if (strict) {
    /* check for invalid code points; too large or surrogates */
    if (res > 0x10FFFFu || (0xD800u <= res && res <= 0xDFFFu))
      return ((void *)0);
  }
  if (val)
    *val = res;
  return s + 1; /* +1 to include first byte */
}

/*
** utf8len(s [, i [, j [, lax]]]) --> number of characters that
** start in the range [i,j], or nil + current position if 's' is not
** well formed in that interval
*/
static int utflen(lua_State *L) {
  lua_Integer n = 0; /* counter for the number of characters */
  size_t len;        /* string length in bytes */
  const char *s = luaL_checklstring(L, 1, &len);
  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);
  lua_Integer posj = u_posrelat(luaL_optinteger(L, 3, -1), len);
  int lax = lua_toboolean(L, 4);
  ((void)((1 <= posi && --posi <= (lua_Integer)len) ||
          luaL_argerror(L, (2), ("initial position out of string"))));
  ((void)((--posj < (lua_Integer)len) ||
          luaL_argerror(L, (3), ("final position out of string"))));
  while (posi <= posj) {
    const char *s1 = utf8_decode(s + posi, ((void *)0), !lax);
    if (s1 == ((void *)0)) {        /* conversion error? */
      lua_pushnil(L);               /* return nil ... */
      lua_pushinteger(L, posi + 1); /* ... and current position */
      return 2;
    }
    posi = s1 - s;
    n++;
  }
  lua_pushinteger(L, n);
  return 1;
}

/*
** codepoint(s, [i, [j [, lax]]]) -> returns codepoints for all
** characters that start in the range [i,j]
*/
static int codepoint(lua_State *L) {
  size_t len;
  const char *s = luaL_checklstring(L, 1, &len);
  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);
  lua_Integer pose = u_posrelat(luaL_optinteger(L, 3, posi), len);
  int lax = lua_toboolean(L, 4);
  int n;
  const char *se;
  ((void)((posi >= 1) || luaL_argerror(L, (2), ("out of range"))));
  ((void)((pose <= (lua_Integer)len) ||
          luaL_argerror(L, (3), ("out of range"))));
  if (posi > pose)
    return 0;                    /* empty interval; return no values */
  if (pose - posi >= 0x7fffffff) /* (lua_Integer -> int) overflow? */
    return luaL_error(L, "string slice too long");
  n = (int)(pose - posi) + 1; /* upper bound for number of returns */
  luaL_checkstack(L, n, "string slice too long");
  n = 0;         /* count the number of returns */
  se = s + pose; /* string end */
  for (s += posi - 1; s < se;) {
    utfint code;
    s = utf8_decode(s, &code, !lax);
    if (s == ((void *)0))
      return luaL_error(L, "invalid UTF-8 code");
    lua_pushinteger(L, code);
    n++;
  }
  return n;
}

static void pushutfchar(lua_State *L, int arg) {
  lua_Unsigned code = (lua_Unsigned)luaL_checkinteger(L, arg);
  ((void)((code <= 0x7FFFFFFFu) ||
          luaL_argerror(L, (arg), ("value out of range"))));
  lua_pushfstring(L, "%U", (long)code);
}

/*
** utfchar(n1, n2, ...)  -> char(n1)..char(n2)...
*/
static int utfchar(lua_State *L) {
  int n = lua_gettop(L); /* number of arguments */
  if (n == 1)            /* optimize common case of single char */
    pushutfchar(L, 1);
  else {
    int i;
    luaL_Buffer b;
    luaL_buffinit(L, &b);
    for (i = 1; i <= n; i++) {
      pushutfchar(L, i);
      luaL_addvalue(&b);
    }
    luaL_pushresult(&b);
  }
  return 1;
}

/*
** offset(s, n, [i])  -> index where n-th character counting from
**   position 'i' starts; 0 means character at 'i'.
*/
static int byteoffset(lua_State *L) {
  size_t len;
  const char *s = luaL_checklstring(L, 1, &len);
  lua_Integer n = luaL_checkinteger(L, 2);
  lua_Integer posi = (n >= 0) ? 1 : len + 1;
  posi = u_posrelat(luaL_optinteger(L, 3, posi), len);
  ((void)((1 <= posi && --posi <= (lua_Integer)len) ||
          luaL_argerror(L, (3), ("position out of range"))));
  if (n == 0) {
    /* find beginning of current byte sequence */
    while (posi > 0 && ((*(s + posi) & 0xC0) == 0x80))
      posi--;
  } else {
    if (((*(s + posi) & 0xC0) == 0x80))
      return luaL_error(L, "initial position is a continuation byte");
    if (n < 0) {
      while (n < 0 && posi > 0) { /* move back */
        do {                      /* find beginning of previous character */
          posi--;
        } while (posi > 0 && ((*(s + posi) & 0xC0) == 0x80));
        n++;
      }
    } else {
      n--; /* do not move for 1st character */
      while (n > 0 && posi < (lua_Integer)len) {
        do { /* find beginning of next character */
          posi++;
        } while (((*(s + posi) & 0xC0) == 0x80)); /* (cannot pass final '\0') */
        n--;
      }
    }
  }
  if (n == 0) /* did it find given character? */
    lua_pushinteger(L, posi + 1);
  else /* no such character */
    lua_pushnil(L);
  return 1;
}

static int iter_aux(lua_State *L, int strict) {
  size_t len;
  const char *s = luaL_checklstring(L, 1, &len);
  lua_Integer n = lua_tointegerx(L, (2), ((void *)0)) - 1;
  if (n < 0) /* first iteration? */
    n = 0;   /* start from here */
  else if (n < (lua_Integer)len) {
    n++; /* skip current byte */
    while (((*(s + n) & 0xC0) == 0x80))
      n++; /* and its continuations */
  }
  if (n >= (lua_Integer)len)
    return 0; /* no more codepoints */
  else {
    utfint code;
    const char *next = utf8_decode(s + n, &code, strict);
    if (next == ((void *)0))
      return luaL_error(L, "invalid UTF-8 code");
    lua_pushinteger(L, n + 1);
    lua_pushinteger(L, code);
    return 2;
  }
}

static int iter_auxstrict(lua_State *L) { return iter_aux(L, 1); }

static int iter_auxlax(lua_State *L) { return iter_aux(L, 0); }

static int iter_codes(lua_State *L) {
  int lax = lua_toboolean(L, 2);
  (luaL_checklstring(L, (1), ((void *)0)));
  lua_pushcclosure(L, (lax ? iter_auxlax : iter_auxstrict), 0);
  lua_pushvalue(L, 1);
  lua_pushinteger(L, 0);
  return 3;
}

/* pattern to match a single UTF-8 character */

static const luaL_Reg funcs[] = {{"offset", byteoffset},
                                 {"codepoint", codepoint},
                                 {"char", utfchar},
                                 {"len", utflen},
                                 {"codes", iter_codes},
                                 /* placeholders */
                                 {"charpattern", ((void *)0)},
                                 {((void *)0), ((void *)0)}};

extern int luaopen_utf8(lua_State *L) {
  (luaL_checkversion_(L, 504, (sizeof(lua_Integer) * 16 + sizeof(lua_Number))),
   lua_createtable(L, 0, sizeof(funcs) / sizeof((funcs)[0]) - 1),
   luaL_setfuncs(L, funcs, 0));
  lua_pushlstring(L, "[\0-\x7F\xC2-\xFD][\x80-\xBF]*",
                  sizeof("[\0-\x7F\xC2-\xFD][\x80-\xBF]*") / sizeof(char) - 1);
  lua_setfield(L, -2, "charpattern");
  return 1;
}
/*
** $Id: linit.c $
** Initialization of libraries for lua.c and other clients
** See Copyright Notice in lua.h
*/

/*
** If you embed Lua in your program and need to open the standard
** libraries, call luaL_openlibs in your program. If you need a
** different set of libraries, copy this file to your project and edit
** it to suit your needs.
**
** You can also *preload* libraries, so that a later 'require' can
** open the library, which is already linked to the application.
** For that, do the following code:
**
**  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);
**  lua_pushcfunction(L, luaopen_modname);
**  lua_setfield(L, -2, modname);
**  lua_pop(L, 1);  // remove PRELOAD table
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/

/*
** these libs are loaded by lua.c and are readily available to any Lua
** program
*/
static const luaL_Reg loadedlibs[] = {{"_G", luaopen_base},
                                      {"package", luaopen_package},
                                      {"coroutine", luaopen_coroutine},
                                      {"table", luaopen_table},
                                      {"io", luaopen_io},
                                      {"os", luaopen_os},
                                      {"string", luaopen_string},
                                      {"math", luaopen_math},
                                      {"utf8", luaopen_utf8},
                                      {"debug", luaopen_debug},
                                      {((void *)0), ((void *)0)}};

extern void luaL_openlibs(lua_State *L) {
  const luaL_Reg *lib;
  /* "require" functions from 'loadedlibs' and set results to global table */
  for (lib = loadedlibs; lib->func; lib++) {
    luaL_requiref(L, lib->name, lib->func, 1);
    lua_settop(L, -(1) - 1); /* remove lib */
  }
}

/* lua */

/*
** $Id: lua.c $
** Lua stand-alone interpreter
** See Copyright Notice in lua.h
*/

/*
** $Id: lprefix.h $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */
/*
 * string.h
 *
 * Definitions for memory and string functions.
 */

/*
** $Id: lua.h $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/

/*
** $Id: lauxlib.h $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/
/*
** $Id: lualib.h $
** Lua standard libraries
** See Copyright Notice in lua.h
*/
static lua_State *globalL = ((void *)0);

static const char *progname = "lua";

/*
** Hook set by signal function to stop the interpreter.
*/
static void lstop(lua_State *L, lua_Debug *ar) {
  (void)ar;                          /* unused arg. */
  lua_sethook(L, ((void *)0), 0, 0); /* reset hook */
  luaL_error(L, "interrupted!");
}

/*
** Function to be called at a C signal. Because a C signal cannot
** just change a Lua state (as there is no proper synchronization),
** this function only sets a hook that, when called, will stop the
** interpreter.
*/
static void laction(int i) {
  signal(i, ((_sig_func_ptr)0) /* Default action */
  ); /* if another SIGINT happens, terminate process */
  lua_sethook(globalL, lstop, (1 << 0) | (1 << 1) | (1 << 3), 1);
}

static void print_usage(const char *badoption) {
  (fprintf(((__getreent())->_stderr), ("%s: "), (progname)),
   fflush(((__getreent())->_stderr)));
  if (badoption[1] == 'e' || badoption[1] == 'l')
    (fprintf(((__getreent())->_stderr), ("'%s' needs argument\n"), (badoption)),
     fflush(((__getreent())->_stderr)));
  else
    (fprintf(((__getreent())->_stderr), ("unrecognized option '%s'\n"),
             (badoption)),
     fflush(((__getreent())->_stderr)));
  (fprintf(((__getreent())->_stderr),
           ("usage: %s [options] [script [args]]\n"
            "Available options are:\n"
            "  -e stat  execute string 'stat'\n"
            "  -i       enter interactive mode after executing 'script'\n"
            "  -l name  require library 'name' into global 'name'\n"
            "  -v       show version information\n"
            "  -E       ignore environment variables\n"
            "  --       stop handling options\n"
            "  -        stop handling options and execute stdin\n"),
           (progname)),
   fflush(((__getreent())->_stderr)));
}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message(const char *pname, const char *msg) {
  if (pname)
    (fprintf(((__getreent())->_stderr), ("%s: "), (pname)),
     fflush(((__getreent())->_stderr)));
  (fprintf(((__getreent())->_stderr), ("%s\n"), (msg)),
   fflush(((__getreent())->_stderr)));
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report(lua_State *L, int status) {
  if (status != 0) {
    const char *msg = lua_tolstring(L, (-1), ((void *)0));
    l_message(progname, msg);
    lua_settop(L, -(1) - 1); /* remove message */
  }
  return status;
}

/*
** Message handler used to run all chunks
*/
static int msghandler(lua_State *L) {
  const char *msg = lua_tolstring(L, (1), ((void *)0));
  if (msg == ((void *)0)) {                  /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") && /* does it have a metamethod */
        lua_type(L, -1) == 4)                /* that produces a string? */
      return 1;                              /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                            lua_typename(L, lua_type(L, (1))));
  }
  luaL_traceback(L, L, msg, 1); /* append a standard traceback */
  return 1;                     /* return the traceback */
}

/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/
static int docall(lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;      /* function index */
  lua_pushcclosure(L, (msghandler), 0); /* push message handler */
  lua_rotate(L, (base), 1);             /* put it under function and args */
  globalL = L;                          /* to be available to 'laction' */
  signal(2                              /* interrupt */
         ,
         laction); /* set C-signal handler */
  status = lua_pcallk(L, (narg), (nres), (base), 0, ((void *)0));
  signal(2 /* interrupt */
         ,
         ((_sig_func_ptr)0) /* Default action */
  );                        /* reset C-signal handler */
  (lua_rotate(L, (base), -1),
   lua_settop(L, -(1) - 1)); /* remove message handler from the stack */
  return status;
}

static void print_version(void) {
  fwrite(("Lua "
          "5"
          "."
          "4"
          "."
          "0"
          "  Copyright (C) 1994-2019 Lua.org, PUC-Rio"),
         sizeof(char),
         (strlen("Lua "
                 "5"
                 "."
                 "4"
                 "."
                 "0"
                 "  Copyright (C) 1994-2019 Lua.org, PUC-Rio")),
         ((__getreent())->_stdout));
  (fwrite(("\n"), sizeof(char), (1), ((__getreent())->_stdout)),
   fflush(((__getreent())->_stdout)));
}

/*
** Create the 'arg' table, which stores all arguments from the
** command line ('argv'). It should be aligned so that, at index 0,
** it has 'argv[script]', which is the script name. The arguments
** to the script (everything after 'script') go to positive indices;
** other arguments (before the script name) go to negative indices.
** If there is no script name, assume interpreter's name as base.
*/
static void createargtable(lua_State *L, char **argv, int argc, int script) {
  int i, narg;
  if (script == argc)
    script = 0;               /* no script name? */
  narg = argc - (script + 1); /* number of positive indices */
  lua_createtable(L, narg, script + 1);
  for (i = 0; i < argc; i++) {
    lua_pushstring(L, argv[i]);
    lua_rawseti(L, -2, i - script);
  }
  lua_setglobal(L, "arg");
}

static int dochunk(lua_State *L, int status) {
  if (status == 0)
    status = docall(L, 0, 0);
  return report(L, status);
}

static int dofile(lua_State *L, const char *name) {
  return dochunk(L, luaL_loadfilex(L, name, ((void *)0)));
}

static int dostring(lua_State *L, const char *s, const char *name) {
  return dochunk(L, luaL_loadbufferx(L, s, strlen(s), name, ((void *)0)));
}

/*
** Calls 'require(name)' and stores the result in a global variable
** with the given name.
*/
static int dolibrary(lua_State *L, const char *name) {
  int status;
  lua_getglobal(L, "require");
  lua_pushstring(L, name);
  status = docall(L, 1, 1); /* call 'require(name)' */
  if (status == 0)
    lua_setglobal(L, name); /* global[name] = require return */
  return report(L, status);
}

/*
** Push on the stack the contents of table 'arg' from 1 to #arg
*/
static int pushargs(lua_State *L) {
  int i, n;
  if (lua_getglobal(L, "arg") != 5)
    luaL_error(L, "'arg' is not a table");
  n = (int)luaL_len(L, -1);
  luaL_checkstack(L, n + 3, "too many arguments to script");
  for (i = 1; i <= n; i++)
    lua_rawgeti(L, -i, i);
  (lua_rotate(L, (-i), -1),
   lua_settop(L, -(1) - 1)); /* remove table from the stack */
  return n;
}

static int handle_script(lua_State *L, char **argv) {
  int status;
  const char *fname = argv[0];
  if (strcmp(fname, "-") == 0 && strcmp(argv[-1], "--") != 0)
    fname = ((void *)0); /* stdin */
  status = luaL_loadfilex(L, fname, ((void *)0));
  if (status == 0) {
    int n = pushargs(L); /* push arguments to script */
    status = docall(L, n, (-1));
  }
  return report(L, status);
}

/* bits of various argument indicators in 'args' */

/*
** Traverses all arguments from 'argv', returning a mask with those
** needed before running any Lua code (or an error code if it finds
** any invalid argument). 'first' returns the first not-handled argument
** (either the script name or a bad argument in case of error).
*/
static int collectargs(char **argv, int *first) {
  int args = 0;
  int i;
  for (i = 1; argv[i] != ((void *)0); i++) {
    *first = i;
    if (argv[i][0] != '-')         /* not an option? */
      return args;                 /* stop handling options */
    switch (argv[i][1]) {          /* else check option */
    case '-':                      /* '--' */
      if (argv[i][2] != '\0')      /* extra characters after '--'? */
        return 1 /* bad option */; /* invalid option */
      *first = i + 1;
      return args;
    case '\0':     /* '-' */
      return args; /* script "name" is '-' */
    case 'E':
      if (argv[i][2] != '\0')      /* extra characters after 1st? */
        return 1 /* bad option */; /* invalid option */
      args |= 16 /* -E */;
      break;
    case 'i':
      args |= 2 /* -i */; /* (-i implies -v) */ /* FALLTHROUGH */
    case 'v':
      if (argv[i][2] != '\0')      /* extra characters after 1st? */
        return 1 /* bad option */; /* invalid option */
      args |= 4 /* -v */;
      break;
    case 'e':
      args |= 8 /* -e */;       /* FALLTHROUGH */
    case 'l':                   /* both options need an argument */
      if (argv[i][2] == '\0') { /* no concatenated argument? */
        i++;                    /* try next 'argv' */
        if (argv[i] == ((void *)0) || argv[i][0] == '-')
          return 1 /* bad option */; /* no next argument or it is another option
                                      */
      }
      break;
    default: /* invalid option */
      return 1 /* bad option */;
    }
  }
  *first = i; /* no script name */
  return args;
}

/*
** Processes options 'e' and 'l', which involve running Lua code.
** Returns 0 if some code raises an error.
*/
static int runargs(lua_State *L, char **argv, int n) {
  int i;
  for (i = 1; i < n; i++) {
    int option = argv[i][1];
    ((void)0); /* already checked */
    if (option == 'e' || option == 'l') {
      int status;
      const char *extra = argv[i] + 2; /* both options need an argument */
      if (*extra == '\0')
        extra = argv[++i];
      ((void)0);
      status = (option == 'e') ? dostring(L, extra, "=(command line)")
                               : dolibrary(L, extra);
      if (status != 0)
        return 0;
    }
  }
  return 1;
}

static int handle_luainit(lua_State *L) {
  const char *name = "="
                     "LUA_INIT"
                     "_"
                     "5"
                     "_"
                     "4";
  const char *init = getenv(name + 1);
  if (init == ((void *)0)) {
    name = "="
           "LUA_INIT";
    init = getenv(name + 1); /* try alternative name */
  }
  if (init == ((void *)0))
    return 0;
  else if (init[0] == '@')
    return dofile(L, init + 1);
  else
    return dostring(L, init, name);
}

/*
** {==================================================================
** Read-Eval-Print Loop (REPL)
** ===================================================================
*/
/*
** lua_stdin_is_tty detects whether the standard input is a 'tty' (that
** is, whether we're running lua interactively).
*/
/* ISO C definition */

/*
** lua_readline defines how to show a prompt and then read a line from
** the standard input.
** lua_saveline defines how to "save" a read line in a "history".
** lua_freeline defines how to free a line read by lua_readline.
*/
/*
** Returns the string to be used as a prompt by the interpreter.
*/
static const char *get_prompt(lua_State *L, int firstline) {
  const char *p;
  lua_getglobal(L, firstline ? "_PROMPT" : "_PROMPT2");
  p = lua_tolstring(L, (-1), ((void *)0));
  if (p == ((void *)0))
    p = (firstline ? "> " : ">> ");
  return p;
}

/* mark in error messages for incomplete statements */

/*
** Check whether 'status' signals a syntax error and the error
** message at the top of the stack ends with the above mark for
** incomplete statements.
*/
static int incomplete(lua_State *L, int status) {
  if (status == 3) {
    size_t lmsg;
    const char *msg = lua_tolstring(L, -1, &lmsg);
    if (lmsg >= (sizeof("<eof>") / sizeof(char) - 1) &&
        strcmp(msg + lmsg - (sizeof("<eof>") / sizeof(char) - 1), "<eof>") ==
            0) {
      lua_settop(L, -(1) - 1);
      return 1;
    }
  }
  return 0; /* else... */
}

/*
** Prompt the user, read a line, and push it into the Lua stack.
*/
static int pushline(lua_State *L, int firstline) {
  char buffer[512];
  char *b = buffer;
  size_t l;
  const char *prmt = get_prompt(L, firstline);
  int readstatus = ((void)L, fputs(prmt, ((__getreent())->_stdout)),
                    fflush(((__getreent())->_stdout)),
                    /* show prompt */ fgets(b, 512, ((__getreent())->_stdin)) !=
                        ((void *)0)) /* get line */;
  if (readstatus == 0)
    return 0;              /* no input (prompt will be popped by caller) */
  lua_settop(L, -(1) - 1); /* remove prompt */
  l = strlen(b);
  if (l > 0 && b[l - 1] == '\n') /* line ends with newline? */
    b[--l] = '\0';               /* remove it */
  if (firstline && b[0] == '=')  /* for compatibility with 5.2, ... */
    lua_pushfstring(L, "return %s", b + 1); /* change '=' to 'return' */
  else
    lua_pushlstring(L, b, l);
  {
    (void)L;
    (void)b;
  };
  return 1;
}

/*
** Try to compile line on the stack as 'return <line>;'; on return, stack
** has either compiled chunk or original line (if compilation failed).
*/
static int addreturn(lua_State *L) {
  const char *line = lua_tolstring(L, (-1), ((void *)0)); /* original line */
  const char *retline = lua_pushfstring(L, "return %s;", line);
  int status =
      luaL_loadbufferx(L, retline, strlen(retline), "=stdin", ((void *)0));
  if (status == 0) {
    (lua_rotate(L, (-2), -1),
     lua_settop(L, -(1) - 1)); /* remove modified line */
    if (line[0] != '\0')       /* non empty? */
    {
      (void)L;
      (void)line;
    }; /* keep history */
  } else
    lua_settop(
        L, -(2) - 1); /* pop result from 'luaL_loadbuffer' and modified line */
  return status;
}

/*
** Read multiple lines until a complete Lua statement
*/
static int multiline(lua_State *L) {
  for (;;) { /* repeat until gets a complete statement */
    size_t len;
    const char *line = lua_tolstring(L, 1, &len); /* get what it has */
    int status =
        luaL_loadbufferx(L, line, len, "=stdin", ((void *)0)); /* try it */
    if (!incomplete(L, status) || !pushline(L, 0)) {
      {
        (void)L;
        (void)line;
      };             /* keep history */
      return status; /* cannot or should not try to add continuation line */
    }
    lua_pushstring(L, ""
                      "\n"); /* add newline... */
    lua_rotate(L, (-2), 1);  /* ...between the two lines */
    lua_concat(L, 3);        /* join them */
  }
}

/*
** Read a line and try to load (compile) it first as an expression (by
** adding "return " in front of it) and second as a statement. Return
** the final status of load/call with the resulting function (if any)
** in the top of the stack.
*/
static int loadline(lua_State *L) {
  int status;
  lua_settop(L, 0);
  if (!pushline(L, 1))
    return -1;                      /* no input */
  if ((status = addreturn(L)) != 0) /* 'return ...' did not work? */
    status = multiline(L); /* try as command, maybe with continuation lines */
  (lua_rotate(L, (1), -1),
   lua_settop(L, -(1) - 1)); /* remove line from the stack */
  ((void)0);
  return status;
}

/*
** Prints (calling the Lua 'print' function) any values on the stack
*/
static void l_print(lua_State *L) {
  int n = lua_gettop(L);
  if (n > 0) { /* any result to be printed? */
    luaL_checkstack(L, 20, "too many results to print");
    lua_getglobal(L, "print");
    lua_rotate(L, (1), 1);
    if (lua_pcallk(L, (n), (0), (0), 0, ((void *)0)) != 0)
      l_message(progname, lua_pushfstring(L, "error calling 'print' (%s)",
                                          lua_tolstring(L, (-1), ((void *)0))));
  }
}

/*
** Do the REPL: repeatedly read (load) a line, evaluate (call) it, and
** print any results.
*/
static void doREPL(lua_State *L) {
  int status;
  const char *oldprogname = progname;
  progname = ((void *)0); /* no 'progname' on errors in interactive mode */
  ((void)L);
  while ((status = loadline(L)) != -1) {
    if (status == 0)
      status = docall(L, 0, (-1));
    if (status == 0)
      l_print(L);
    else
      report(L, status);
  }
  lua_settop(L, 0); /* clear stack */
  (fwrite(("\n"), sizeof(char), (1), ((__getreent())->_stdout)),
   fflush(((__getreent())->_stdout)));
  progname = oldprogname;
}

/* }================================================================== */

/*
** Main body of stand-alone interpreter (to be called in protected mode).
** Reads the options and handles them all.
*/
static int pmain(lua_State *L) {
  int argc = (int)lua_tointegerx(L, (1), ((void *)0));
  char **argv = (char **)lua_touserdata(L, 2);
  int script;
  int args = collectargs(argv, &script);
  luaL_checkversion_(
      L, 504,
      (sizeof(lua_Integer) * 16 +
       sizeof(lua_Number))); /* check that interpreter has correct version */
  if (argv[0] && argv[0][0])
    progname = argv[0];
  if (args == 1 /* bad option */) { /* bad arg? */
    print_usage(argv[script]);      /* 'script' has index of bad arg. */
    return 0;
  }
  if (args & 4 /* -v */) /* option '-v'? */
    print_version();
  if (args & 16 /* -E */) { /* option '-E'? */
    lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */
    lua_setfield(L, (-1000000 - 1000), "LUA_NOENV");
  }
  luaL_openlibs(L);                      /* open standard libraries */
  createargtable(L, argv, argc, script); /* create table 'arg' */
  lua_gc(L, 10, 0, 0);                   /* GC in generational mode */
  if (!(args & 16 /* -E */)) {           /* no option '-E'? */
    if (handle_luainit(L) != 0)          /* run LUA_INIT */
      return 0;                          /* error running LUA_INIT */
  }
  if (!runargs(L, argv, script)) /* execute arguments -e and -l */
    return 0;                    /* something failed */
  if (script < argc &&           /* execute main script (if there is one) */
      handle_script(L, argv + script) != 0)
    return 0;
  if (args & 2 /* -i */) /* -i option? */
    doREPL(L);           /* do read-eval-print loop */
  else if (script == argc &&
           !(args & (8 /* -e */ | 4 /* -v */))) { /* no arguments? */
    if (1 /* assume stdin is a tty */) { /* running in interactive mode? */
      print_version();
      doREPL(L); /* do read-eval-print loop */
    } else
      dofile(L, ((void *)0)); /* executes stdin as a file */
  }
  lua_pushboolean(L, 1); /* signal no errors */
  return 1;
}

int main(int argc, char **argv) {
  int status, result;
  lua_State *L = luaL_newstate(); /* create state */
  if (L == ((void *)0)) {
    l_message(argv[0], "cannot create state: not enough memory");
    return 1;
  }
  lua_pushcclosure(L, (&pmain), 0); /* to call 'pmain' in protected mode */
  lua_pushinteger(L, argc);         /* 1st argument */
  lua_pushlightuserdata(L, argv);   /* 2nd argument */
  status = lua_pcallk(L, (2), (1), (0), 0, ((void *)0)); /* do the call */
  result = lua_toboolean(L, -1);                         /* get result */
  report(L, status);
  lua_close(L);
  return (result && status == 0) ? 0 : 1;
}

/* luac */
